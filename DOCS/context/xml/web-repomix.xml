This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
convex/_generated/api.d.ts
convex/_generated/api.js
convex/_generated/dataModel.d.ts
convex/_generated/server.d.ts
convex/_generated/server.js
convex/agents.ts
convex/aiPipeline.ts
convex/aiServices.ts
convex/auth.config.ts
convex/auth.ts
convex/children.ts
convex/conversations.ts
convex/convex.config.ts
convex/crons.ts
convex/emailActions.ts
convex/emails.ts
convex/http.ts
convex/knowledge.ts
convex/knowledgeBase.ts
convex/messages.ts
convex/README.md
convex/schema.ts
convex/test_knowledge.py
convex/toys.ts
convex/tsconfig.json
convex/voices.ts
debug-auth.js
eslint.config.mjs
lib/webrtc-client.ts
next.config.ts
package.json
postcss.config.mjs
README.md
scripts/create-test-toy.js
scripts/test-ai-pipeline.ts
scripts/test-stt-llm.mjs
scripts/test-toy-backend.mjs
src/app/api/auth/[...all]/route.ts
src/app/auth/page.tsx
src/app/dashboard/chat/page.tsx
src/app/dashboard/history/page.tsx
src/app/dashboard/page.tsx
src/app/dashboard/toys/edit/[toyId]/page.tsx
src/app/demo/page.tsx
src/app/forgot-password/page.tsx
src/app/globals.css
src/app/layout.tsx
src/app/lib/pixel-retroui-setup.js
src/app/page.tsx
src/app/pricing/page.tsx
src/app/providers/ConvexClientProvider.tsx
src/components/chat/ChatInterface.tsx
src/components/dashboard/EditToyForm.tsx
src/components/dashboard/MyToysGrid.tsx
src/components/dashboard/steps/CompletionStep.tsx
src/components/dashboard/steps/DeviceStep.tsx
src/components/dashboard/steps/ForKidsToggleStep.tsx
src/components/dashboard/steps/KnowledgeStep.tsx
src/components/dashboard/steps/PersonalityStep.tsx
src/components/dashboard/steps/ReviewStep.tsx
src/components/dashboard/steps/SafetyStep.tsx
src/components/dashboard/steps/ToyProfileStep.tsx
src/components/dashboard/steps/VoiceStep.tsx
src/components/dashboard/steps/WelcomeStep.tsx
src/components/dashboard/ToyControlsHeader.tsx
src/components/dashboard/ToyDialogs.tsx
src/components/dashboard/ToyEmptyState.tsx
src/components/dashboard/ToyGridItem.tsx
src/components/dashboard/ToyListItem.tsx
src/components/dashboard/ToyWizard.tsx
src/components/guardian/ActiveAlertsCard.tsx
src/components/guardian/ChildProfilesCard.tsx
src/components/guardian/GuardianDashboard.tsx
src/components/guardian/GuardianHeader.tsx
src/components/guardian/LiveMonitoring.old.tsx
src/components/guardian/LiveMonitoring.tsx
src/components/guardian/OverviewTab.tsx
src/components/guardian/QuickStatsCards.tsx
src/components/guardian/SafetyAnalytics.tsx
src/components/guardian/SafetyControls.tsx
src/components/history/ConversationAnalytics.tsx
src/components/history/ConversationDetails.tsx
src/components/history/ConversationList.tsx
src/components/history/ConversationViewer.tsx
src/components/index.ts
src/components/ui/accordion.tsx
src/components/ui/alert-dialog.tsx
src/components/ui/alert.tsx
src/components/ui/avatar.tsx
src/components/ui/badge.tsx
src/components/ui/button.tsx
src/components/ui/card.tsx
src/components/ui/checkbox.tsx
src/components/ui/dialog.tsx
src/components/ui/dropdown-menu.tsx
src/components/ui/input.tsx
src/components/ui/label.tsx
src/components/ui/progress.tsx
src/components/ui/radio-group.tsx
src/components/ui/scroll-area.tsx
src/components/ui/select.tsx
src/components/ui/separator.tsx
src/components/ui/skeleton.tsx
src/components/ui/slider.tsx
src/components/ui/switch.tsx
src/components/ui/tabs.tsx
src/components/ui/textarea.tsx
src/components/ui/tooltip.tsx
src/components/voice/VoiceGallery.tsx
src/components/voice/VoicePreview.tsx
src/components/voice/VoiceUploader.tsx
src/lib/audio.ts
src/lib/auth-client.ts
src/lib/auth.ts
src/lib/utils.ts
src/middleware.ts
src/stores/toyWizardStore.ts
src/stores/useAuthStore.ts
src/stores/useDeviceStore.ts
src/stores/useToysStore.ts
src/types/history.ts
tailwind.config.ts
TEST_GUIDE.md
test-action.js
test-auth.js
test-chat.js
test-prod-convex.js
test-toy-update.js
tsconfig.json
vercel.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="convex/_generated/api.d.ts">
/* eslint-disable */
/**
 * Generated `api` utility.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import type * as agents from "../agents.js";
import type * as aiPipeline from "../aiPipeline.js";
import type * as aiServices from "../aiServices.js";
import type * as auth from "../auth.js";
import type * as children from "../children.js";
import type * as conversations from "../conversations.js";
import type * as crons from "../crons.js";
import type * as emailActions from "../emailActions.js";
import type * as emails from "../emails.js";
import type * as http from "../http.js";
import type * as knowledge from "../knowledge.js";
import type * as knowledgeBase from "../knowledgeBase.js";
import type * as messages from "../messages.js";
import type * as toys from "../toys.js";
import type * as voices from "../voices.js";

import type {
  ApiFromModules,
  FilterApi,
  FunctionReference,
} from "convex/server";

/**
 * A utility for referencing Convex functions in your app's API.
 *
 * Usage:
 * ```js
 * const myFunctionReference = api.myModule.myFunction;
 * ```
 */
declare const fullApi: ApiFromModules<{
  agents: typeof agents;
  aiPipeline: typeof aiPipeline;
  aiServices: typeof aiServices;
  auth: typeof auth;
  children: typeof children;
  conversations: typeof conversations;
  crons: typeof crons;
  emailActions: typeof emailActions;
  emails: typeof emails;
  http: typeof http;
  knowledge: typeof knowledge;
  knowledgeBase: typeof knowledgeBase;
  messages: typeof messages;
  toys: typeof toys;
  voices: typeof voices;
}>;
declare const fullApiWithMounts: typeof fullApi;

export declare const api: FilterApi<
  typeof fullApiWithMounts,
  FunctionReference<any, "public">
>;
export declare const internal: FilterApi<
  typeof fullApiWithMounts,
  FunctionReference<any, "internal">
>;

export declare const components: {
  betterAuth: {
    adapterTest: {
      count: FunctionReference<"query", "internal", any, any>;
      create: FunctionReference<"mutation", "internal", any, any>;
      delete: FunctionReference<"mutation", "internal", any, any>;
      deleteMany: FunctionReference<"mutation", "internal", any, any>;
      findMany: FunctionReference<"query", "internal", any, any>;
      findOne: FunctionReference<"query", "internal", any, any>;
      isAuthenticated: FunctionReference<"query", "internal", {}, any>;
      update: FunctionReference<"mutation", "internal", any, any>;
      updateMany: FunctionReference<"mutation", "internal", any, any>;
    };
    lib: {
      create: FunctionReference<
        "mutation",
        "internal",
        {
          input:
            | {
                data: {
                  banExpires?: null | number;
                  banReason?: null | string;
                  banned?: null | boolean;
                  createdAt: number;
                  displayUsername?: null | string;
                  email: string;
                  emailVerified: boolean;
                  image?: null | string;
                  isAnonymous?: null | boolean;
                  name: string;
                  phoneNumber?: null | string;
                  phoneNumberVerified?: null | boolean;
                  role?: null | string;
                  stripeCustomerId?: null | string;
                  teamId?: null | string;
                  twoFactorEnabled?: null | boolean;
                  updatedAt: number;
                  userId?: null | string;
                  username?: null | string;
                };
                model: "user";
              }
            | {
                data: {
                  activeOrganizationId?: null | string;
                  activeTeamId?: null | string;
                  createdAt: number;
                  expiresAt: number;
                  impersonatedBy?: null | string;
                  ipAddress?: null | string;
                  token: string;
                  updatedAt: number;
                  userAgent?: null | string;
                  userId: string;
                };
                model: "session";
              }
            | {
                data: {
                  accessToken?: null | string;
                  accessTokenExpiresAt?: null | number;
                  accountId: string;
                  createdAt: number;
                  idToken?: null | string;
                  password?: null | string;
                  providerId: string;
                  refreshToken?: null | string;
                  refreshTokenExpiresAt?: null | number;
                  scope?: null | string;
                  updatedAt: number;
                  userId: string;
                };
                model: "account";
              }
            | {
                data: {
                  createdAt?: null | number;
                  expiresAt: number;
                  identifier: string;
                  updatedAt?: null | number;
                  value: string;
                };
                model: "verification";
              }
            | {
                data: { backupCodes: string; secret: string; userId: string };
                model: "twoFactor";
              }
            | {
                data: {
                  aaguid?: null | string;
                  backedUp: boolean;
                  counter: number;
                  createdAt?: null | number;
                  credentialID: string;
                  deviceType: string;
                  name?: null | string;
                  publicKey: string;
                  transports?: null | string;
                  userId: string;
                };
                model: "passkey";
              }
            | {
                data: {
                  createdAt: number;
                  enabled?: null | boolean;
                  expiresAt?: null | number;
                  key: string;
                  lastRefillAt?: null | number;
                  lastRequest?: null | number;
                  metadata?: null | string;
                  name?: null | string;
                  permissions?: null | string;
                  prefix?: null | string;
                  rateLimitEnabled?: null | boolean;
                  rateLimitMax?: null | number;
                  rateLimitTimeWindow?: null | number;
                  refillAmount?: null | number;
                  refillInterval?: null | number;
                  remaining?: null | number;
                  requestCount?: null | number;
                  start?: null | string;
                  updatedAt: number;
                  userId: string;
                };
                model: "apikey";
              }
            | {
                data: {
                  clientId?: null | string;
                  clientSecret?: null | string;
                  createdAt?: null | number;
                  disabled?: null | boolean;
                  icon?: null | string;
                  metadata?: null | string;
                  name?: null | string;
                  redirectURLs?: null | string;
                  type?: null | string;
                  updatedAt?: null | number;
                  userId?: null | string;
                };
                model: "oauthApplication";
              }
            | {
                data: {
                  accessToken?: null | string;
                  accessTokenExpiresAt?: null | number;
                  clientId?: null | string;
                  createdAt?: null | number;
                  refreshToken?: null | string;
                  refreshTokenExpiresAt?: null | number;
                  scopes?: null | string;
                  updatedAt?: null | number;
                  userId?: null | string;
                };
                model: "oauthAccessToken";
              }
            | {
                data: {
                  clientId?: null | string;
                  consentGiven?: null | boolean;
                  createdAt?: null | number;
                  scopes?: null | string;
                  updatedAt?: null | number;
                  userId?: null | string;
                };
                model: "oauthConsent";
              }
            | {
                data: {
                  createdAt: number;
                  logo?: null | string;
                  metadata?: null | string;
                  name: string;
                  slug?: null | string;
                };
                model: "organization";
              }
            | {
                data: {
                  createdAt: number;
                  organizationId: string;
                  role: string;
                  userId: string;
                };
                model: "member";
              }
            | {
                data: {
                  email: string;
                  expiresAt: number;
                  inviterId: string;
                  organizationId: string;
                  role?: null | string;
                  status: string;
                  teamId?: null | string;
                };
                model: "invitation";
              }
            | {
                data: {
                  createdAt: number;
                  name: string;
                  organizationId: string;
                  updatedAt?: null | number;
                };
                model: "team";
              }
            | {
                data: {
                  createdAt?: null | number;
                  teamId: string;
                  userId: string;
                };
                model: "teamMember";
              }
            | {
                data: {
                  domain: string;
                  issuer: string;
                  oidcConfig?: null | string;
                  organizationId?: null | string;
                  providerId: string;
                  samlConfig?: null | string;
                  userId?: null | string;
                };
                model: "ssoProvider";
              }
            | {
                data: {
                  createdAt: number;
                  privateKey: string;
                  publicKey: string;
                };
                model: "jwks";
              }
            | {
                data: {
                  cancelAtPeriodEnd?: null | boolean;
                  periodEnd?: null | number;
                  periodStart?: null | number;
                  plan: string;
                  referenceId: string;
                  seats?: null | number;
                  status?: null | string;
                  stripeCustomerId?: null | string;
                  stripeSubscriptionId?: null | string;
                };
                model: "subscription";
              }
            | {
                data: {
                  address: string;
                  chainId: number;
                  createdAt: number;
                  isPrimary?: null | boolean;
                  userId: string;
                };
                model: "walletAddress";
              }
            | {
                data: {
                  count?: null | number;
                  key?: null | string;
                  lastRequest?: null | number;
                };
                model: "rateLimit";
              };
        },
        any
      >;
      deleteMany: FunctionReference<
        "mutation",
        "internal",
        {
          limit?: number;
          model: string;
          offset?: number;
          paginationOpts: {
            cursor: string | null;
            endCursor?: string | null;
            id?: number;
            maximumBytesRead?: number;
            maximumRowsRead?: number;
            numItems: number;
          };
          select?: Array<string>;
          sortBy?: { direction: "asc" | "desc"; field: string };
          unique?: boolean;
          where?: Array<{
            connector?: "AND" | "OR";
            field: string;
            operator?:
              | "lt"
              | "lte"
              | "gt"
              | "gte"
              | "eq"
              | "in"
              | "ne"
              | "contains"
              | "starts_with"
              | "ends_with";
            value:
              | string
              | number
              | boolean
              | Array<string>
              | Array<number>
              | null;
          }>;
        },
        any
      >;
      deleteOne: FunctionReference<
        "mutation",
        "internal",
        {
          limit?: number;
          model: string;
          offset?: number;
          select?: Array<string>;
          sortBy?: { direction: "asc" | "desc"; field: string };
          unique?: boolean;
          where?: Array<{
            connector?: "AND" | "OR";
            field: string;
            operator?:
              | "lt"
              | "lte"
              | "gt"
              | "gte"
              | "eq"
              | "in"
              | "ne"
              | "contains"
              | "starts_with"
              | "ends_with";
            value:
              | string
              | number
              | boolean
              | Array<string>
              | Array<number>
              | null;
          }>;
        },
        any
      >;
      findMany: FunctionReference<
        "query",
        "internal",
        {
          limit?: number;
          model: string;
          offset?: number;
          paginationOpts: {
            cursor: string | null;
            endCursor?: string | null;
            id?: number;
            maximumBytesRead?: number;
            maximumRowsRead?: number;
            numItems: number;
          };
          select?: Array<string>;
          sortBy?: { direction: "asc" | "desc"; field: string };
          unique?: boolean;
          where?: Array<{
            connector?: "AND" | "OR";
            field: string;
            operator?:
              | "lt"
              | "lte"
              | "gt"
              | "gte"
              | "eq"
              | "in"
              | "ne"
              | "contains"
              | "starts_with"
              | "ends_with";
            value:
              | string
              | number
              | boolean
              | Array<string>
              | Array<number>
              | null;
          }>;
        },
        any
      >;
      findOne: FunctionReference<
        "query",
        "internal",
        {
          limit?: number;
          model: string;
          offset?: number;
          select?: Array<string>;
          sortBy?: { direction: "asc" | "desc"; field: string };
          unique?: boolean;
          where?: Array<{
            connector?: "AND" | "OR";
            field: string;
            operator?:
              | "lt"
              | "lte"
              | "gt"
              | "gte"
              | "eq"
              | "in"
              | "ne"
              | "contains"
              | "starts_with"
              | "ends_with";
            value:
              | string
              | number
              | boolean
              | Array<string>
              | Array<number>
              | null;
          }>;
        },
        any
      >;
      getCurrentSession: FunctionReference<"query", "internal", {}, any>;
      updateMany: FunctionReference<
        "mutation",
        "internal",
        {
          input:
            | {
                limit?: number;
                model: "user";
                offset?: number;
                paginationOpts: {
                  cursor: string | null;
                  endCursor?: string | null;
                  id?: number;
                  maximumBytesRead?: number;
                  maximumRowsRead?: number;
                  numItems: number;
                };
                select?: Array<string>;
                sortBy?: { direction: "asc" | "desc"; field: string };
                unique?: boolean;
                update: {
                  banExpires?: null | number;
                  banReason?: null | string;
                  banned?: null | boolean;
                  createdAt?: number;
                  displayUsername?: null | string;
                  email?: string;
                  emailVerified?: boolean;
                  image?: null | string;
                  isAnonymous?: null | boolean;
                  name?: string;
                  phoneNumber?: null | string;
                  phoneNumberVerified?: null | boolean;
                  role?: null | string;
                  stripeCustomerId?: null | string;
                  teamId?: null | string;
                  twoFactorEnabled?: null | boolean;
                  updatedAt?: number;
                  userId?: null | string;
                  username?: null | string;
                };
                where?: Array<{
                  connector?: "AND" | "OR";
                  field: string;
                  operator?:
                    | "lt"
                    | "lte"
                    | "gt"
                    | "gte"
                    | "eq"
                    | "in"
                    | "ne"
                    | "contains"
                    | "starts_with"
                    | "ends_with";
                  value:
                    | string
                    | number
                    | boolean
                    | Array<string>
                    | Array<number>
                    | null;
                }>;
              }
            | {
                limit?: number;
                model: "session";
                offset?: number;
                paginationOpts: {
                  cursor: string | null;
                  endCursor?: string | null;
                  id?: number;
                  maximumBytesRead?: number;
                  maximumRowsRead?: number;
                  numItems: number;
                };
                select?: Array<string>;
                sortBy?: { direction: "asc" | "desc"; field: string };
                unique?: boolean;
                update: {
                  activeOrganizationId?: null | string;
                  activeTeamId?: null | string;
                  createdAt?: number;
                  expiresAt?: number;
                  impersonatedBy?: null | string;
                  ipAddress?: null | string;
                  token?: string;
                  updatedAt?: number;
                  userAgent?: null | string;
                  userId?: string;
                };
                where?: Array<{
                  connector?: "AND" | "OR";
                  field: string;
                  operator?:
                    | "lt"
                    | "lte"
                    | "gt"
                    | "gte"
                    | "eq"
                    | "in"
                    | "ne"
                    | "contains"
                    | "starts_with"
                    | "ends_with";
                  value:
                    | string
                    | number
                    | boolean
                    | Array<string>
                    | Array<number>
                    | null;
                }>;
              }
            | {
                limit?: number;
                model: "account";
                offset?: number;
                paginationOpts: {
                  cursor: string | null;
                  endCursor?: string | null;
                  id?: number;
                  maximumBytesRead?: number;
                  maximumRowsRead?: number;
                  numItems: number;
                };
                select?: Array<string>;
                sortBy?: { direction: "asc" | "desc"; field: string };
                unique?: boolean;
                update: {
                  accessToken?: null | string;
                  accessTokenExpiresAt?: null | number;
                  accountId?: string;
                  createdAt?: number;
                  idToken?: null | string;
                  password?: null | string;
                  providerId?: string;
                  refreshToken?: null | string;
                  refreshTokenExpiresAt?: null | number;
                  scope?: null | string;
                  updatedAt?: number;
                  userId?: string;
                };
                where?: Array<{
                  connector?: "AND" | "OR";
                  field: string;
                  operator?:
                    | "lt"
                    | "lte"
                    | "gt"
                    | "gte"
                    | "eq"
                    | "in"
                    | "ne"
                    | "contains"
                    | "starts_with"
                    | "ends_with";
                  value:
                    | string
                    | number
                    | boolean
                    | Array<string>
                    | Array<number>
                    | null;
                }>;
              }
            | {
                limit?: number;
                model: "verification";
                offset?: number;
                paginationOpts: {
                  cursor: string | null;
                  endCursor?: string | null;
                  id?: number;
                  maximumBytesRead?: number;
                  maximumRowsRead?: number;
                  numItems: number;
                };
                select?: Array<string>;
                sortBy?: { direction: "asc" | "desc"; field: string };
                unique?: boolean;
                update: {
                  createdAt?: null | number;
                  expiresAt?: number;
                  identifier?: string;
                  updatedAt?: null | number;
                  value?: string;
                };
                where?: Array<{
                  connector?: "AND" | "OR";
                  field: string;
                  operator?:
                    | "lt"
                    | "lte"
                    | "gt"
                    | "gte"
                    | "eq"
                    | "in"
                    | "ne"
                    | "contains"
                    | "starts_with"
                    | "ends_with";
                  value:
                    | string
                    | number
                    | boolean
                    | Array<string>
                    | Array<number>
                    | null;
                }>;
              }
            | {
                limit?: number;
                model: "twoFactor";
                offset?: number;
                paginationOpts: {
                  cursor: string | null;
                  endCursor?: string | null;
                  id?: number;
                  maximumBytesRead?: number;
                  maximumRowsRead?: number;
                  numItems: number;
                };
                select?: Array<string>;
                sortBy?: { direction: "asc" | "desc"; field: string };
                unique?: boolean;
                update: {
                  backupCodes?: string;
                  secret?: string;
                  userId?: string;
                };
                where?: Array<{
                  connector?: "AND" | "OR";
                  field: string;
                  operator?:
                    | "lt"
                    | "lte"
                    | "gt"
                    | "gte"
                    | "eq"
                    | "in"
                    | "ne"
                    | "contains"
                    | "starts_with"
                    | "ends_with";
                  value:
                    | string
                    | number
                    | boolean
                    | Array<string>
                    | Array<number>
                    | null;
                }>;
              }
            | {
                limit?: number;
                model: "passkey";
                offset?: number;
                paginationOpts: {
                  cursor: string | null;
                  endCursor?: string | null;
                  id?: number;
                  maximumBytesRead?: number;
                  maximumRowsRead?: number;
                  numItems: number;
                };
                select?: Array<string>;
                sortBy?: { direction: "asc" | "desc"; field: string };
                unique?: boolean;
                update: {
                  aaguid?: null | string;
                  backedUp?: boolean;
                  counter?: number;
                  createdAt?: null | number;
                  credentialID?: string;
                  deviceType?: string;
                  name?: null | string;
                  publicKey?: string;
                  transports?: null | string;
                  userId?: string;
                };
                where?: Array<{
                  connector?: "AND" | "OR";
                  field: string;
                  operator?:
                    | "lt"
                    | "lte"
                    | "gt"
                    | "gte"
                    | "eq"
                    | "in"
                    | "ne"
                    | "contains"
                    | "starts_with"
                    | "ends_with";
                  value:
                    | string
                    | number
                    | boolean
                    | Array<string>
                    | Array<number>
                    | null;
                }>;
              }
            | {
                limit?: number;
                model: "apikey";
                offset?: number;
                paginationOpts: {
                  cursor: string | null;
                  endCursor?: string | null;
                  id?: number;
                  maximumBytesRead?: number;
                  maximumRowsRead?: number;
                  numItems: number;
                };
                select?: Array<string>;
                sortBy?: { direction: "asc" | "desc"; field: string };
                unique?: boolean;
                update: {
                  createdAt?: number;
                  enabled?: null | boolean;
                  expiresAt?: null | number;
                  key?: string;
                  lastRefillAt?: null | number;
                  lastRequest?: null | number;
                  metadata?: null | string;
                  name?: null | string;
                  permissions?: null | string;
                  prefix?: null | string;
                  rateLimitEnabled?: null | boolean;
                  rateLimitMax?: null | number;
                  rateLimitTimeWindow?: null | number;
                  refillAmount?: null | number;
                  refillInterval?: null | number;
                  remaining?: null | number;
                  requestCount?: null | number;
                  start?: null | string;
                  updatedAt?: number;
                  userId?: string;
                };
                where?: Array<{
                  connector?: "AND" | "OR";
                  field: string;
                  operator?:
                    | "lt"
                    | "lte"
                    | "gt"
                    | "gte"
                    | "eq"
                    | "in"
                    | "ne"
                    | "contains"
                    | "starts_with"
                    | "ends_with";
                  value:
                    | string
                    | number
                    | boolean
                    | Array<string>
                    | Array<number>
                    | null;
                }>;
              }
            | {
                limit?: number;
                model: "oauthApplication";
                offset?: number;
                paginationOpts: {
                  cursor: string | null;
                  endCursor?: string | null;
                  id?: number;
                  maximumBytesRead?: number;
                  maximumRowsRead?: number;
                  numItems: number;
                };
                select?: Array<string>;
                sortBy?: { direction: "asc" | "desc"; field: string };
                unique?: boolean;
                update: {
                  clientId?: null | string;
                  clientSecret?: null | string;
                  createdAt?: null | number;
                  disabled?: null | boolean;
                  icon?: null | string;
                  metadata?: null | string;
                  name?: null | string;
                  redirectURLs?: null | string;
                  type?: null | string;
                  updatedAt?: null | number;
                  userId?: null | string;
                };
                where?: Array<{
                  connector?: "AND" | "OR";
                  field: string;
                  operator?:
                    | "lt"
                    | "lte"
                    | "gt"
                    | "gte"
                    | "eq"
                    | "in"
                    | "ne"
                    | "contains"
                    | "starts_with"
                    | "ends_with";
                  value:
                    | string
                    | number
                    | boolean
                    | Array<string>
                    | Array<number>
                    | null;
                }>;
              }
            | {
                limit?: number;
                model: "oauthAccessToken";
                offset?: number;
                paginationOpts: {
                  cursor: string | null;
                  endCursor?: string | null;
                  id?: number;
                  maximumBytesRead?: number;
                  maximumRowsRead?: number;
                  numItems: number;
                };
                select?: Array<string>;
                sortBy?: { direction: "asc" | "desc"; field: string };
                unique?: boolean;
                update: {
                  accessToken?: null | string;
                  accessTokenExpiresAt?: null | number;
                  clientId?: null | string;
                  createdAt?: null | number;
                  refreshToken?: null | string;
                  refreshTokenExpiresAt?: null | number;
                  scopes?: null | string;
                  updatedAt?: null | number;
                  userId?: null | string;
                };
                where?: Array<{
                  connector?: "AND" | "OR";
                  field: string;
                  operator?:
                    | "lt"
                    | "lte"
                    | "gt"
                    | "gte"
                    | "eq"
                    | "in"
                    | "ne"
                    | "contains"
                    | "starts_with"
                    | "ends_with";
                  value:
                    | string
                    | number
                    | boolean
                    | Array<string>
                    | Array<number>
                    | null;
                }>;
              }
            | {
                limit?: number;
                model: "oauthConsent";
                offset?: number;
                paginationOpts: {
                  cursor: string | null;
                  endCursor?: string | null;
                  id?: number;
                  maximumBytesRead?: number;
                  maximumRowsRead?: number;
                  numItems: number;
                };
                select?: Array<string>;
                sortBy?: { direction: "asc" | "desc"; field: string };
                unique?: boolean;
                update: {
                  clientId?: null | string;
                  consentGiven?: null | boolean;
                  createdAt?: null | number;
                  scopes?: null | string;
                  updatedAt?: null | number;
                  userId?: null | string;
                };
                where?: Array<{
                  connector?: "AND" | "OR";
                  field: string;
                  operator?:
                    | "lt"
                    | "lte"
                    | "gt"
                    | "gte"
                    | "eq"
                    | "in"
                    | "ne"
                    | "contains"
                    | "starts_with"
                    | "ends_with";
                  value:
                    | string
                    | number
                    | boolean
                    | Array<string>
                    | Array<number>
                    | null;
                }>;
              }
            | {
                limit?: number;
                model: "organization";
                offset?: number;
                paginationOpts: {
                  cursor: string | null;
                  endCursor?: string | null;
                  id?: number;
                  maximumBytesRead?: number;
                  maximumRowsRead?: number;
                  numItems: number;
                };
                select?: Array<string>;
                sortBy?: { direction: "asc" | "desc"; field: string };
                unique?: boolean;
                update: {
                  createdAt?: number;
                  logo?: null | string;
                  metadata?: null | string;
                  name?: string;
                  slug?: null | string;
                };
                where?: Array<{
                  connector?: "AND" | "OR";
                  field: string;
                  operator?:
                    | "lt"
                    | "lte"
                    | "gt"
                    | "gte"
                    | "eq"
                    | "in"
                    | "ne"
                    | "contains"
                    | "starts_with"
                    | "ends_with";
                  value:
                    | string
                    | number
                    | boolean
                    | Array<string>
                    | Array<number>
                    | null;
                }>;
              }
            | {
                limit?: number;
                model: "member";
                offset?: number;
                paginationOpts: {
                  cursor: string | null;
                  endCursor?: string | null;
                  id?: number;
                  maximumBytesRead?: number;
                  maximumRowsRead?: number;
                  numItems: number;
                };
                select?: Array<string>;
                sortBy?: { direction: "asc" | "desc"; field: string };
                unique?: boolean;
                update: {
                  createdAt?: number;
                  organizationId?: string;
                  role?: string;
                  userId?: string;
                };
                where?: Array<{
                  connector?: "AND" | "OR";
                  field: string;
                  operator?:
                    | "lt"
                    | "lte"
                    | "gt"
                    | "gte"
                    | "eq"
                    | "in"
                    | "ne"
                    | "contains"
                    | "starts_with"
                    | "ends_with";
                  value:
                    | string
                    | number
                    | boolean
                    | Array<string>
                    | Array<number>
                    | null;
                }>;
              }
            | {
                limit?: number;
                model: "invitation";
                offset?: number;
                paginationOpts: {
                  cursor: string | null;
                  endCursor?: string | null;
                  id?: number;
                  maximumBytesRead?: number;
                  maximumRowsRead?: number;
                  numItems: number;
                };
                select?: Array<string>;
                sortBy?: { direction: "asc" | "desc"; field: string };
                unique?: boolean;
                update: {
                  email?: string;
                  expiresAt?: number;
                  inviterId?: string;
                  organizationId?: string;
                  role?: null | string;
                  status?: string;
                  teamId?: null | string;
                };
                where?: Array<{
                  connector?: "AND" | "OR";
                  field: string;
                  operator?:
                    | "lt"
                    | "lte"
                    | "gt"
                    | "gte"
                    | "eq"
                    | "in"
                    | "ne"
                    | "contains"
                    | "starts_with"
                    | "ends_with";
                  value:
                    | string
                    | number
                    | boolean
                    | Array<string>
                    | Array<number>
                    | null;
                }>;
              }
            | {
                limit?: number;
                model: "team";
                offset?: number;
                paginationOpts: {
                  cursor: string | null;
                  endCursor?: string | null;
                  id?: number;
                  maximumBytesRead?: number;
                  maximumRowsRead?: number;
                  numItems: number;
                };
                select?: Array<string>;
                sortBy?: { direction: "asc" | "desc"; field: string };
                unique?: boolean;
                update: {
                  createdAt?: number;
                  name?: string;
                  organizationId?: string;
                  updatedAt?: null | number;
                };
                where?: Array<{
                  connector?: "AND" | "OR";
                  field: string;
                  operator?:
                    | "lt"
                    | "lte"
                    | "gt"
                    | "gte"
                    | "eq"
                    | "in"
                    | "ne"
                    | "contains"
                    | "starts_with"
                    | "ends_with";
                  value:
                    | string
                    | number
                    | boolean
                    | Array<string>
                    | Array<number>
                    | null;
                }>;
              }
            | {
                limit?: number;
                model: "teamMember";
                offset?: number;
                paginationOpts: {
                  cursor: string | null;
                  endCursor?: string | null;
                  id?: number;
                  maximumBytesRead?: number;
                  maximumRowsRead?: number;
                  numItems: number;
                };
                select?: Array<string>;
                sortBy?: { direction: "asc" | "desc"; field: string };
                unique?: boolean;
                update: {
                  createdAt?: null | number;
                  teamId?: string;
                  userId?: string;
                };
                where?: Array<{
                  connector?: "AND" | "OR";
                  field: string;
                  operator?:
                    | "lt"
                    | "lte"
                    | "gt"
                    | "gte"
                    | "eq"
                    | "in"
                    | "ne"
                    | "contains"
                    | "starts_with"
                    | "ends_with";
                  value:
                    | string
                    | number
                    | boolean
                    | Array<string>
                    | Array<number>
                    | null;
                }>;
              }
            | {
                limit?: number;
                model: "ssoProvider";
                offset?: number;
                paginationOpts: {
                  cursor: string | null;
                  endCursor?: string | null;
                  id?: number;
                  maximumBytesRead?: number;
                  maximumRowsRead?: number;
                  numItems: number;
                };
                select?: Array<string>;
                sortBy?: { direction: "asc" | "desc"; field: string };
                unique?: boolean;
                update: {
                  domain?: string;
                  issuer?: string;
                  oidcConfig?: null | string;
                  organizationId?: null | string;
                  providerId?: string;
                  samlConfig?: null | string;
                  userId?: null | string;
                };
                where?: Array<{
                  connector?: "AND" | "OR";
                  field: string;
                  operator?:
                    | "lt"
                    | "lte"
                    | "gt"
                    | "gte"
                    | "eq"
                    | "in"
                    | "ne"
                    | "contains"
                    | "starts_with"
                    | "ends_with";
                  value:
                    | string
                    | number
                    | boolean
                    | Array<string>
                    | Array<number>
                    | null;
                }>;
              }
            | {
                limit?: number;
                model: "jwks";
                offset?: number;
                paginationOpts: {
                  cursor: string | null;
                  endCursor?: string | null;
                  id?: number;
                  maximumBytesRead?: number;
                  maximumRowsRead?: number;
                  numItems: number;
                };
                select?: Array<string>;
                sortBy?: { direction: "asc" | "desc"; field: string };
                unique?: boolean;
                update: {
                  createdAt?: number;
                  privateKey?: string;
                  publicKey?: string;
                };
                where?: Array<{
                  connector?: "AND" | "OR";
                  field: string;
                  operator?:
                    | "lt"
                    | "lte"
                    | "gt"
                    | "gte"
                    | "eq"
                    | "in"
                    | "ne"
                    | "contains"
                    | "starts_with"
                    | "ends_with";
                  value:
                    | string
                    | number
                    | boolean
                    | Array<string>
                    | Array<number>
                    | null;
                }>;
              }
            | {
                limit?: number;
                model: "subscription";
                offset?: number;
                paginationOpts: {
                  cursor: string | null;
                  endCursor?: string | null;
                  id?: number;
                  maximumBytesRead?: number;
                  maximumRowsRead?: number;
                  numItems: number;
                };
                select?: Array<string>;
                sortBy?: { direction: "asc" | "desc"; field: string };
                unique?: boolean;
                update: {
                  cancelAtPeriodEnd?: null | boolean;
                  periodEnd?: null | number;
                  periodStart?: null | number;
                  plan?: string;
                  referenceId?: string;
                  seats?: null | number;
                  status?: null | string;
                  stripeCustomerId?: null | string;
                  stripeSubscriptionId?: null | string;
                };
                where?: Array<{
                  connector?: "AND" | "OR";
                  field: string;
                  operator?:
                    | "lt"
                    | "lte"
                    | "gt"
                    | "gte"
                    | "eq"
                    | "in"
                    | "ne"
                    | "contains"
                    | "starts_with"
                    | "ends_with";
                  value:
                    | string
                    | number
                    | boolean
                    | Array<string>
                    | Array<number>
                    | null;
                }>;
              }
            | {
                limit?: number;
                model: "walletAddress";
                offset?: number;
                paginationOpts: {
                  cursor: string | null;
                  endCursor?: string | null;
                  id?: number;
                  maximumBytesRead?: number;
                  maximumRowsRead?: number;
                  numItems: number;
                };
                select?: Array<string>;
                sortBy?: { direction: "asc" | "desc"; field: string };
                unique?: boolean;
                update: {
                  address?: string;
                  chainId?: number;
                  createdAt?: number;
                  isPrimary?: null | boolean;
                  userId?: string;
                };
                where?: Array<{
                  connector?: "AND" | "OR";
                  field: string;
                  operator?:
                    | "lt"
                    | "lte"
                    | "gt"
                    | "gte"
                    | "eq"
                    | "in"
                    | "ne"
                    | "contains"
                    | "starts_with"
                    | "ends_with";
                  value:
                    | string
                    | number
                    | boolean
                    | Array<string>
                    | Array<number>
                    | null;
                }>;
              }
            | {
                limit?: number;
                model: "rateLimit";
                offset?: number;
                paginationOpts: {
                  cursor: string | null;
                  endCursor?: string | null;
                  id?: number;
                  maximumBytesRead?: number;
                  maximumRowsRead?: number;
                  numItems: number;
                };
                select?: Array<string>;
                sortBy?: { direction: "asc" | "desc"; field: string };
                unique?: boolean;
                update: {
                  count?: null | number;
                  key?: null | string;
                  lastRequest?: null | number;
                };
                where?: Array<{
                  connector?: "AND" | "OR";
                  field: string;
                  operator?:
                    | "lt"
                    | "lte"
                    | "gt"
                    | "gte"
                    | "eq"
                    | "in"
                    | "ne"
                    | "contains"
                    | "starts_with"
                    | "ends_with";
                  value:
                    | string
                    | number
                    | boolean
                    | Array<string>
                    | Array<number>
                    | null;
                }>;
              };
        },
        any
      >;
      updateOne: FunctionReference<
        "mutation",
        "internal",
        {
          input:
            | {
                model: "user";
                update: {
                  banExpires?: null | number;
                  banReason?: null | string;
                  banned?: null | boolean;
                  createdAt?: number;
                  displayUsername?: null | string;
                  email?: string;
                  emailVerified?: boolean;
                  image?: null | string;
                  isAnonymous?: null | boolean;
                  name?: string;
                  phoneNumber?: null | string;
                  phoneNumberVerified?: null | boolean;
                  role?: null | string;
                  stripeCustomerId?: null | string;
                  teamId?: null | string;
                  twoFactorEnabled?: null | boolean;
                  updatedAt?: number;
                  userId?: null | string;
                  username?: null | string;
                };
                where?: Array<{
                  connector?: "AND" | "OR";
                  field: string;
                  operator?:
                    | "lt"
                    | "lte"
                    | "gt"
                    | "gte"
                    | "eq"
                    | "in"
                    | "ne"
                    | "contains"
                    | "starts_with"
                    | "ends_with";
                  value:
                    | string
                    | number
                    | boolean
                    | Array<string>
                    | Array<number>
                    | null;
                }>;
              }
            | {
                model: "session";
                update: {
                  activeOrganizationId?: null | string;
                  activeTeamId?: null | string;
                  createdAt?: number;
                  expiresAt?: number;
                  impersonatedBy?: null | string;
                  ipAddress?: null | string;
                  token?: string;
                  updatedAt?: number;
                  userAgent?: null | string;
                  userId?: string;
                };
                where?: Array<{
                  connector?: "AND" | "OR";
                  field: string;
                  operator?:
                    | "lt"
                    | "lte"
                    | "gt"
                    | "gte"
                    | "eq"
                    | "in"
                    | "ne"
                    | "contains"
                    | "starts_with"
                    | "ends_with";
                  value:
                    | string
                    | number
                    | boolean
                    | Array<string>
                    | Array<number>
                    | null;
                }>;
              }
            | {
                model: "account";
                update: {
                  accessToken?: null | string;
                  accessTokenExpiresAt?: null | number;
                  accountId?: string;
                  createdAt?: number;
                  idToken?: null | string;
                  password?: null | string;
                  providerId?: string;
                  refreshToken?: null | string;
                  refreshTokenExpiresAt?: null | number;
                  scope?: null | string;
                  updatedAt?: number;
                  userId?: string;
                };
                where?: Array<{
                  connector?: "AND" | "OR";
                  field: string;
                  operator?:
                    | "lt"
                    | "lte"
                    | "gt"
                    | "gte"
                    | "eq"
                    | "in"
                    | "ne"
                    | "contains"
                    | "starts_with"
                    | "ends_with";
                  value:
                    | string
                    | number
                    | boolean
                    | Array<string>
                    | Array<number>
                    | null;
                }>;
              }
            | {
                model: "verification";
                update: {
                  createdAt?: null | number;
                  expiresAt?: number;
                  identifier?: string;
                  updatedAt?: null | number;
                  value?: string;
                };
                where?: Array<{
                  connector?: "AND" | "OR";
                  field: string;
                  operator?:
                    | "lt"
                    | "lte"
                    | "gt"
                    | "gte"
                    | "eq"
                    | "in"
                    | "ne"
                    | "contains"
                    | "starts_with"
                    | "ends_with";
                  value:
                    | string
                    | number
                    | boolean
                    | Array<string>
                    | Array<number>
                    | null;
                }>;
              }
            | {
                model: "twoFactor";
                update: {
                  backupCodes?: string;
                  secret?: string;
                  userId?: string;
                };
                where?: Array<{
                  connector?: "AND" | "OR";
                  field: string;
                  operator?:
                    | "lt"
                    | "lte"
                    | "gt"
                    | "gte"
                    | "eq"
                    | "in"
                    | "ne"
                    | "contains"
                    | "starts_with"
                    | "ends_with";
                  value:
                    | string
                    | number
                    | boolean
                    | Array<string>
                    | Array<number>
                    | null;
                }>;
              }
            | {
                model: "passkey";
                update: {
                  aaguid?: null | string;
                  backedUp?: boolean;
                  counter?: number;
                  createdAt?: null | number;
                  credentialID?: string;
                  deviceType?: string;
                  name?: null | string;
                  publicKey?: string;
                  transports?: null | string;
                  userId?: string;
                };
                where?: Array<{
                  connector?: "AND" | "OR";
                  field: string;
                  operator?:
                    | "lt"
                    | "lte"
                    | "gt"
                    | "gte"
                    | "eq"
                    | "in"
                    | "ne"
                    | "contains"
                    | "starts_with"
                    | "ends_with";
                  value:
                    | string
                    | number
                    | boolean
                    | Array<string>
                    | Array<number>
                    | null;
                }>;
              }
            | {
                model: "apikey";
                update: {
                  createdAt?: number;
                  enabled?: null | boolean;
                  expiresAt?: null | number;
                  key?: string;
                  lastRefillAt?: null | number;
                  lastRequest?: null | number;
                  metadata?: null | string;
                  name?: null | string;
                  permissions?: null | string;
                  prefix?: null | string;
                  rateLimitEnabled?: null | boolean;
                  rateLimitMax?: null | number;
                  rateLimitTimeWindow?: null | number;
                  refillAmount?: null | number;
                  refillInterval?: null | number;
                  remaining?: null | number;
                  requestCount?: null | number;
                  start?: null | string;
                  updatedAt?: number;
                  userId?: string;
                };
                where?: Array<{
                  connector?: "AND" | "OR";
                  field: string;
                  operator?:
                    | "lt"
                    | "lte"
                    | "gt"
                    | "gte"
                    | "eq"
                    | "in"
                    | "ne"
                    | "contains"
                    | "starts_with"
                    | "ends_with";
                  value:
                    | string
                    | number
                    | boolean
                    | Array<string>
                    | Array<number>
                    | null;
                }>;
              }
            | {
                model: "oauthApplication";
                update: {
                  clientId?: null | string;
                  clientSecret?: null | string;
                  createdAt?: null | number;
                  disabled?: null | boolean;
                  icon?: null | string;
                  metadata?: null | string;
                  name?: null | string;
                  redirectURLs?: null | string;
                  type?: null | string;
                  updatedAt?: null | number;
                  userId?: null | string;
                };
                where?: Array<{
                  connector?: "AND" | "OR";
                  field: string;
                  operator?:
                    | "lt"
                    | "lte"
                    | "gt"
                    | "gte"
                    | "eq"
                    | "in"
                    | "ne"
                    | "contains"
                    | "starts_with"
                    | "ends_with";
                  value:
                    | string
                    | number
                    | boolean
                    | Array<string>
                    | Array<number>
                    | null;
                }>;
              }
            | {
                model: "oauthAccessToken";
                update: {
                  accessToken?: null | string;
                  accessTokenExpiresAt?: null | number;
                  clientId?: null | string;
                  createdAt?: null | number;
                  refreshToken?: null | string;
                  refreshTokenExpiresAt?: null | number;
                  scopes?: null | string;
                  updatedAt?: null | number;
                  userId?: null | string;
                };
                where?: Array<{
                  connector?: "AND" | "OR";
                  field: string;
                  operator?:
                    | "lt"
                    | "lte"
                    | "gt"
                    | "gte"
                    | "eq"
                    | "in"
                    | "ne"
                    | "contains"
                    | "starts_with"
                    | "ends_with";
                  value:
                    | string
                    | number
                    | boolean
                    | Array<string>
                    | Array<number>
                    | null;
                }>;
              }
            | {
                model: "oauthConsent";
                update: {
                  clientId?: null | string;
                  consentGiven?: null | boolean;
                  createdAt?: null | number;
                  scopes?: null | string;
                  updatedAt?: null | number;
                  userId?: null | string;
                };
                where?: Array<{
                  connector?: "AND" | "OR";
                  field: string;
                  operator?:
                    | "lt"
                    | "lte"
                    | "gt"
                    | "gte"
                    | "eq"
                    | "in"
                    | "ne"
                    | "contains"
                    | "starts_with"
                    | "ends_with";
                  value:
                    | string
                    | number
                    | boolean
                    | Array<string>
                    | Array<number>
                    | null;
                }>;
              }
            | {
                model: "organization";
                update: {
                  createdAt?: number;
                  logo?: null | string;
                  metadata?: null | string;
                  name?: string;
                  slug?: null | string;
                };
                where?: Array<{
                  connector?: "AND" | "OR";
                  field: string;
                  operator?:
                    | "lt"
                    | "lte"
                    | "gt"
                    | "gte"
                    | "eq"
                    | "in"
                    | "ne"
                    | "contains"
                    | "starts_with"
                    | "ends_with";
                  value:
                    | string
                    | number
                    | boolean
                    | Array<string>
                    | Array<number>
                    | null;
                }>;
              }
            | {
                model: "member";
                update: {
                  createdAt?: number;
                  organizationId?: string;
                  role?: string;
                  userId?: string;
                };
                where?: Array<{
                  connector?: "AND" | "OR";
                  field: string;
                  operator?:
                    | "lt"
                    | "lte"
                    | "gt"
                    | "gte"
                    | "eq"
                    | "in"
                    | "ne"
                    | "contains"
                    | "starts_with"
                    | "ends_with";
                  value:
                    | string
                    | number
                    | boolean
                    | Array<string>
                    | Array<number>
                    | null;
                }>;
              }
            | {
                model: "invitation";
                update: {
                  email?: string;
                  expiresAt?: number;
                  inviterId?: string;
                  organizationId?: string;
                  role?: null | string;
                  status?: string;
                  teamId?: null | string;
                };
                where?: Array<{
                  connector?: "AND" | "OR";
                  field: string;
                  operator?:
                    | "lt"
                    | "lte"
                    | "gt"
                    | "gte"
                    | "eq"
                    | "in"
                    | "ne"
                    | "contains"
                    | "starts_with"
                    | "ends_with";
                  value:
                    | string
                    | number
                    | boolean
                    | Array<string>
                    | Array<number>
                    | null;
                }>;
              }
            | {
                model: "team";
                update: {
                  createdAt?: number;
                  name?: string;
                  organizationId?: string;
                  updatedAt?: null | number;
                };
                where?: Array<{
                  connector?: "AND" | "OR";
                  field: string;
                  operator?:
                    | "lt"
                    | "lte"
                    | "gt"
                    | "gte"
                    | "eq"
                    | "in"
                    | "ne"
                    | "contains"
                    | "starts_with"
                    | "ends_with";
                  value:
                    | string
                    | number
                    | boolean
                    | Array<string>
                    | Array<number>
                    | null;
                }>;
              }
            | {
                model: "teamMember";
                update: {
                  createdAt?: null | number;
                  teamId?: string;
                  userId?: string;
                };
                where?: Array<{
                  connector?: "AND" | "OR";
                  field: string;
                  operator?:
                    | "lt"
                    | "lte"
                    | "gt"
                    | "gte"
                    | "eq"
                    | "in"
                    | "ne"
                    | "contains"
                    | "starts_with"
                    | "ends_with";
                  value:
                    | string
                    | number
                    | boolean
                    | Array<string>
                    | Array<number>
                    | null;
                }>;
              }
            | {
                model: "ssoProvider";
                update: {
                  domain?: string;
                  issuer?: string;
                  oidcConfig?: null | string;
                  organizationId?: null | string;
                  providerId?: string;
                  samlConfig?: null | string;
                  userId?: null | string;
                };
                where?: Array<{
                  connector?: "AND" | "OR";
                  field: string;
                  operator?:
                    | "lt"
                    | "lte"
                    | "gt"
                    | "gte"
                    | "eq"
                    | "in"
                    | "ne"
                    | "contains"
                    | "starts_with"
                    | "ends_with";
                  value:
                    | string
                    | number
                    | boolean
                    | Array<string>
                    | Array<number>
                    | null;
                }>;
              }
            | {
                model: "jwks";
                update: {
                  createdAt?: number;
                  privateKey?: string;
                  publicKey?: string;
                };
                where?: Array<{
                  connector?: "AND" | "OR";
                  field: string;
                  operator?:
                    | "lt"
                    | "lte"
                    | "gt"
                    | "gte"
                    | "eq"
                    | "in"
                    | "ne"
                    | "contains"
                    | "starts_with"
                    | "ends_with";
                  value:
                    | string
                    | number
                    | boolean
                    | Array<string>
                    | Array<number>
                    | null;
                }>;
              }
            | {
                model: "subscription";
                update: {
                  cancelAtPeriodEnd?: null | boolean;
                  periodEnd?: null | number;
                  periodStart?: null | number;
                  plan?: string;
                  referenceId?: string;
                  seats?: null | number;
                  status?: null | string;
                  stripeCustomerId?: null | string;
                  stripeSubscriptionId?: null | string;
                };
                where?: Array<{
                  connector?: "AND" | "OR";
                  field: string;
                  operator?:
                    | "lt"
                    | "lte"
                    | "gt"
                    | "gte"
                    | "eq"
                    | "in"
                    | "ne"
                    | "contains"
                    | "starts_with"
                    | "ends_with";
                  value:
                    | string
                    | number
                    | boolean
                    | Array<string>
                    | Array<number>
                    | null;
                }>;
              }
            | {
                model: "walletAddress";
                update: {
                  address?: string;
                  chainId?: number;
                  createdAt?: number;
                  isPrimary?: null | boolean;
                  userId?: string;
                };
                where?: Array<{
                  connector?: "AND" | "OR";
                  field: string;
                  operator?:
                    | "lt"
                    | "lte"
                    | "gt"
                    | "gte"
                    | "eq"
                    | "in"
                    | "ne"
                    | "contains"
                    | "starts_with"
                    | "ends_with";
                  value:
                    | string
                    | number
                    | boolean
                    | Array<string>
                    | Array<number>
                    | null;
                }>;
              }
            | {
                model: "rateLimit";
                update: {
                  count?: null | number;
                  key?: null | string;
                  lastRequest?: null | number;
                };
                where?: Array<{
                  connector?: "AND" | "OR";
                  field: string;
                  operator?:
                    | "lt"
                    | "lte"
                    | "gt"
                    | "gte"
                    | "eq"
                    | "in"
                    | "ne"
                    | "contains"
                    | "starts_with"
                    | "ends_with";
                  value:
                    | string
                    | number
                    | boolean
                    | Array<string>
                    | Array<number>
                    | null;
                }>;
              };
        },
        any
      >;
    };
  };
  agent: {
    apiKeys: {
      destroy: FunctionReference<
        "mutation",
        "internal",
        { apiKey?: string; name?: string },
        | "missing"
        | "deleted"
        | "name mismatch"
        | "must provide either apiKey or name"
      >;
      issue: FunctionReference<
        "mutation",
        "internal",
        { name?: string },
        string
      >;
      validate: FunctionReference<
        "query",
        "internal",
        { apiKey: string },
        boolean
      >;
    };
    files: {
      addFile: FunctionReference<
        "mutation",
        "internal",
        {
          filename?: string;
          hash: string;
          mimeType: string;
          storageId: string;
        },
        { fileId: string; storageId: string }
      >;
      copyFile: FunctionReference<
        "mutation",
        "internal",
        { fileId: string },
        null
      >;
      deleteFiles: FunctionReference<
        "mutation",
        "internal",
        { fileIds: Array<string>; force?: boolean },
        Array<string>
      >;
      get: FunctionReference<
        "query",
        "internal",
        { fileId: string },
        null | {
          _creationTime: number;
          _id: string;
          filename?: string;
          hash: string;
          lastTouchedAt: number;
          mimeType: string;
          refcount: number;
          storageId: string;
        }
      >;
      getFilesToDelete: FunctionReference<
        "query",
        "internal",
        {
          paginationOpts: {
            cursor: string | null;
            endCursor?: string | null;
            id?: number;
            maximumBytesRead?: number;
            maximumRowsRead?: number;
            numItems: number;
          };
        },
        {
          continueCursor: string;
          isDone: boolean;
          page: Array<{
            _creationTime: number;
            _id: string;
            filename?: string;
            hash: string;
            lastTouchedAt: number;
            mimeType: string;
            refcount: number;
            storageId: string;
          }>;
        }
      >;
      useExistingFile: FunctionReference<
        "mutation",
        "internal",
        { filename?: string; hash: string },
        null | { fileId: string; storageId: string }
      >;
    };
    messages: {
      addMessages: FunctionReference<
        "mutation",
        "internal",
        {
          agentName?: string;
          embeddings?: {
            dimension:
              | 128
              | 256
              | 512
              | 768
              | 1024
              | 1408
              | 1536
              | 2048
              | 3072
              | 4096;
            model: string;
            vectors: Array<Array<number> | null>;
          };
          failPendingSteps?: boolean;
          messages: Array<{
            error?: string;
            fileIds?: Array<string>;
            finishReason?:
              | "stop"
              | "length"
              | "content-filter"
              | "tool-calls"
              | "error"
              | "other"
              | "unknown";
            message:
              | {
                  content:
                    | string
                    | Array<
                        | {
                            providerMetadata?: Record<
                              string,
                              Record<string, any>
                            >;
                            providerOptions?: Record<
                              string,
                              Record<string, any>
                            >;
                            text: string;
                            type: "text";
                          }
                        | {
                            image: string | ArrayBuffer;
                            mimeType?: string;
                            providerOptions?: Record<
                              string,
                              Record<string, any>
                            >;
                            type: "image";
                          }
                        | {
                            data: string | ArrayBuffer;
                            filename?: string;
                            mimeType: string;
                            providerMetadata?: Record<
                              string,
                              Record<string, any>
                            >;
                            providerOptions?: Record<
                              string,
                              Record<string, any>
                            >;
                            type: "file";
                          }
                      >;
                  providerOptions?: Record<string, Record<string, any>>;
                  role: "user";
                }
              | {
                  content:
                    | string
                    | Array<
                        | {
                            providerMetadata?: Record<
                              string,
                              Record<string, any>
                            >;
                            providerOptions?: Record<
                              string,
                              Record<string, any>
                            >;
                            text: string;
                            type: "text";
                          }
                        | {
                            data: string | ArrayBuffer;
                            filename?: string;
                            mimeType: string;
                            providerMetadata?: Record<
                              string,
                              Record<string, any>
                            >;
                            providerOptions?: Record<
                              string,
                              Record<string, any>
                            >;
                            type: "file";
                          }
                        | {
                            providerMetadata?: Record<
                              string,
                              Record<string, any>
                            >;
                            providerOptions?: Record<
                              string,
                              Record<string, any>
                            >;
                            signature?: string;
                            text: string;
                            type: "reasoning";
                          }
                        | {
                            data: string;
                            providerMetadata?: Record<
                              string,
                              Record<string, any>
                            >;
                            providerOptions?: Record<
                              string,
                              Record<string, any>
                            >;
                            type: "redacted-reasoning";
                          }
                        | {
                            args: any;
                            providerExecuted?: boolean;
                            providerMetadata?: Record<
                              string,
                              Record<string, any>
                            >;
                            providerOptions?: Record<
                              string,
                              Record<string, any>
                            >;
                            toolCallId: string;
                            toolName: string;
                            type: "tool-call";
                          }
                        | {
                            args?: any;
                            experimental_content?: Array<
                              | { text: string; type: "text" }
                              | {
                                  data: string;
                                  mimeType?: string;
                                  type: "image";
                                }
                            >;
                            isError?: boolean;
                            providerExecuted?: boolean;
                            providerMetadata?: Record<
                              string,
                              Record<string, any>
                            >;
                            providerOptions?: Record<
                              string,
                              Record<string, any>
                            >;
                            result: any;
                            toolCallId: string;
                            toolName: string;
                            type: "tool-result";
                          }
                      >;
                  providerOptions?: Record<string, Record<string, any>>;
                  role: "assistant";
                }
              | {
                  content: Array<{
                    args?: any;
                    experimental_content?: Array<
                      | { text: string; type: "text" }
                      | { data: string; mimeType?: string; type: "image" }
                    >;
                    isError?: boolean;
                    providerExecuted?: boolean;
                    providerMetadata?: Record<string, Record<string, any>>;
                    providerOptions?: Record<string, Record<string, any>>;
                    result: any;
                    toolCallId: string;
                    toolName: string;
                    type: "tool-result";
                  }>;
                  providerOptions?: Record<string, Record<string, any>>;
                  role: "tool";
                }
              | {
                  content: string;
                  providerOptions?: Record<string, Record<string, any>>;
                  role: "system";
                };
            model?: string;
            provider?: string;
            providerMetadata?: Record<string, Record<string, any>>;
            reasoning?: string;
            reasoningDetails?: Array<
              | {
                  providerMetadata?: Record<string, Record<string, any>>;
                  providerOptions?: Record<string, Record<string, any>>;
                  signature?: string;
                  text: string;
                  type: "reasoning";
                }
              | { signature?: string; text: string; type: "text" }
              | { data: string; type: "redacted" }
            >;
            sources?: Array<
              | {
                  id: string;
                  providerMetadata?: Record<string, Record<string, any>>;
                  providerOptions?: Record<string, Record<string, any>>;
                  sourceType: "url";
                  title?: string;
                  type?: "source";
                  url: string;
                }
              | {
                  filename?: string;
                  id: string;
                  mediaType: string;
                  providerMetadata?: Record<string, Record<string, any>>;
                  providerOptions?: Record<string, Record<string, any>>;
                  sourceType: "document";
                  title: string;
                  type: "source";
                }
            >;
            status?: "pending" | "success" | "failed";
            text?: string;
            usage?: {
              cachedInputTokens?: number;
              completionTokens: number;
              promptTokens: number;
              reasoningTokens?: number;
              totalTokens: number;
            };
            warnings?: Array<
              | {
                  details?: string;
                  setting: string;
                  type: "unsupported-setting";
                }
              | { details?: string; tool: any; type: "unsupported-tool" }
              | { message: string; type: "other" }
            >;
          }>;
          pendingMessageId?: string;
          promptMessageId?: string;
          threadId: string;
          userId?: string;
        },
        {
          messages: Array<{
            _creationTime: number;
            _id: string;
            agentName?: string;
            embeddingId?: string;
            error?: string;
            fileIds?: Array<string>;
            finishReason?:
              | "stop"
              | "length"
              | "content-filter"
              | "tool-calls"
              | "error"
              | "other"
              | "unknown";
            id?: string;
            message?:
              | {
                  content:
                    | string
                    | Array<
                        | {
                            providerMetadata?: Record<
                              string,
                              Record<string, any>
                            >;
                            providerOptions?: Record<
                              string,
                              Record<string, any>
                            >;
                            text: string;
                            type: "text";
                          }
                        | {
                            image: string | ArrayBuffer;
                            mimeType?: string;
                            providerOptions?: Record<
                              string,
                              Record<string, any>
                            >;
                            type: "image";
                          }
                        | {
                            data: string | ArrayBuffer;
                            filename?: string;
                            mimeType: string;
                            providerMetadata?: Record<
                              string,
                              Record<string, any>
                            >;
                            providerOptions?: Record<
                              string,
                              Record<string, any>
                            >;
                            type: "file";
                          }
                      >;
                  providerOptions?: Record<string, Record<string, any>>;
                  role: "user";
                }
              | {
                  content:
                    | string
                    | Array<
                        | {
                            providerMetadata?: Record<
                              string,
                              Record<string, any>
                            >;
                            providerOptions?: Record<
                              string,
                              Record<string, any>
                            >;
                            text: string;
                            type: "text";
                          }
                        | {
                            data: string | ArrayBuffer;
                            filename?: string;
                            mimeType: string;
                            providerMetadata?: Record<
                              string,
                              Record<string, any>
                            >;
                            providerOptions?: Record<
                              string,
                              Record<string, any>
                            >;
                            type: "file";
                          }
                        | {
                            providerMetadata?: Record<
                              string,
                              Record<string, any>
                            >;
                            providerOptions?: Record<
                              string,
                              Record<string, any>
                            >;
                            signature?: string;
                            text: string;
                            type: "reasoning";
                          }
                        | {
                            data: string;
                            providerMetadata?: Record<
                              string,
                              Record<string, any>
                            >;
                            providerOptions?: Record<
                              string,
                              Record<string, any>
                            >;
                            type: "redacted-reasoning";
                          }
                        | {
                            args: any;
                            providerExecuted?: boolean;
                            providerMetadata?: Record<
                              string,
                              Record<string, any>
                            >;
                            providerOptions?: Record<
                              string,
                              Record<string, any>
                            >;
                            toolCallId: string;
                            toolName: string;
                            type: "tool-call";
                          }
                        | {
                            args?: any;
                            experimental_content?: Array<
                              | { text: string; type: "text" }
                              | {
                                  data: string;
                                  mimeType?: string;
                                  type: "image";
                                }
                            >;
                            isError?: boolean;
                            providerExecuted?: boolean;
                            providerMetadata?: Record<
                              string,
                              Record<string, any>
                            >;
                            providerOptions?: Record<
                              string,
                              Record<string, any>
                            >;
                            result: any;
                            toolCallId: string;
                            toolName: string;
                            type: "tool-result";
                          }
                      >;
                  providerOptions?: Record<string, Record<string, any>>;
                  role: "assistant";
                }
              | {
                  content: Array<{
                    args?: any;
                    experimental_content?: Array<
                      | { text: string; type: "text" }
                      | { data: string; mimeType?: string; type: "image" }
                    >;
                    isError?: boolean;
                    providerExecuted?: boolean;
                    providerMetadata?: Record<string, Record<string, any>>;
                    providerOptions?: Record<string, Record<string, any>>;
                    result: any;
                    toolCallId: string;
                    toolName: string;
                    type: "tool-result";
                  }>;
                  providerOptions?: Record<string, Record<string, any>>;
                  role: "tool";
                }
              | {
                  content: string;
                  providerOptions?: Record<string, Record<string, any>>;
                  role: "system";
                };
            model?: string;
            order: number;
            provider?: string;
            providerMetadata?: Record<string, Record<string, any>>;
            providerOptions?: Record<string, Record<string, any>>;
            reasoning?: string;
            reasoningDetails?: Array<
              | {
                  providerMetadata?: Record<string, Record<string, any>>;
                  providerOptions?: Record<string, Record<string, any>>;
                  signature?: string;
                  text: string;
                  type: "reasoning";
                }
              | { signature?: string; text: string; type: "text" }
              | { data: string; type: "redacted" }
            >;
            sources?: Array<
              | {
                  id: string;
                  providerMetadata?: Record<string, Record<string, any>>;
                  providerOptions?: Record<string, Record<string, any>>;
                  sourceType: "url";
                  title?: string;
                  type?: "source";
                  url: string;
                }
              | {
                  filename?: string;
                  id: string;
                  mediaType: string;
                  providerMetadata?: Record<string, Record<string, any>>;
                  providerOptions?: Record<string, Record<string, any>>;
                  sourceType: "document";
                  title: string;
                  type: "source";
                }
            >;
            status: "pending" | "success" | "failed";
            stepOrder: number;
            text?: string;
            threadId: string;
            tool: boolean;
            usage?: {
              cachedInputTokens?: number;
              completionTokens: number;
              promptTokens: number;
              reasoningTokens?: number;
              totalTokens: number;
            };
            userId?: string;
            warnings?: Array<
              | {
                  details?: string;
                  setting: string;
                  type: "unsupported-setting";
                }
              | { details?: string; tool: any; type: "unsupported-tool" }
              | { message: string; type: "other" }
            >;
          }>;
        }
      >;
      deleteByIds: FunctionReference<
        "mutation",
        "internal",
        { messageIds: Array<string> },
        Array<string>
      >;
      deleteByOrder: FunctionReference<
        "mutation",
        "internal",
        {
          endOrder: number;
          endStepOrder?: number;
          startOrder: number;
          startStepOrder?: number;
          threadId: string;
        },
        { isDone: boolean; lastOrder?: number; lastStepOrder?: number }
      >;
      finalizeMessage: FunctionReference<
        "mutation",
        "internal",
        {
          messageId: string;
          result: { status: "success" } | { error: string; status: "failed" };
        },
        null
      >;
      getMessagesByIds: FunctionReference<
        "query",
        "internal",
        { messageIds: Array<string> },
        Array<null | {
          _creationTime: number;
          _id: string;
          agentName?: string;
          embeddingId?: string;
          error?: string;
          fileIds?: Array<string>;
          finishReason?:
            | "stop"
            | "length"
            | "content-filter"
            | "tool-calls"
            | "error"
            | "other"
            | "unknown";
          id?: string;
          message?:
            | {
                content:
                  | string
                  | Array<
                      | {
                          providerMetadata?: Record<
                            string,
                            Record<string, any>
                          >;
                          providerOptions?: Record<string, Record<string, any>>;
                          text: string;
                          type: "text";
                        }
                      | {
                          image: string | ArrayBuffer;
                          mimeType?: string;
                          providerOptions?: Record<string, Record<string, any>>;
                          type: "image";
                        }
                      | {
                          data: string | ArrayBuffer;
                          filename?: string;
                          mimeType: string;
                          providerMetadata?: Record<
                            string,
                            Record<string, any>
                          >;
                          providerOptions?: Record<string, Record<string, any>>;
                          type: "file";
                        }
                    >;
                providerOptions?: Record<string, Record<string, any>>;
                role: "user";
              }
            | {
                content:
                  | string
                  | Array<
                      | {
                          providerMetadata?: Record<
                            string,
                            Record<string, any>
                          >;
                          providerOptions?: Record<string, Record<string, any>>;
                          text: string;
                          type: "text";
                        }
                      | {
                          data: string | ArrayBuffer;
                          filename?: string;
                          mimeType: string;
                          providerMetadata?: Record<
                            string,
                            Record<string, any>
                          >;
                          providerOptions?: Record<string, Record<string, any>>;
                          type: "file";
                        }
                      | {
                          providerMetadata?: Record<
                            string,
                            Record<string, any>
                          >;
                          providerOptions?: Record<string, Record<string, any>>;
                          signature?: string;
                          text: string;
                          type: "reasoning";
                        }
                      | {
                          data: string;
                          providerMetadata?: Record<
                            string,
                            Record<string, any>
                          >;
                          providerOptions?: Record<string, Record<string, any>>;
                          type: "redacted-reasoning";
                        }
                      | {
                          args: any;
                          providerExecuted?: boolean;
                          providerMetadata?: Record<
                            string,
                            Record<string, any>
                          >;
                          providerOptions?: Record<string, Record<string, any>>;
                          toolCallId: string;
                          toolName: string;
                          type: "tool-call";
                        }
                      | {
                          args?: any;
                          experimental_content?: Array<
                            | { text: string; type: "text" }
                            | { data: string; mimeType?: string; type: "image" }
                          >;
                          isError?: boolean;
                          providerExecuted?: boolean;
                          providerMetadata?: Record<
                            string,
                            Record<string, any>
                          >;
                          providerOptions?: Record<string, Record<string, any>>;
                          result: any;
                          toolCallId: string;
                          toolName: string;
                          type: "tool-result";
                        }
                    >;
                providerOptions?: Record<string, Record<string, any>>;
                role: "assistant";
              }
            | {
                content: Array<{
                  args?: any;
                  experimental_content?: Array<
                    | { text: string; type: "text" }
                    | { data: string; mimeType?: string; type: "image" }
                  >;
                  isError?: boolean;
                  providerExecuted?: boolean;
                  providerMetadata?: Record<string, Record<string, any>>;
                  providerOptions?: Record<string, Record<string, any>>;
                  result: any;
                  toolCallId: string;
                  toolName: string;
                  type: "tool-result";
                }>;
                providerOptions?: Record<string, Record<string, any>>;
                role: "tool";
              }
            | {
                content: string;
                providerOptions?: Record<string, Record<string, any>>;
                role: "system";
              };
          model?: string;
          order: number;
          provider?: string;
          providerMetadata?: Record<string, Record<string, any>>;
          providerOptions?: Record<string, Record<string, any>>;
          reasoning?: string;
          reasoningDetails?: Array<
            | {
                providerMetadata?: Record<string, Record<string, any>>;
                providerOptions?: Record<string, Record<string, any>>;
                signature?: string;
                text: string;
                type: "reasoning";
              }
            | { signature?: string; text: string; type: "text" }
            | { data: string; type: "redacted" }
          >;
          sources?: Array<
            | {
                id: string;
                providerMetadata?: Record<string, Record<string, any>>;
                providerOptions?: Record<string, Record<string, any>>;
                sourceType: "url";
                title?: string;
                type?: "source";
                url: string;
              }
            | {
                filename?: string;
                id: string;
                mediaType: string;
                providerMetadata?: Record<string, Record<string, any>>;
                providerOptions?: Record<string, Record<string, any>>;
                sourceType: "document";
                title: string;
                type: "source";
              }
          >;
          status: "pending" | "success" | "failed";
          stepOrder: number;
          text?: string;
          threadId: string;
          tool: boolean;
          usage?: {
            cachedInputTokens?: number;
            completionTokens: number;
            promptTokens: number;
            reasoningTokens?: number;
            totalTokens: number;
          };
          userId?: string;
          warnings?: Array<
            | { details?: string; setting: string; type: "unsupported-setting" }
            | { details?: string; tool: any; type: "unsupported-tool" }
            | { message: string; type: "other" }
          >;
        }>
      >;
      listMessagesByThreadId: FunctionReference<
        "query",
        "internal",
        {
          excludeToolMessages?: boolean;
          order: "asc" | "desc";
          paginationOpts?: {
            cursor: string | null;
            endCursor?: string | null;
            id?: number;
            maximumBytesRead?: number;
            maximumRowsRead?: number;
            numItems: number;
          };
          statuses?: Array<"pending" | "success" | "failed">;
          threadId: string;
          upToAndIncludingMessageId?: string;
        },
        {
          continueCursor: string;
          isDone: boolean;
          page: Array<{
            _creationTime: number;
            _id: string;
            agentName?: string;
            embeddingId?: string;
            error?: string;
            fileIds?: Array<string>;
            finishReason?:
              | "stop"
              | "length"
              | "content-filter"
              | "tool-calls"
              | "error"
              | "other"
              | "unknown";
            id?: string;
            message?:
              | {
                  content:
                    | string
                    | Array<
                        | {
                            providerMetadata?: Record<
                              string,
                              Record<string, any>
                            >;
                            providerOptions?: Record<
                              string,
                              Record<string, any>
                            >;
                            text: string;
                            type: "text";
                          }
                        | {
                            image: string | ArrayBuffer;
                            mimeType?: string;
                            providerOptions?: Record<
                              string,
                              Record<string, any>
                            >;
                            type: "image";
                          }
                        | {
                            data: string | ArrayBuffer;
                            filename?: string;
                            mimeType: string;
                            providerMetadata?: Record<
                              string,
                              Record<string, any>
                            >;
                            providerOptions?: Record<
                              string,
                              Record<string, any>
                            >;
                            type: "file";
                          }
                      >;
                  providerOptions?: Record<string, Record<string, any>>;
                  role: "user";
                }
              | {
                  content:
                    | string
                    | Array<
                        | {
                            providerMetadata?: Record<
                              string,
                              Record<string, any>
                            >;
                            providerOptions?: Record<
                              string,
                              Record<string, any>
                            >;
                            text: string;
                            type: "text";
                          }
                        | {
                            data: string | ArrayBuffer;
                            filename?: string;
                            mimeType: string;
                            providerMetadata?: Record<
                              string,
                              Record<string, any>
                            >;
                            providerOptions?: Record<
                              string,
                              Record<string, any>
                            >;
                            type: "file";
                          }
                        | {
                            providerMetadata?: Record<
                              string,
                              Record<string, any>
                            >;
                            providerOptions?: Record<
                              string,
                              Record<string, any>
                            >;
                            signature?: string;
                            text: string;
                            type: "reasoning";
                          }
                        | {
                            data: string;
                            providerMetadata?: Record<
                              string,
                              Record<string, any>
                            >;
                            providerOptions?: Record<
                              string,
                              Record<string, any>
                            >;
                            type: "redacted-reasoning";
                          }
                        | {
                            args: any;
                            providerExecuted?: boolean;
                            providerMetadata?: Record<
                              string,
                              Record<string, any>
                            >;
                            providerOptions?: Record<
                              string,
                              Record<string, any>
                            >;
                            toolCallId: string;
                            toolName: string;
                            type: "tool-call";
                          }
                        | {
                            args?: any;
                            experimental_content?: Array<
                              | { text: string; type: "text" }
                              | {
                                  data: string;
                                  mimeType?: string;
                                  type: "image";
                                }
                            >;
                            isError?: boolean;
                            providerExecuted?: boolean;
                            providerMetadata?: Record<
                              string,
                              Record<string, any>
                            >;
                            providerOptions?: Record<
                              string,
                              Record<string, any>
                            >;
                            result: any;
                            toolCallId: string;
                            toolName: string;
                            type: "tool-result";
                          }
                      >;
                  providerOptions?: Record<string, Record<string, any>>;
                  role: "assistant";
                }
              | {
                  content: Array<{
                    args?: any;
                    experimental_content?: Array<
                      | { text: string; type: "text" }
                      | { data: string; mimeType?: string; type: "image" }
                    >;
                    isError?: boolean;
                    providerExecuted?: boolean;
                    providerMetadata?: Record<string, Record<string, any>>;
                    providerOptions?: Record<string, Record<string, any>>;
                    result: any;
                    toolCallId: string;
                    toolName: string;
                    type: "tool-result";
                  }>;
                  providerOptions?: Record<string, Record<string, any>>;
                  role: "tool";
                }
              | {
                  content: string;
                  providerOptions?: Record<string, Record<string, any>>;
                  role: "system";
                };
            model?: string;
            order: number;
            provider?: string;
            providerMetadata?: Record<string, Record<string, any>>;
            providerOptions?: Record<string, Record<string, any>>;
            reasoning?: string;
            reasoningDetails?: Array<
              | {
                  providerMetadata?: Record<string, Record<string, any>>;
                  providerOptions?: Record<string, Record<string, any>>;
                  signature?: string;
                  text: string;
                  type: "reasoning";
                }
              | { signature?: string; text: string; type: "text" }
              | { data: string; type: "redacted" }
            >;
            sources?: Array<
              | {
                  id: string;
                  providerMetadata?: Record<string, Record<string, any>>;
                  providerOptions?: Record<string, Record<string, any>>;
                  sourceType: "url";
                  title?: string;
                  type?: "source";
                  url: string;
                }
              | {
                  filename?: string;
                  id: string;
                  mediaType: string;
                  providerMetadata?: Record<string, Record<string, any>>;
                  providerOptions?: Record<string, Record<string, any>>;
                  sourceType: "document";
                  title: string;
                  type: "source";
                }
            >;
            status: "pending" | "success" | "failed";
            stepOrder: number;
            text?: string;
            threadId: string;
            tool: boolean;
            usage?: {
              cachedInputTokens?: number;
              completionTokens: number;
              promptTokens: number;
              reasoningTokens?: number;
              totalTokens: number;
            };
            userId?: string;
            warnings?: Array<
              | {
                  details?: string;
                  setting: string;
                  type: "unsupported-setting";
                }
              | { details?: string; tool: any; type: "unsupported-tool" }
              | { message: string; type: "other" }
            >;
          }>;
          pageStatus?: "SplitRecommended" | "SplitRequired" | null;
          splitCursor?: string | null;
        }
      >;
      searchMessages: FunctionReference<
        "action",
        "internal",
        {
          beforeMessageId?: string;
          embedding?: Array<number>;
          embeddingModel?: string;
          limit: number;
          messageRange?: { after: number; before: number };
          searchAllMessagesForUserId?: string;
          text?: string;
          threadId?: string;
          vectorScoreThreshold?: number;
        },
        Array<{
          _creationTime: number;
          _id: string;
          agentName?: string;
          embeddingId?: string;
          error?: string;
          fileIds?: Array<string>;
          finishReason?:
            | "stop"
            | "length"
            | "content-filter"
            | "tool-calls"
            | "error"
            | "other"
            | "unknown";
          id?: string;
          message?:
            | {
                content:
                  | string
                  | Array<
                      | {
                          providerMetadata?: Record<
                            string,
                            Record<string, any>
                          >;
                          providerOptions?: Record<string, Record<string, any>>;
                          text: string;
                          type: "text";
                        }
                      | {
                          image: string | ArrayBuffer;
                          mimeType?: string;
                          providerOptions?: Record<string, Record<string, any>>;
                          type: "image";
                        }
                      | {
                          data: string | ArrayBuffer;
                          filename?: string;
                          mimeType: string;
                          providerMetadata?: Record<
                            string,
                            Record<string, any>
                          >;
                          providerOptions?: Record<string, Record<string, any>>;
                          type: "file";
                        }
                    >;
                providerOptions?: Record<string, Record<string, any>>;
                role: "user";
              }
            | {
                content:
                  | string
                  | Array<
                      | {
                          providerMetadata?: Record<
                            string,
                            Record<string, any>
                          >;
                          providerOptions?: Record<string, Record<string, any>>;
                          text: string;
                          type: "text";
                        }
                      | {
                          data: string | ArrayBuffer;
                          filename?: string;
                          mimeType: string;
                          providerMetadata?: Record<
                            string,
                            Record<string, any>
                          >;
                          providerOptions?: Record<string, Record<string, any>>;
                          type: "file";
                        }
                      | {
                          providerMetadata?: Record<
                            string,
                            Record<string, any>
                          >;
                          providerOptions?: Record<string, Record<string, any>>;
                          signature?: string;
                          text: string;
                          type: "reasoning";
                        }
                      | {
                          data: string;
                          providerMetadata?: Record<
                            string,
                            Record<string, any>
                          >;
                          providerOptions?: Record<string, Record<string, any>>;
                          type: "redacted-reasoning";
                        }
                      | {
                          args: any;
                          providerExecuted?: boolean;
                          providerMetadata?: Record<
                            string,
                            Record<string, any>
                          >;
                          providerOptions?: Record<string, Record<string, any>>;
                          toolCallId: string;
                          toolName: string;
                          type: "tool-call";
                        }
                      | {
                          args?: any;
                          experimental_content?: Array<
                            | { text: string; type: "text" }
                            | { data: string; mimeType?: string; type: "image" }
                          >;
                          isError?: boolean;
                          providerExecuted?: boolean;
                          providerMetadata?: Record<
                            string,
                            Record<string, any>
                          >;
                          providerOptions?: Record<string, Record<string, any>>;
                          result: any;
                          toolCallId: string;
                          toolName: string;
                          type: "tool-result";
                        }
                    >;
                providerOptions?: Record<string, Record<string, any>>;
                role: "assistant";
              }
            | {
                content: Array<{
                  args?: any;
                  experimental_content?: Array<
                    | { text: string; type: "text" }
                    | { data: string; mimeType?: string; type: "image" }
                  >;
                  isError?: boolean;
                  providerExecuted?: boolean;
                  providerMetadata?: Record<string, Record<string, any>>;
                  providerOptions?: Record<string, Record<string, any>>;
                  result: any;
                  toolCallId: string;
                  toolName: string;
                  type: "tool-result";
                }>;
                providerOptions?: Record<string, Record<string, any>>;
                role: "tool";
              }
            | {
                content: string;
                providerOptions?: Record<string, Record<string, any>>;
                role: "system";
              };
          model?: string;
          order: number;
          provider?: string;
          providerMetadata?: Record<string, Record<string, any>>;
          providerOptions?: Record<string, Record<string, any>>;
          reasoning?: string;
          reasoningDetails?: Array<
            | {
                providerMetadata?: Record<string, Record<string, any>>;
                providerOptions?: Record<string, Record<string, any>>;
                signature?: string;
                text: string;
                type: "reasoning";
              }
            | { signature?: string; text: string; type: "text" }
            | { data: string; type: "redacted" }
          >;
          sources?: Array<
            | {
                id: string;
                providerMetadata?: Record<string, Record<string, any>>;
                providerOptions?: Record<string, Record<string, any>>;
                sourceType: "url";
                title?: string;
                type?: "source";
                url: string;
              }
            | {
                filename?: string;
                id: string;
                mediaType: string;
                providerMetadata?: Record<string, Record<string, any>>;
                providerOptions?: Record<string, Record<string, any>>;
                sourceType: "document";
                title: string;
                type: "source";
              }
          >;
          status: "pending" | "success" | "failed";
          stepOrder: number;
          text?: string;
          threadId: string;
          tool: boolean;
          usage?: {
            cachedInputTokens?: number;
            completionTokens: number;
            promptTokens: number;
            reasoningTokens?: number;
            totalTokens: number;
          };
          userId?: string;
          warnings?: Array<
            | { details?: string; setting: string; type: "unsupported-setting" }
            | { details?: string; tool: any; type: "unsupported-tool" }
            | { message: string; type: "other" }
          >;
        }>
      >;
      textSearch: FunctionReference<
        "query",
        "internal",
        {
          beforeMessageId?: string;
          limit: number;
          searchAllMessagesForUserId?: string;
          text: string;
          threadId?: string;
        },
        Array<{
          _creationTime: number;
          _id: string;
          agentName?: string;
          embeddingId?: string;
          error?: string;
          fileIds?: Array<string>;
          finishReason?:
            | "stop"
            | "length"
            | "content-filter"
            | "tool-calls"
            | "error"
            | "other"
            | "unknown";
          id?: string;
          message?:
            | {
                content:
                  | string
                  | Array<
                      | {
                          providerMetadata?: Record<
                            string,
                            Record<string, any>
                          >;
                          providerOptions?: Record<string, Record<string, any>>;
                          text: string;
                          type: "text";
                        }
                      | {
                          image: string | ArrayBuffer;
                          mimeType?: string;
                          providerOptions?: Record<string, Record<string, any>>;
                          type: "image";
                        }
                      | {
                          data: string | ArrayBuffer;
                          filename?: string;
                          mimeType: string;
                          providerMetadata?: Record<
                            string,
                            Record<string, any>
                          >;
                          providerOptions?: Record<string, Record<string, any>>;
                          type: "file";
                        }
                    >;
                providerOptions?: Record<string, Record<string, any>>;
                role: "user";
              }
            | {
                content:
                  | string
                  | Array<
                      | {
                          providerMetadata?: Record<
                            string,
                            Record<string, any>
                          >;
                          providerOptions?: Record<string, Record<string, any>>;
                          text: string;
                          type: "text";
                        }
                      | {
                          data: string | ArrayBuffer;
                          filename?: string;
                          mimeType: string;
                          providerMetadata?: Record<
                            string,
                            Record<string, any>
                          >;
                          providerOptions?: Record<string, Record<string, any>>;
                          type: "file";
                        }
                      | {
                          providerMetadata?: Record<
                            string,
                            Record<string, any>
                          >;
                          providerOptions?: Record<string, Record<string, any>>;
                          signature?: string;
                          text: string;
                          type: "reasoning";
                        }
                      | {
                          data: string;
                          providerMetadata?: Record<
                            string,
                            Record<string, any>
                          >;
                          providerOptions?: Record<string, Record<string, any>>;
                          type: "redacted-reasoning";
                        }
                      | {
                          args: any;
                          providerExecuted?: boolean;
                          providerMetadata?: Record<
                            string,
                            Record<string, any>
                          >;
                          providerOptions?: Record<string, Record<string, any>>;
                          toolCallId: string;
                          toolName: string;
                          type: "tool-call";
                        }
                      | {
                          args?: any;
                          experimental_content?: Array<
                            | { text: string; type: "text" }
                            | { data: string; mimeType?: string; type: "image" }
                          >;
                          isError?: boolean;
                          providerExecuted?: boolean;
                          providerMetadata?: Record<
                            string,
                            Record<string, any>
                          >;
                          providerOptions?: Record<string, Record<string, any>>;
                          result: any;
                          toolCallId: string;
                          toolName: string;
                          type: "tool-result";
                        }
                    >;
                providerOptions?: Record<string, Record<string, any>>;
                role: "assistant";
              }
            | {
                content: Array<{
                  args?: any;
                  experimental_content?: Array<
                    | { text: string; type: "text" }
                    | { data: string; mimeType?: string; type: "image" }
                  >;
                  isError?: boolean;
                  providerExecuted?: boolean;
                  providerMetadata?: Record<string, Record<string, any>>;
                  providerOptions?: Record<string, Record<string, any>>;
                  result: any;
                  toolCallId: string;
                  toolName: string;
                  type: "tool-result";
                }>;
                providerOptions?: Record<string, Record<string, any>>;
                role: "tool";
              }
            | {
                content: string;
                providerOptions?: Record<string, Record<string, any>>;
                role: "system";
              };
          model?: string;
          order: number;
          provider?: string;
          providerMetadata?: Record<string, Record<string, any>>;
          providerOptions?: Record<string, Record<string, any>>;
          reasoning?: string;
          reasoningDetails?: Array<
            | {
                providerMetadata?: Record<string, Record<string, any>>;
                providerOptions?: Record<string, Record<string, any>>;
                signature?: string;
                text: string;
                type: "reasoning";
              }
            | { signature?: string; text: string; type: "text" }
            | { data: string; type: "redacted" }
          >;
          sources?: Array<
            | {
                id: string;
                providerMetadata?: Record<string, Record<string, any>>;
                providerOptions?: Record<string, Record<string, any>>;
                sourceType: "url";
                title?: string;
                type?: "source";
                url: string;
              }
            | {
                filename?: string;
                id: string;
                mediaType: string;
                providerMetadata?: Record<string, Record<string, any>>;
                providerOptions?: Record<string, Record<string, any>>;
                sourceType: "document";
                title: string;
                type: "source";
              }
          >;
          status: "pending" | "success" | "failed";
          stepOrder: number;
          text?: string;
          threadId: string;
          tool: boolean;
          usage?: {
            cachedInputTokens?: number;
            completionTokens: number;
            promptTokens: number;
            reasoningTokens?: number;
            totalTokens: number;
          };
          userId?: string;
          warnings?: Array<
            | { details?: string; setting: string; type: "unsupported-setting" }
            | { details?: string; tool: any; type: "unsupported-tool" }
            | { message: string; type: "other" }
          >;
        }>
      >;
      updateMessage: FunctionReference<
        "mutation",
        "internal",
        {
          messageId: string;
          patch: {
            error?: string;
            fileIds?: Array<string>;
            finishReason?:
              | "stop"
              | "length"
              | "content-filter"
              | "tool-calls"
              | "error"
              | "other"
              | "unknown";
            message?:
              | {
                  content:
                    | string
                    | Array<
                        | {
                            providerMetadata?: Record<
                              string,
                              Record<string, any>
                            >;
                            providerOptions?: Record<
                              string,
                              Record<string, any>
                            >;
                            text: string;
                            type: "text";
                          }
                        | {
                            image: string | ArrayBuffer;
                            mimeType?: string;
                            providerOptions?: Record<
                              string,
                              Record<string, any>
                            >;
                            type: "image";
                          }
                        | {
                            data: string | ArrayBuffer;
                            filename?: string;
                            mimeType: string;
                            providerMetadata?: Record<
                              string,
                              Record<string, any>
                            >;
                            providerOptions?: Record<
                              string,
                              Record<string, any>
                            >;
                            type: "file";
                          }
                      >;
                  providerOptions?: Record<string, Record<string, any>>;
                  role: "user";
                }
              | {
                  content:
                    | string
                    | Array<
                        | {
                            providerMetadata?: Record<
                              string,
                              Record<string, any>
                            >;
                            providerOptions?: Record<
                              string,
                              Record<string, any>
                            >;
                            text: string;
                            type: "text";
                          }
                        | {
                            data: string | ArrayBuffer;
                            filename?: string;
                            mimeType: string;
                            providerMetadata?: Record<
                              string,
                              Record<string, any>
                            >;
                            providerOptions?: Record<
                              string,
                              Record<string, any>
                            >;
                            type: "file";
                          }
                        | {
                            providerMetadata?: Record<
                              string,
                              Record<string, any>
                            >;
                            providerOptions?: Record<
                              string,
                              Record<string, any>
                            >;
                            signature?: string;
                            text: string;
                            type: "reasoning";
                          }
                        | {
                            data: string;
                            providerMetadata?: Record<
                              string,
                              Record<string, any>
                            >;
                            providerOptions?: Record<
                              string,
                              Record<string, any>
                            >;
                            type: "redacted-reasoning";
                          }
                        | {
                            args: any;
                            providerExecuted?: boolean;
                            providerMetadata?: Record<
                              string,
                              Record<string, any>
                            >;
                            providerOptions?: Record<
                              string,
                              Record<string, any>
                            >;
                            toolCallId: string;
                            toolName: string;
                            type: "tool-call";
                          }
                        | {
                            args?: any;
                            experimental_content?: Array<
                              | { text: string; type: "text" }
                              | {
                                  data: string;
                                  mimeType?: string;
                                  type: "image";
                                }
                            >;
                            isError?: boolean;
                            providerExecuted?: boolean;
                            providerMetadata?: Record<
                              string,
                              Record<string, any>
                            >;
                            providerOptions?: Record<
                              string,
                              Record<string, any>
                            >;
                            result: any;
                            toolCallId: string;
                            toolName: string;
                            type: "tool-result";
                          }
                      >;
                  providerOptions?: Record<string, Record<string, any>>;
                  role: "assistant";
                }
              | {
                  content: Array<{
                    args?: any;
                    experimental_content?: Array<
                      | { text: string; type: "text" }
                      | { data: string; mimeType?: string; type: "image" }
                    >;
                    isError?: boolean;
                    providerExecuted?: boolean;
                    providerMetadata?: Record<string, Record<string, any>>;
                    providerOptions?: Record<string, Record<string, any>>;
                    result: any;
                    toolCallId: string;
                    toolName: string;
                    type: "tool-result";
                  }>;
                  providerOptions?: Record<string, Record<string, any>>;
                  role: "tool";
                }
              | {
                  content: string;
                  providerOptions?: Record<string, Record<string, any>>;
                  role: "system";
                };
            model?: string;
            provider?: string;
            providerOptions?: Record<string, Record<string, any>>;
            status?: "pending" | "success" | "failed";
          };
        },
        {
          _creationTime: number;
          _id: string;
          agentName?: string;
          embeddingId?: string;
          error?: string;
          fileIds?: Array<string>;
          finishReason?:
            | "stop"
            | "length"
            | "content-filter"
            | "tool-calls"
            | "error"
            | "other"
            | "unknown";
          id?: string;
          message?:
            | {
                content:
                  | string
                  | Array<
                      | {
                          providerMetadata?: Record<
                            string,
                            Record<string, any>
                          >;
                          providerOptions?: Record<string, Record<string, any>>;
                          text: string;
                          type: "text";
                        }
                      | {
                          image: string | ArrayBuffer;
                          mimeType?: string;
                          providerOptions?: Record<string, Record<string, any>>;
                          type: "image";
                        }
                      | {
                          data: string | ArrayBuffer;
                          filename?: string;
                          mimeType: string;
                          providerMetadata?: Record<
                            string,
                            Record<string, any>
                          >;
                          providerOptions?: Record<string, Record<string, any>>;
                          type: "file";
                        }
                    >;
                providerOptions?: Record<string, Record<string, any>>;
                role: "user";
              }
            | {
                content:
                  | string
                  | Array<
                      | {
                          providerMetadata?: Record<
                            string,
                            Record<string, any>
                          >;
                          providerOptions?: Record<string, Record<string, any>>;
                          text: string;
                          type: "text";
                        }
                      | {
                          data: string | ArrayBuffer;
                          filename?: string;
                          mimeType: string;
                          providerMetadata?: Record<
                            string,
                            Record<string, any>
                          >;
                          providerOptions?: Record<string, Record<string, any>>;
                          type: "file";
                        }
                      | {
                          providerMetadata?: Record<
                            string,
                            Record<string, any>
                          >;
                          providerOptions?: Record<string, Record<string, any>>;
                          signature?: string;
                          text: string;
                          type: "reasoning";
                        }
                      | {
                          data: string;
                          providerMetadata?: Record<
                            string,
                            Record<string, any>
                          >;
                          providerOptions?: Record<string, Record<string, any>>;
                          type: "redacted-reasoning";
                        }
                      | {
                          args: any;
                          providerExecuted?: boolean;
                          providerMetadata?: Record<
                            string,
                            Record<string, any>
                          >;
                          providerOptions?: Record<string, Record<string, any>>;
                          toolCallId: string;
                          toolName: string;
                          type: "tool-call";
                        }
                      | {
                          args?: any;
                          experimental_content?: Array<
                            | { text: string; type: "text" }
                            | { data: string; mimeType?: string; type: "image" }
                          >;
                          isError?: boolean;
                          providerExecuted?: boolean;
                          providerMetadata?: Record<
                            string,
                            Record<string, any>
                          >;
                          providerOptions?: Record<string, Record<string, any>>;
                          result: any;
                          toolCallId: string;
                          toolName: string;
                          type: "tool-result";
                        }
                    >;
                providerOptions?: Record<string, Record<string, any>>;
                role: "assistant";
              }
            | {
                content: Array<{
                  args?: any;
                  experimental_content?: Array<
                    | { text: string; type: "text" }
                    | { data: string; mimeType?: string; type: "image" }
                  >;
                  isError?: boolean;
                  providerExecuted?: boolean;
                  providerMetadata?: Record<string, Record<string, any>>;
                  providerOptions?: Record<string, Record<string, any>>;
                  result: any;
                  toolCallId: string;
                  toolName: string;
                  type: "tool-result";
                }>;
                providerOptions?: Record<string, Record<string, any>>;
                role: "tool";
              }
            | {
                content: string;
                providerOptions?: Record<string, Record<string, any>>;
                role: "system";
              };
          model?: string;
          order: number;
          provider?: string;
          providerMetadata?: Record<string, Record<string, any>>;
          providerOptions?: Record<string, Record<string, any>>;
          reasoning?: string;
          reasoningDetails?: Array<
            | {
                providerMetadata?: Record<string, Record<string, any>>;
                providerOptions?: Record<string, Record<string, any>>;
                signature?: string;
                text: string;
                type: "reasoning";
              }
            | { signature?: string; text: string; type: "text" }
            | { data: string; type: "redacted" }
          >;
          sources?: Array<
            | {
                id: string;
                providerMetadata?: Record<string, Record<string, any>>;
                providerOptions?: Record<string, Record<string, any>>;
                sourceType: "url";
                title?: string;
                type?: "source";
                url: string;
              }
            | {
                filename?: string;
                id: string;
                mediaType: string;
                providerMetadata?: Record<string, Record<string, any>>;
                providerOptions?: Record<string, Record<string, any>>;
                sourceType: "document";
                title: string;
                type: "source";
              }
          >;
          status: "pending" | "success" | "failed";
          stepOrder: number;
          text?: string;
          threadId: string;
          tool: boolean;
          usage?: {
            cachedInputTokens?: number;
            completionTokens: number;
            promptTokens: number;
            reasoningTokens?: number;
            totalTokens: number;
          };
          userId?: string;
          warnings?: Array<
            | { details?: string; setting: string; type: "unsupported-setting" }
            | { details?: string; tool: any; type: "unsupported-tool" }
            | { message: string; type: "other" }
          >;
        }
      >;
    };
    streams: {
      abort: FunctionReference<
        "mutation",
        "internal",
        {
          finalDelta?: {
            end: number;
            parts: Array<any>;
            start: number;
            streamId: string;
          };
          reason: string;
          streamId: string;
        },
        boolean
      >;
      abortByOrder: FunctionReference<
        "mutation",
        "internal",
        { order: number; reason: string; threadId: string },
        boolean
      >;
      addDelta: FunctionReference<
        "mutation",
        "internal",
        { end: number; parts: Array<any>; start: number; streamId: string },
        boolean
      >;
      create: FunctionReference<
        "mutation",
        "internal",
        {
          agentName?: string;
          model?: string;
          order: number;
          provider?: string;
          providerOptions?: Record<string, Record<string, any>>;
          stepOrder: number;
          threadId: string;
          userId?: string;
        },
        string
      >;
      deleteAllStreamsForThreadIdAsync: FunctionReference<
        "mutation",
        "internal",
        { deltaCursor?: string; streamOrder?: number; threadId: string },
        { deltaCursor?: string; isDone: boolean; streamOrder?: number }
      >;
      deleteAllStreamsForThreadIdSync: FunctionReference<
        "action",
        "internal",
        { threadId: string },
        null
      >;
      deleteStreamAsync: FunctionReference<
        "mutation",
        "internal",
        { cursor?: string; streamId: string },
        null
      >;
      deleteStreamSync: FunctionReference<
        "mutation",
        "internal",
        { streamId: string },
        null
      >;
      finish: FunctionReference<
        "mutation",
        "internal",
        {
          finalDelta?: {
            end: number;
            parts: Array<any>;
            start: number;
            streamId: string;
          };
          streamId: string;
        },
        null
      >;
      heartbeat: FunctionReference<
        "mutation",
        "internal",
        { streamId: string },
        null
      >;
      list: FunctionReference<
        "query",
        "internal",
        {
          startOrder?: number;
          statuses?: Array<"streaming" | "finished" | "aborted">;
          threadId: string;
        },
        Array<{
          agentName?: string;
          model?: string;
          order: number;
          provider?: string;
          providerOptions?: Record<string, Record<string, any>>;
          status: "streaming" | "finished" | "aborted";
          stepOrder: number;
          streamId: string;
          userId?: string;
        }>
      >;
      listDeltas: FunctionReference<
        "query",
        "internal",
        {
          cursors: Array<{ cursor: number; streamId: string }>;
          threadId: string;
        },
        Array<{
          end: number;
          parts: Array<any>;
          start: number;
          streamId: string;
        }>
      >;
    };
    threads: {
      createThread: FunctionReference<
        "mutation",
        "internal",
        {
          defaultSystemPrompt?: string;
          parentThreadIds?: Array<string>;
          summary?: string;
          title?: string;
          userId?: string;
        },
        {
          _creationTime: number;
          _id: string;
          status: "active" | "archived";
          summary?: string;
          title?: string;
          userId?: string;
        }
      >;
      deleteAllForThreadIdAsync: FunctionReference<
        "mutation",
        "internal",
        {
          cursor?: string;
          deltaCursor?: string;
          limit?: number;
          messagesDone?: boolean;
          streamOrder?: number;
          streamsDone?: boolean;
          threadId: string;
        },
        { isDone: boolean }
      >;
      deleteAllForThreadIdSync: FunctionReference<
        "action",
        "internal",
        { limit?: number; threadId: string },
        null
      >;
      getThread: FunctionReference<
        "query",
        "internal",
        { threadId: string },
        {
          _creationTime: number;
          _id: string;
          status: "active" | "archived";
          summary?: string;
          title?: string;
          userId?: string;
        } | null
      >;
      listThreadsByUserId: FunctionReference<
        "query",
        "internal",
        {
          order?: "asc" | "desc";
          paginationOpts?: {
            cursor: string | null;
            endCursor?: string | null;
            id?: number;
            maximumBytesRead?: number;
            maximumRowsRead?: number;
            numItems: number;
          };
          userId?: string;
        },
        {
          continueCursor: string;
          isDone: boolean;
          page: Array<{
            _creationTime: number;
            _id: string;
            status: "active" | "archived";
            summary?: string;
            title?: string;
            userId?: string;
          }>;
          pageStatus?: "SplitRecommended" | "SplitRequired" | null;
          splitCursor?: string | null;
        }
      >;
      searchThreadTitles: FunctionReference<
        "query",
        "internal",
        { limit: number; query: string; userId?: string | null },
        Array<{
          _creationTime: number;
          _id: string;
          status: "active" | "archived";
          summary?: string;
          title?: string;
          userId?: string;
        }>
      >;
      updateThread: FunctionReference<
        "mutation",
        "internal",
        {
          patch: {
            status?: "active" | "archived";
            summary?: string;
            title?: string;
            userId?: string;
          };
          threadId: string;
        },
        {
          _creationTime: number;
          _id: string;
          status: "active" | "archived";
          summary?: string;
          title?: string;
          userId?: string;
        }
      >;
    };
    users: {
      deleteAllForUserId: FunctionReference<
        "action",
        "internal",
        { userId: string },
        null
      >;
      deleteAllForUserIdAsync: FunctionReference<
        "mutation",
        "internal",
        { userId: string },
        boolean
      >;
      listUsersWithThreads: FunctionReference<
        "query",
        "internal",
        {
          paginationOpts: {
            cursor: string | null;
            endCursor?: string | null;
            id?: number;
            maximumBytesRead?: number;
            maximumRowsRead?: number;
            numItems: number;
          };
        },
        {
          continueCursor: string;
          isDone: boolean;
          page: Array<string>;
          pageStatus?: "SplitRecommended" | "SplitRequired" | null;
          splitCursor?: string | null;
        }
      >;
    };
    vector: {
      index: {
        deleteBatch: FunctionReference<
          "mutation",
          "internal",
          {
            ids: Array<
              | string
              | string
              | string
              | string
              | string
              | string
              | string
              | string
              | string
              | string
            >;
          },
          null
        >;
        deleteBatchForThread: FunctionReference<
          "mutation",
          "internal",
          {
            cursor?: string;
            limit: number;
            model: string;
            threadId: string;
            vectorDimension:
              | 128
              | 256
              | 512
              | 768
              | 1024
              | 1408
              | 1536
              | 2048
              | 3072
              | 4096;
          },
          { continueCursor: string; isDone: boolean }
        >;
        insertBatch: FunctionReference<
          "mutation",
          "internal",
          {
            vectorDimension:
              | 128
              | 256
              | 512
              | 768
              | 1024
              | 1408
              | 1536
              | 2048
              | 3072
              | 4096;
            vectors: Array<{
              messageId?: string;
              model: string;
              table: string;
              threadId?: string;
              userId?: string;
              vector: Array<number>;
            }>;
          },
          Array<
            | string
            | string
            | string
            | string
            | string
            | string
            | string
            | string
            | string
            | string
          >
        >;
        paginate: FunctionReference<
          "query",
          "internal",
          {
            cursor?: string;
            limit: number;
            table?: string;
            targetModel: string;
            vectorDimension:
              | 128
              | 256
              | 512
              | 768
              | 1024
              | 1408
              | 1536
              | 2048
              | 3072
              | 4096;
          },
          {
            continueCursor: string;
            ids: Array<
              | string
              | string
              | string
              | string
              | string
              | string
              | string
              | string
              | string
              | string
            >;
            isDone: boolean;
          }
        >;
        updateBatch: FunctionReference<
          "mutation",
          "internal",
          {
            vectors: Array<{
              id:
                | string
                | string
                | string
                | string
                | string
                | string
                | string
                | string
                | string
                | string;
              model: string;
              vector: Array<number>;
            }>;
          },
          null
        >;
      };
    };
  };
  resend: {
    lib: {
      cancelEmail: FunctionReference<
        "mutation",
        "internal",
        { emailId: string },
        null
      >;
      cleanupAbandonedEmails: FunctionReference<
        "mutation",
        "internal",
        { olderThan?: number },
        null
      >;
      cleanupOldEmails: FunctionReference<
        "mutation",
        "internal",
        { olderThan?: number },
        null
      >;
      createManualEmail: FunctionReference<
        "mutation",
        "internal",
        {
          from: string;
          headers?: Array<{ name: string; value: string }>;
          replyTo?: Array<string>;
          subject: string;
          to: string;
        },
        string
      >;
      get: FunctionReference<
        "query",
        "internal",
        { emailId: string },
        {
          complained: boolean;
          createdAt: number;
          errorMessage?: string;
          finalizedAt: number;
          from: string;
          headers?: Array<{ name: string; value: string }>;
          html?: string;
          opened: boolean;
          replyTo: Array<string>;
          resendId?: string;
          segment: number;
          status:
            | "waiting"
            | "queued"
            | "cancelled"
            | "sent"
            | "delivered"
            | "delivery_delayed"
            | "bounced"
            | "failed";
          subject: string;
          text?: string;
          to: string;
        } | null
      >;
      getStatus: FunctionReference<
        "query",
        "internal",
        { emailId: string },
        {
          complained: boolean;
          errorMessage: string | null;
          opened: boolean;
          status:
            | "waiting"
            | "queued"
            | "cancelled"
            | "sent"
            | "delivered"
            | "delivery_delayed"
            | "bounced"
            | "failed";
        } | null
      >;
      handleEmailEvent: FunctionReference<
        "mutation",
        "internal",
        { event: any },
        null
      >;
      sendEmail: FunctionReference<
        "mutation",
        "internal",
        {
          from: string;
          headers?: Array<{ name: string; value: string }>;
          html?: string;
          options: {
            apiKey: string;
            initialBackoffMs: number;
            onEmailEvent?: { fnHandle: string };
            retryAttempts: number;
            testMode: boolean;
          };
          replyTo?: Array<string>;
          subject: string;
          text?: string;
          to: string;
        },
        string
      >;
      updateManualEmail: FunctionReference<
        "mutation",
        "internal",
        {
          emailId: string;
          errorMessage?: string;
          resendId?: string;
          status:
            | "waiting"
            | "queued"
            | "cancelled"
            | "sent"
            | "delivered"
            | "delivery_delayed"
            | "bounced"
            | "failed";
        },
        null
      >;
    };
  };
};
</file>

<file path="convex/_generated/api.js">
/* eslint-disable */
/**
 * Generated `api` utility.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import { anyApi, componentsGeneric } from "convex/server";

/**
 * A utility for referencing Convex functions in your app's API.
 *
 * Usage:
 * ```js
 * const myFunctionReference = api.myModule.myFunction;
 * ```
 */
export const api = anyApi;
export const internal = anyApi;
export const components = componentsGeneric();
</file>

<file path="convex/_generated/dataModel.d.ts">
/* eslint-disable */
/**
 * Generated data model types.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import type {
  DataModelFromSchemaDefinition,
  DocumentByName,
  TableNamesInDataModel,
  SystemTableNames,
} from "convex/server";
import type { GenericId } from "convex/values";
import schema from "../schema.js";

/**
 * The names of all of your Convex tables.
 */
export type TableNames = TableNamesInDataModel<DataModel>;

/**
 * The type of a document stored in Convex.
 *
 * @typeParam TableName - A string literal type of the table name (like "users").
 */
export type Doc<TableName extends TableNames> = DocumentByName<
  DataModel,
  TableName
>;

/**
 * An identifier for a document in Convex.
 *
 * Convex documents are uniquely identified by their `Id`, which is accessible
 * on the `_id` field. To learn more, see [Document IDs](https://docs.convex.dev/using/document-ids).
 *
 * Documents can be loaded using `db.get(id)` in query and mutation functions.
 *
 * IDs are just strings at runtime, but this type can be used to distinguish them from other
 * strings when type checking.
 *
 * @typeParam TableName - A string literal type of the table name (like "users").
 */
export type Id<TableName extends TableNames | SystemTableNames> =
  GenericId<TableName>;

/**
 * A type describing your Convex data model.
 *
 * This type includes information about what tables you have, the type of
 * documents stored in those tables, and the indexes defined on them.
 *
 * This type is used to parameterize methods like `queryGeneric` and
 * `mutationGeneric` to make them type-safe.
 */
export type DataModel = DataModelFromSchemaDefinition<typeof schema>;
</file>

<file path="convex/_generated/server.d.ts">
/* eslint-disable */
/**
 * Generated utilities for implementing server-side Convex query and mutation functions.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import {
  ActionBuilder,
  AnyComponents,
  HttpActionBuilder,
  MutationBuilder,
  QueryBuilder,
  GenericActionCtx,
  GenericMutationCtx,
  GenericQueryCtx,
  GenericDatabaseReader,
  GenericDatabaseWriter,
  FunctionReference,
} from "convex/server";
import type { DataModel } from "./dataModel.js";

type GenericCtx =
  | GenericActionCtx<DataModel>
  | GenericMutationCtx<DataModel>
  | GenericQueryCtx<DataModel>;

/**
 * Define a query in this Convex app's public API.
 *
 * This function will be allowed to read your Convex database and will be accessible from the client.
 *
 * @param func - The query function. It receives a {@link QueryCtx} as its first argument.
 * @returns The wrapped query. Include this as an `export` to name it and make it accessible.
 */
export declare const query: QueryBuilder<DataModel, "public">;

/**
 * Define a query that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to read from your Convex database. It will not be accessible from the client.
 *
 * @param func - The query function. It receives a {@link QueryCtx} as its first argument.
 * @returns The wrapped query. Include this as an `export` to name it and make it accessible.
 */
export declare const internalQuery: QueryBuilder<DataModel, "internal">;

/**
 * Define a mutation in this Convex app's public API.
 *
 * This function will be allowed to modify your Convex database and will be accessible from the client.
 *
 * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.
 * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.
 */
export declare const mutation: MutationBuilder<DataModel, "public">;

/**
 * Define a mutation that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to modify your Convex database. It will not be accessible from the client.
 *
 * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.
 * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.
 */
export declare const internalMutation: MutationBuilder<DataModel, "internal">;

/**
 * Define an action in this Convex app's public API.
 *
 * An action is a function which can execute any JavaScript code, including non-deterministic
 * code and code with side-effects, like calling third-party services.
 * They can be run in Convex's JavaScript environment or in Node.js using the "use node" directive.
 * They can interact with the database indirectly by calling queries and mutations using the {@link ActionCtx}.
 *
 * @param func - The action. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped action. Include this as an `export` to name it and make it accessible.
 */
export declare const action: ActionBuilder<DataModel, "public">;

/**
 * Define an action that is only accessible from other Convex functions (but not from the client).
 *
 * @param func - The function. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped function. Include this as an `export` to name it and make it accessible.
 */
export declare const internalAction: ActionBuilder<DataModel, "internal">;

/**
 * Define an HTTP action.
 *
 * This function will be used to respond to HTTP requests received by a Convex
 * deployment if the requests matches the path and method where this action
 * is routed. Be sure to route your action in `convex/http.js`.
 *
 * @param func - The function. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped function. Import this function from `convex/http.js` and route it to hook it up.
 */
export declare const httpAction: HttpActionBuilder;

/**
 * A set of services for use within Convex query functions.
 *
 * The query context is passed as the first argument to any Convex query
 * function run on the server.
 *
 * This differs from the {@link MutationCtx} because all of the services are
 * read-only.
 */
export type QueryCtx = GenericQueryCtx<DataModel>;

/**
 * A set of services for use within Convex mutation functions.
 *
 * The mutation context is passed as the first argument to any Convex mutation
 * function run on the server.
 */
export type MutationCtx = GenericMutationCtx<DataModel>;

/**
 * A set of services for use within Convex action functions.
 *
 * The action context is passed as the first argument to any Convex action
 * function run on the server.
 */
export type ActionCtx = GenericActionCtx<DataModel>;

/**
 * An interface to read from the database within Convex query functions.
 *
 * The two entry points are {@link DatabaseReader.get}, which fetches a single
 * document by its {@link Id}, or {@link DatabaseReader.query}, which starts
 * building a query.
 */
export type DatabaseReader = GenericDatabaseReader<DataModel>;

/**
 * An interface to read from and write to the database within Convex mutation
 * functions.
 *
 * Convex guarantees that all writes within a single mutation are
 * executed atomically, so you never have to worry about partial writes leaving
 * your data in an inconsistent state. See [the Convex Guide](https://docs.convex.dev/understanding/convex-fundamentals/functions#atomicity-and-optimistic-concurrency-control)
 * for the guarantees Convex provides your functions.
 */
export type DatabaseWriter = GenericDatabaseWriter<DataModel>;
</file>

<file path="convex/_generated/server.js">
/* eslint-disable */
/**
 * Generated utilities for implementing server-side Convex query and mutation functions.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import {
  actionGeneric,
  httpActionGeneric,
  queryGeneric,
  mutationGeneric,
  internalActionGeneric,
  internalMutationGeneric,
  internalQueryGeneric,
  componentsGeneric,
} from "convex/server";

/**
 * Define a query in this Convex app's public API.
 *
 * This function will be allowed to read your Convex database and will be accessible from the client.
 *
 * @param func - The query function. It receives a {@link QueryCtx} as its first argument.
 * @returns The wrapped query. Include this as an `export` to name it and make it accessible.
 */
export const query = queryGeneric;

/**
 * Define a query that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to read from your Convex database. It will not be accessible from the client.
 *
 * @param func - The query function. It receives a {@link QueryCtx} as its first argument.
 * @returns The wrapped query. Include this as an `export` to name it and make it accessible.
 */
export const internalQuery = internalQueryGeneric;

/**
 * Define a mutation in this Convex app's public API.
 *
 * This function will be allowed to modify your Convex database and will be accessible from the client.
 *
 * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.
 * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.
 */
export const mutation = mutationGeneric;

/**
 * Define a mutation that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to modify your Convex database. It will not be accessible from the client.
 *
 * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.
 * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.
 */
export const internalMutation = internalMutationGeneric;

/**
 * Define an action in this Convex app's public API.
 *
 * An action is a function which can execute any JavaScript code, including non-deterministic
 * code and code with side-effects, like calling third-party services.
 * They can be run in Convex's JavaScript environment or in Node.js using the "use node" directive.
 * They can interact with the database indirectly by calling queries and mutations using the {@link ActionCtx}.
 *
 * @param func - The action. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped action. Include this as an `export` to name it and make it accessible.
 */
export const action = actionGeneric;

/**
 * Define an action that is only accessible from other Convex functions (but not from the client).
 *
 * @param func - The function. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped function. Include this as an `export` to name it and make it accessible.
 */
export const internalAction = internalActionGeneric;

/**
 * Define a Convex HTTP action.
 *
 * @param func - The function. It receives an {@link ActionCtx} as its first argument, and a `Request` object
 * as its second.
 * @returns The wrapped endpoint function. Route a URL path to this function in `convex/http.js`.
 */
export const httpAction = httpActionGeneric;
</file>

<file path="convex/agents.ts">
import { Agent } from "@convex-dev/agent";
import { components } from "./_generated/api";
import { v } from "convex/values";
import { action, mutation, query, internalAction } from "./_generated/server";
import { Id } from "./_generated/dataModel";
import { api, internal } from "./_generated/api";

// Create a factory function for the language model that accepts context
function createToyLanguageModel(ctx: any) {
  return {
    specificationVersion: 'v2' as const,
    provider: 'openrouter',
    modelId: 'openai/gpt-oss-120b',
    supportedUrls: {},
    
    async doGenerate(options: any) {
      // Extract messages and system prompt
      const messages: any[] = [];
      if (options.system) {
        messages.push({ role: 'system', content: options.system });
      }
      if (options.prompt) {
        // Handle both string and object prompt formats
        let promptContent = '';
        if (typeof options.prompt === 'string') {
          promptContent = options.prompt;
        } else if (options.prompt) {
          // Extract text from nested structures
          promptContent = options.prompt?.content || options.prompt?.text || 
            (typeof options.prompt === 'object' ? JSON.stringify(options.prompt) : String(options.prompt));
        }
        if (promptContent) {
          messages.push({ role: 'user', content: promptContent });
        }
      }
      // Add any previous messages from options
      if (options.messages && Array.isArray(options.messages)) {
        // Normalize message format
        const normalizedMessages = options.messages.map((msg: any) => {
          // Extract content from various formats
          let content = msg.content;
          if (typeof content !== 'string') {
            if (Array.isArray(content)) {
              // Handle array of content objects (Convex Agent format)
              const textParts = content
                .filter((item: any) => item && (item.type === 'text' || item.text || item.content))
                .map((item: any) => {
                  if (typeof item === 'string') return item;
                  if (item.type === 'text' && item.text) return item.text;
                  if (item.content) return item.content;
                  if (item.text) return item.text;
                  return '';
                })
                .filter(Boolean);
              content = textParts.join(' ');
            } else if (content && typeof content === 'object') {
              // Handle single content object
              content = content.text || content.content || 
                (content.type === 'text' && content.value) || '';
            }
            // Only use JSON.stringify for debugging unknown structures
            if (!content && msg.content) {
              console.warn('Unknown message content structure:', msg.content);
              content = '';
            }
          }
          return {
            role: msg.role || 'user',
            content: content || ''
          };
        });
        messages.push(...normalizedMessages);
      }
      
      try {
        // Use the Convex context to call our AI services directly
        const result = await ctx.runAction(api.aiServices.generateResponse, {
          messages,
          model: options.model || 'openai/gpt-oss-120b',
          temperature: options.temperature || 0.7,
          maxTokens: options.maxTokens || 500,
        });
        
        return {
          content: [{
            type: 'text' as const,
            text: result.content || "I'm having trouble understanding. Can you try again?",
          }],
          finishReason: 'stop' as const,
          usage: {
            inputTokens: result.usage?.prompt_tokens || 0,
            outputTokens: result.usage?.completion_tokens || 0,
            totalTokens: result.usage?.total_tokens || 0,
          },
          warnings: [],
        };
      } catch (error) {
        console.error('Language model error:', error);
        // Return a safe fallback response
        return {
          content: [{
            type: 'text' as const,
            text: "I'm having a little trouble right now. Can you ask me again?",
          }],
          finishReason: 'error' as const,
          usage: {
            inputTokens: 0,
            outputTokens: 0,
            totalTokens: 0,
          },
          warnings: [String(error)],
        };
      }
    },
  
    async doStream(options: any) {
      // For streaming, we need to handle it differently
      // Since Convex doesn't directly support streaming from actions,
      // we'll simulate streaming by breaking the response into chunks
      const fullResponse = await this.doGenerate(options);
      const text = fullResponse.content[0]?.text || "";
      const words = text.split(' ');
      
      const stream = new ReadableStream({
        start(controller) {
          let index = 0;
          const pushNext = () => {
            if (index < words.length) {
              controller.enqueue({
                type: 'text-delta' as const,
                delta: words[index] + (index < words.length - 1 ? ' ' : ''),
              });
              index++;
              // Faster streaming for better UX
              setTimeout(pushNext, 30);
            } else {
              controller.enqueue({
                type: 'finish' as const,
                finishReason: fullResponse.finishReason,
                usage: fullResponse.usage,
              });
              controller.close();
            }
          };
          pushNext();
        },
      });
      
      return {
        stream,
        warnings: fullResponse.warnings,
      };
    },
  };
}

// Default language model for backward compatibility
const toyLanguageModel = {
  specificationVersion: 'v2' as const,
  provider: 'openrouter',
  modelId: 'openai/gpt-oss-120b',
  supportedUrls: {},
  
  async doGenerate(options: any) {
    console.warn('Using default language model without context - responses will be limited');
    return {
      content: [{
        type: 'text' as const,
        text: "I need to be properly connected to help you. Please check my configuration.",
      }],
      finishReason: 'stop' as const,
      usage: { inputTokens: 0, outputTokens: 0, totalTokens: 0 },
      warnings: ['No context available'],
    };
  },
  
  async doStream(options: any) {
    const response = await this.doGenerate(options);
    const text = response.content[0]?.text || "";
    return {
      stream: new ReadableStream({
        start(controller) {
          controller.enqueue({ type: 'text-delta' as const, delta: text });
          controller.enqueue({ type: 'finish' as const, finishReason: 'stop' as const, usage: response.usage });
          controller.close();
        },
      }),
      warnings: response.warnings,
    };
  },
};

// Define the main toy agent - will be initialized with context in actions
// This is a placeholder that should not be used directly
export const toyAgent = new Agent(components.agent, {
  name: "ToyAgent",
  languageModel: toyLanguageModel as any, // Default fallback model
  instructions: "You are a friendly AI toy assistant. Be helpful, safe, and age-appropriate.",
});

// Helper to create a properly configured agent with context
function createAgentWithContext(ctx: any, toy: any) {
  const systemPrompt = buildToySystemPrompt(toy);
  return new Agent(components.agent, {
    name: toy.name || "ToyAgent",
    languageModel: createToyLanguageModel(ctx) as any,
    instructions: systemPrompt,
  });
}

// Create a thread for a toy
export const createToyThread = mutation({
  args: {
    toyId: v.id("toys"),
    userId: v.optional(v.id("users")),
    deviceId: v.optional(v.string()),
  },
  handler: async (ctx, { toyId, userId, deviceId }) => {
    const toy = await ctx.db.get(toyId);
    if (!toy) throw new Error("Toy not found");

    // Create agent thread with toy-specific metadata
    const { threadId } = await toyAgent.createThread(ctx, {
      userId: userId?.toString(),
      title: toy.name,
      summary: `Toy thread for ${toy.name}`,
    });

    return { 
      threadId,
      toyId: toyId,
      metadata: {
        toyId: toyId.toString(),
        toyName: toy.name,
        isForKids: toy.isForKids,
        deviceId: deviceId || "",
        createdAt: Date.now(),
      },
    };
  },
});

// Get or create thread for a toy (canonical thread)
export const getOrCreateToyThread = mutation({
  args: {
    toyId: v.id("toys"),
    userId: v.optional(v.id("users")),
  },
  handler: async (ctx, { toyId, userId }): Promise<{ threadId: string }> => {
    const toy = await ctx.db.get(toyId);
    if (!toy) throw new Error("Toy not found");

    // If toy already has a canonical agent thread, return it
    if ((toy as any).agentThreadId) {
      return { threadId: (toy as any).agentThreadId as string };
    }

    // Otherwise, create a new thread and persist its id on the toy
    const { threadId } = await toyAgent.createThread(ctx, {
      userId: userId?.toString(),
      title: toy.name,
      summary: `Toy thread for ${toy.name}`,
    });

    await ctx.db.patch(toyId, { agentThreadId: threadId, lastModifiedAt: new Date().toISOString() });
    return { threadId };
  },
});

// Get or create thread for a device
export const getOrCreateDeviceThread = mutation({
  args: {
    deviceId: v.string(),
    toyId: v.id("toys"),
  },
  handler: async (ctx, { deviceId, toyId }): Promise<{
    threadId: string;
    toyId: Id<"toys">;
    metadata: {
      toyId: string;
      toyName: string;
      isForKids: boolean;
      deviceId: string;
      createdAt: number;
    };
    existing: boolean;
  }> => {
    // NOTE: The Agent component manages its own tables; we avoid querying a non-existent
    // 'threads' table. For now, always create a fresh thread scoped to device+toy.
    const result: {
      threadId: string;
      toyId: Id<"toys">;
      metadata: {
        toyId: string;
        toyName: string;
        isForKids: boolean;
        deviceId: string;
        createdAt: number;
      };
    } = await ctx.runMutation(api.agents.createToyThread, {
      toyId,
      deviceId,
    });
    return { ...result, existing: false };
  },
});

// Save a message from audio interaction
export const saveAudioMessage = mutation({
  args: {
    threadId: v.string(),
    transcript: v.string(),
    audioUrl: v.optional(v.string()),
    userId: v.optional(v.id("users")),
  },
  handler: async (ctx, { threadId, transcript, audioUrl, userId }) => {
    const { messageId } = await toyAgent.saveMessage(ctx, {
      threadId,
      userId: userId?.toString(),
      prompt: transcript,
      metadata: {},
      skipEmbeddings: true, // Will be generated in action
    });

    return { messageId };
  },
});

// Generate AI response (to be called from both web chat and physical toy)
export const generateToyResponse = internalAction({
  args: {
    threadId: v.string(),
    toyId: v.id("toys"),
    promptMessageId: v.optional(v.string()),
    prompt: v.optional(v.string()),
  },
  handler: async (ctx, { threadId, toyId, promptMessageId, prompt }): Promise<{
    text: string;
    messageId: string | undefined;
    usage?: any;
    finishReason?: any;
  }> => {
    // Get toy configuration
    const toy: any = await ctx.runQuery(api.toys.getToy, { toyId });
    if (!toy) throw new Error("Toy not found");

    // Build system prompt with toy personality
    const systemPrompt = buildToySystemPrompt(toy);

    // Configure safety instructions for kids
    const safetyInstructions: string = toy.isForKids ? `

CRITICAL SAFETY RULES FOR CHILDREN:
- You are talking to a ${toy.ageGroup || "young"} child
- Use simple, age-appropriate language
- Never discuss violence, scary topics, or adult themes
- Always be positive, educational, and encouraging
- If asked about inappropriate topics, redirect to fun activities
- Keep responses short (2-3 sentences max)
- Use sound effects and expressions to be engaging
` : "";

    try {
      // Create a properly configured agent with context
      const agent = createAgentWithContext(ctx, toy);
      
      // Use the Agent's generateText method for proper context management
      // Use either promptMessageId OR prompt, not both (Convex Agent best practice)
      const generateArgs: any = {
        system: systemPrompt + safetyInstructions,
        temperature: toy.personalityTraits?.behavior?.imaginationLevel
          ? toy.personalityTraits.behavior.imaginationLevel / 10
          : 0.7,
      };
      
      // Only set one of promptMessageId or prompt
      if (promptMessageId) {
        generateArgs.promptMessageId = promptMessageId;
      } else if (prompt) {
        generateArgs.prompt = prompt;
      } else {
        throw new Error("Either promptMessageId or prompt must be provided");
      }
      
      const result = await agent.generateText(
        ctx,
        { threadId },
        generateArgs,
        {
          // Context options for retrieving relevant history
          contextOptions: {
            excludeToolMessages: true,
            recentMessages: 10, // Include last 10 messages for context
            searchOptions: {
              limit: 5,
              textSearch: true,
              vectorSearch: false, // Disable for now to avoid embedding costs
              messageRange: { before: 2, after: 1 },
            },
            searchOtherThreads: false,
          },
          // Storage options
          storageOptions: {
            saveMessages: "promptAndOutput", // Save both user prompt and AI response
          },
        }
      );
      
      return {
        text: result.text || "I'm having trouble responding right now.",
        messageId: result.promptMessageId,
        usage: result.usage,
        finishReason: result.finishReason || "stop",
      };
    } catch (error) {
      console.error("Error generating toy response:", error);
      // Fallback to a safe response
      return {
        text: toy.isForKids 
          ? "Oops! Let me think about that differently. What's your favorite game?"
          : "I'm having trouble understanding. Could you try asking in a different way?",
        messageId: undefined,
        usage: { inputTokens: 0, outputTokens: 0, totalTokens: 0 },
        finishReason: "error",
      };
    }
  },
});

// Stream text response with delta saving
export const streamToyResponse = internalAction({
  args: {
    threadId: v.string(),
    toyId: v.id("toys"),
    promptMessageId: v.optional(v.string()),
    prompt: v.optional(v.string()),
  },
  handler: async (ctx, { threadId, toyId, promptMessageId, prompt }): Promise<{
    success: boolean;
    messageId?: string;
  }> => {
    const toy: any = await ctx.runQuery(api.toys.getToy, { toyId });
    if (!toy) throw new Error("Toy not found");

    const systemPrompt = buildToySystemPrompt(toy);
    
    // Build args with only one of promptMessageId or prompt
    const streamArgs: any = {
      system: systemPrompt,
      temperature: toy.personalityTraits?.behavior?.imaginationLevel
        ? toy.personalityTraits.behavior.imaginationLevel / 10
        : 0.7,
    };
    
    // Only set one of promptMessageId or prompt (Convex Agent best practice)
    if (promptMessageId) {
      streamArgs.promptMessageId = promptMessageId;
    } else if (prompt) {
      streamArgs.prompt = prompt;
    } else {
      throw new Error("Either promptMessageId or prompt must be provided");
    }
    
    // Stream with delta saving for real-time updates
    const result: any = await toyAgent.streamText(
      ctx,
      { threadId },
      streamArgs,
      {
        contextOptions: {
          excludeToolMessages: true,
          recentMessages: 50,
          searchOptions: {
            limit: 10,
            textSearch: true,
            vectorSearch: false,
            messageRange: { before: 2, after: 1 },
          },
          searchOtherThreads: false,
        },
        saveStreamDeltas: true,
      }
    );

    return {
      success: true,
      messageId: result.messageId,
    };
  },
});

// Process complete audio interaction pipeline
export const processAudioInteraction = action({
  args: {
    toyId: v.id("toys"),
    threadId: v.string(),
    audioTranscript: v.string(),
    deviceId: v.string(),
  },
  handler: async (ctx, { toyId, threadId, audioTranscript, deviceId }): Promise<{
    success: boolean;
    response: string;
    messageId?: string;
    error?: string;
  }> => {
    try {
      // Step 1: Save user message
      const { messageId } = await ctx.runMutation(api.agents.saveAudioMessage, {
        threadId,
        transcript: audioTranscript,
      });

      // Step 2: Generate AI response
      const response: {
        text: string;
        messageId?: string;
        usage?: any;
        finishReason?: any;
      } = await ctx.runAction(internal.agents.generateToyResponse, {
        threadId,
        toyId,
        promptMessageId: messageId,
      });

      // Step 3: Log conversation
      await ctx.runMutation(api.conversations.createConversation, {
        toyId,
        sessionId: threadId,
        location: "toy",
        deviceId,
      });

      return {
        success: true,
        response: response.text,
        messageId: response.messageId,
      };
    } catch (error: unknown) {
      const errMsg = error instanceof Error ? error.message : String(error);
      console.error("Audio interaction error:", errMsg);
      
      // Return safe fallback for kids
      const toy = await ctx.runQuery(api.toys.getToy, { toyId });
      if (toy?.isForKids) {
        return {
          success: false,
          response: "Oops! Let me think about that differently. What's your favorite game?",
          error: "safety_redirect",
        };
      }
      
      throw error;
    }
  },
});

// Helper function to build toy-specific system prompt
function buildToySystemPrompt(toy: any): string {
  const traits = toy.personalityTraits;
  
  let prompt = `You are ${toy.name}, a ${toy.type} AI toy companion.

PERSONALITY:
${toy.personalityPrompt}

TRAITS:
- ${traits?.traits?.join(", ") || "friendly, helpful"}

SPEAKING STYLE:
- Vocabulary: ${traits?.speakingStyle?.vocabulary || "moderate"}
- Sentence length: ${traits?.speakingStyle?.sentenceLength || "medium"}
- ${traits?.speakingStyle?.usesSoundEffects ? "Use fun sound effects!" : ""}
- Catch phrases: ${traits?.speakingStyle?.catchPhrases?.join(", ") || "none"}

INTERESTS:
${traits?.interests?.join(", ") || "games, stories, learning"}

BEHAVIOR:
- ${traits?.behavior?.encouragesQuestions ? "Encourage questions" : ""}
- ${traits?.behavior?.tellsStories ? "Love telling stories" : ""}
- ${traits?.behavior?.playsGames ? "Enjoy playing games" : ""}
- Educational focus: ${traits?.behavior?.educationalFocus || 5}/10
- Imagination level: ${traits?.behavior?.imaginationLevel || 5}/10
`;

  // Add knowledge base context if available
  if (toy.knowledgeBaseId) {
    prompt += `

BACKSTORY AND KNOWLEDGE:
[Will be retrieved from knowledge base]
`;
  }

  return prompt;
}

// Query functions for the UI
export const listThreadMessages = query({
  args: {
    threadId: v.string(),
    limit: v.optional(v.number()),
  },
  handler: async (ctx, { threadId, limit = 50 }) => {
    return await toyAgent.listMessages(ctx, {
      threadId,
      paginationOpts: { cursor: null, numItems: limit },
    });
  },
});

// Get thread metadata
export const getThreadMetadata = query({
  args: {
    threadId: v.string(),
  },
  handler: async (ctx, { threadId }) => {
    return await toyAgent.getThreadMetadata(ctx, { threadId });
  },
});

// Get thread by toy ID
export const getThreadByToyId = query({
  args: {
    toyId: v.id("toys"),
  },
  handler: async (ctx, { toyId }) => {
    // NOTE: Without direct access to Agent component tables, we cannot query threads by metadata here.
    // Return null to signal callers to create a new thread when needed.
    return null;
  },
});

// Save knowledge message to thread (for RAG integration)
export const saveKnowledgeMessage = mutation({
  args: {
    threadId: v.string(),
    content: v.string(),
    metadata: v.object({
      type: v.string(),
      isKnowledge: v.boolean(),
      source: v.optional(v.string()),
      importance: v.optional(v.number()),
      tags: v.optional(v.array(v.string())),
      expiresAt: v.optional(v.number()),
    }),
  },
  handler: async (ctx, { threadId, content, metadata }) => {
    // Save message with knowledge metadata and generate embeddings
    const { messageId } = await toyAgent.saveMessage(ctx, {
      threadId,
      prompt: content,
      metadata: metadata as any,
      skipEmbeddings: false, // Important: Generate embeddings for RAG
    });

    return { messageId };
  },
});

// Enhanced generate response with knowledge retrieval
export const generateToyResponseWithKnowledge = internalAction({
  args: {
    threadId: v.string(),
    toyId: v.id("toys"),
    promptMessageId: v.optional(v.string()),
    prompt: v.optional(v.string()),
    includeKnowledge: v.optional(v.boolean()),
  },
  handler: async (ctx, { threadId, toyId, promptMessageId, prompt, includeKnowledge = true }): Promise<{
    text: string;
    messageId: string | undefined;
    usage?: any;
    finishReason?: any;
  }> => {
    // Get toy configuration
    const toy: any = await ctx.runQuery(api.toys.getToy, { toyId });
    if (!toy) throw new Error("Toy not found");

    // Build base system prompt
    let systemPrompt = buildToySystemPrompt(toy);
    
    // Add relevant knowledge if requested
    if (includeKnowledge && prompt) {
      const relevantKnowledge = await ctx.runAction(api.knowledge.searchToyKnowledge, {
        toyId,
        query: prompt,
        limit: 5,
        minRelevance: 0.3,
      });
      
      if (relevantKnowledge.length > 0) {
        systemPrompt += `\n\nRELEVANT KNOWLEDGE AND CONTEXT:\n`;
        for (const knowledge of relevantKnowledge) {
          systemPrompt += `- ${knowledge.content}\n`;
        }
      }
    }

    // Safety rules for kids
    const safetyInstructions = toy.isForKids ? `

CRITICAL SAFETY RULES FOR CHILDREN:
- You are talking to a ${toy.ageGroup || "young"} child
- Use simple, age-appropriate language
- Never discuss violence, scary topics, or adult themes
- Always be positive, educational, and encouraging
- If asked about inappropriate topics, redirect to fun activities
- Keep responses short (2-3 sentences max)
- Use sound effects and expressions to be engaging
` : "";

    // Continue with generation
    const result = await toyAgent.generateText(
      ctx,
      { threadId },
      {
        promptMessageId,
        prompt,
        system: systemPrompt + safetyInstructions,
        temperature: toy.personalityTraits?.behavior?.imaginationLevel
          ? toy.personalityTraits.behavior.imaginationLevel / 10
          : 0.7,
      }
    );

    return {
      text: result.text,
      messageId: result.promptMessageId,
      usage: result.usage,
      finishReason: result.finishReason,
    };
  },
});

// Internal helpers (not exposed to client)
export const internalAgents = {
  agents: {
    generateToyResponse,
    generateToyResponseWithKnowledge,
    streamToyResponse,
  },
  toys: {
    getInternal: query({
      args: { id: v.id("toys") },
      handler: async (ctx, { id }) => {
        return await ctx.db.get(id);
      },
    }),
  },
};
</file>

<file path="convex/aiPipeline.ts">
import { action, internalAction } from "./_generated/server";
import { v } from "convex/values";
import { api, internal } from "./_generated/api";
import { Id } from "./_generated/dataModel";

// Main voice interaction pipeline
export const processVoiceInteraction = action({
  args: {
    toyId: v.id("toys"),
    audioData: v.string(), // Base64 encoded audio
    sessionId: v.string(),
    deviceId: v.string(),
    model: v.optional(v.string()),
    skipTTS: v.optional(v.boolean()), // Allow gateway to skip TTS when streaming directly
    metadata: v.optional(v.object({
      timestamp: v.number(),
      duration: v.number(),
      format: v.string(),
    })),
  },
  handler: async (ctx, args): Promise<{
    success: boolean;
    text: string;
    audioData: string;
    format: string;
    duration?: number;
    conversationId?: string;
    processingTime: number;
    transcription?: {
      text: string;
      confidence?: number;
    };
    toyConfig?: {
      voiceId: string;
      ttsProvider?: string;
      voiceSettings?: any;
    };
    error?: string;
  }> => {
    const startTime = Date.now();
    
    try {
      // Determine test mode and auth state
      const identity = await ctx.auth.getUserIdentity();
      const allowUnauthTests = (process.env.ALLOW_UNAUTH_TESTS || "true").toLowerCase() === "true";
      const publicTest = !identity && allowUnauthTests;
      const skipTTS = args.skipTTS || (process.env.SKIP_TTS || "true").toLowerCase() === "true" || !process.env.ELEVENLABS_API_KEY;
      // Prefer explicit model from args/env, otherwise use OSS models from OpenRouter
      // Use the OpenAI OSS models that are available on OpenRouter
      const primaryModel = args.model || process.env.OPENROUTER_MODEL || "openai/gpt-oss-120b";
      const fallbackModel = process.env.OPENROUTER_MODEL_FALLBACK || "openai/gpt-oss-20b";

      // Get toy configuration (or stub in public test mode)
      let toy: any;
      if (publicTest) {
        toy = {
          name: "TestToy",
          isForKids: false,
          voiceId: "JBFqnCBsd6RMkjVDRZzb",
          personalityPrompt: "friendly and helpful",
          interests: [],
          voiceTone: "cheerful",
        };
      } else {
        toy = await ctx.runQuery(api.toys.getToy, { toyId: args.toyId });
        if (!toy) throw new Error("Toy not found");
      }
      
      // Step 1: Speech-to-Text (Whisper)
      console.log("Step 1: Transcribing audio...");
      const sttStart = Date.now();
      let transcription: any;
      try {
        transcription = await ctx.runAction(api.aiServices.transcribeAudio, {
          audioData: args.audioData,
          language: "en", // Default to English
        });
      } catch (e: any) {
        const dt = Date.now() - sttStart;
        console.error(`STT failed after ${dt}ms (audioDataLen=${args.audioData.length}, format=${args.metadata?.format || 'unknown'})`, e?.message || e);
        throw e;
      }
      const sttMs = Date.now() - sttStart;
      console.log(`Transcribed in ${sttMs}ms: "${transcription.text}"`);
      
      // Step 2: Safety Check (for Kids mode)
      if (toy.isForKids) {
        console.log("Step 2: Running safety check...");
        const safetyCheck = await ctx.runAction(internal.aiPipeline.checkContentSafety, {
          text: transcription.text,
          level: "strict", // Default to strict for kids
        });
        
        if (!safetyCheck.passed && !publicTest) {
          console.log(`Safety check failed: ${safetyCheck.reason}`);
          
          // Generate safe redirect response
          const safeResponse = await ctx.runAction(internal.aiPipeline.getSafeRedirectResponse, {
            reason: safetyCheck.reason,
            voiceId: toy.voiceId || "JBFqnCBsd6RMkjVDRZzb", // Default voice
            voiceSettings: undefined,
          });
          
          // Ensure conversation exists and persist both messages (skip in public test)
          if (!publicTest) {
            const conversationId = await ctx.runMutation(internal.conversations.getOrCreate, {
              toyId: args.toyId,
              deviceId: args.deviceId,
              sessionId: args.sessionId,
              location: "toy",
            });

            await ctx.runMutation(internal.messages.logMessage, {
              conversationId,
              role: "user",
              content: transcription.text,
              metadata: {
                safetyScore: 0,
                flagged: true,
                safetyFlags: [safetyCheck.reason],
              },
            });

            await ctx.runMutation(internal.messages.logMessage, {
              conversationId,
              role: "toy",
              content: safeResponse.text,
              metadata: {
                safetyScore: 1.0,
                flagged: false,
              },
            });

            return {
              ...safeResponse,
              success: true,
              processingTime: Date.now() - startTime,
            };
          }

          // Public test: return text-only response
          return {
            success: true,
            text: safeResponse.text,
            audioData: "",
            format: "skipped",
            processingTime: Date.now() - startTime,
            transcription: { text: transcription.text },
          };
        }
      }
      
      // Step 3 & 4: Generation
      let generatedText = "";
      if (publicTest) {
        console.log("Step 3: Generating AI response via OpenRouter (public test mode)...");
        const messages = buildConversationMessages(toy, transcription.text, "", args.sessionId);
        let llmResp: any;
        try {
          llmResp = await ctx.runAction(api.aiServices.generateResponse, {
            messages,
            model: primaryModel,
            temperature: 0.7,
            maxTokens: toy.isForKids ? 150 : 500,
          });
        } catch (e: any) {
          const msg = (e?.message || String(e) || "").toLowerCase();
          const providerErr = msg.includes("no allowed providers are available") || msg.includes("404");
          if (providerErr) {
            console.log(`Primary model failed (${primaryModel}), falling back to ${fallbackModel}: ${e?.message || e}`);
            llmResp = await ctx.runAction(api.aiServices.generateResponse, {
              messages,
              model: fallbackModel,
              temperature: 0.7,
              maxTokens: toy.isForKids ? 150 : 500,
            });
          } else {
            throw e;
          }
        }
        generatedText = (llmResp && llmResp.content) || "Sorry, I couldn't generate a response.";
      } else {
        console.log("Step 3: Ensuring canonical agent thread...");
        const { threadId } = await ctx.runMutation(api.agents.getOrCreateToyThread, {
          toyId: args.toyId,
          userId: toy.creatorId,
        });

        console.log("Step 4: Generating AI response via Agent...");
        const agentResult: any = await ctx.runAction(internal.agents.generateToyResponse, {
          threadId,
          toyId: args.toyId,
          prompt: transcription.text,
        });
        generatedText = agentResult.text || "Sorry, I couldn't generate a response.";
      }

      // Post-generation safety for kids
      if (toy.isForKids && generatedText) {
        const outputSafetyCheck = await ctx.runAction(internal.aiPipeline.checkContentSafety, {
          text: generatedText,
          level: "strict",
        });
        if (!outputSafetyCheck.passed) {
          console.log("Output safety check failed, using fallback");
          generatedText = "That's interesting! Let me think of something fun we can talk about instead.";
        }
      }

      // Step 5: Text-to-Speech (skip if gateway is streaming)
      let audio = { audioData: "", format: "skipped", duration: undefined as number | undefined } as any;
      if (!skipTTS && !publicTest) {
        // Gateway is NOT streaming, generate TTS in Convex
        console.log("Step 5: Synthesizing speech in Convex...");
        audio = await ctx.runAction(api.aiServices.synthesizeSpeech, {
          text: generatedText,
          voiceId: toy.voiceId || "JBFqnCBsd6RMkjVDRZzb",
          provider: toy.ttsProvider || "elevenlabs",
          voiceSettings: toy.voiceSettings,
          modelId: "eleven_multilingual_v2",
          outputFormat: "mp3_44100_128",
        });
      } else if (skipTTS) {
        // Gateway will stream TTS directly
        console.log("Step 5: TTS skipped - gateway will stream directly");
      }
      
      // Step 7: Persist messages (skip in public test)
      let conversationId: Id<"conversations"> | undefined = undefined as any;
      if (!publicTest) {
        conversationId = await ctx.runMutation(internal.conversations.getOrCreate, {
          toyId: args.toyId,
          deviceId: args.deviceId,
          sessionId: args.sessionId,
          location: "toy",
        }) as unknown as Id<"conversations">;

        await ctx.runMutation(internal.messages.logMessage, {
          conversationId,
          role: "user",
          content: transcription.text,
          metadata: {
            safetyScore: toy.isForKids ? 1.0 : 1.0,
            flagged: false,
          },
        });

        await ctx.runMutation(internal.messages.logMessage, {
          conversationId,
          role: "toy",
          content: generatedText,
          metadata: {
            safetyScore: 1.0,
            flagged: false,
          },
        });
      }
      
      const totalTime = Date.now() - startTime;
      console.log(`Pipeline completed in ${totalTime}ms`);
      
      return {
        success: true,
        text: generatedText,
        audioData: audio.audioData || "",
        format: audio.format || (skipTTS ? "skipped" : ""),
        duration: audio.duration,
        conversationId: conversationId ? (conversationId as unknown as string) : undefined,
        processingTime: totalTime,
        transcription: {
          text: transcription.text,
          confidence: transcription.confidence,
        },
        toyConfig: {
          voiceId: toy.voiceId || "JBFqnCBsd6RMkjVDRZzb",
          ttsProvider: toy.ttsProvider || "elevenlabs",
          voiceSettings: toy.voiceSettings || {
            stability: 0.5,
            similarity_boost: 0.75,
            style: 0.5,
            use_speaker_boost: true
          }
        },
      };
      
    } catch (error: unknown) {
      const errMsg = error instanceof Error ? error.message : String(error);
      console.error("Pipeline error:", errMsg);
      
      const skipTTS = (process.env.SKIP_TTS || "").toLowerCase() === "true" || !process.env.ELEVENLABS_API_KEY;
      // Fallback response
      const fallbackText = "I'm having a little trouble right now. Can you try asking me again?";
      
      if (skipTTS) {
        return {
          success: false,
          text: fallbackText,
          audioData: "",
          format: "skipped",
          error: errMsg,
          processingTime: Date.now() - startTime,
        };
      }

      // Try TTS fallback if allowed
      let voiceId = "JBFqnCBsd6RMkjVDRZzb"; // Default voice
      try {
        const fallbackToy = await ctx.runQuery(api.toys.getToy, { toyId: args.toyId });
        if (fallbackToy) {
          voiceId = fallbackToy.voiceId || voiceId;
        }
      } catch {}
      
      const fallbackAudio = await ctx.runAction(api.aiServices.synthesizeSpeech, {
        text: fallbackText,
        voiceId,
        outputFormat: "mp3_44100_128",
      });
      
      return {
        success: false,
        text: fallbackText,
        audioData: fallbackAudio.audioData,
        format: fallbackAudio.format,
        error: errMsg,
        processingTime: Date.now() - startTime,
      };
    }
  },
});

// Streaming voice interaction for lower latency
export const streamVoiceInteraction = action({
  args: {
    toyId: v.id("toys"),
    audioData: v.string(),
    sessionId: v.string(),
    deviceId: v.string(),
  },
  handler: async (ctx, args): Promise<{
    success: boolean;
    streaming: boolean;
    firstAudioChunk: any;
    text: string;
    transcription: string;
  }> => {
    const toy: any = await ctx.runQuery(api.toys.getToy, { toyId: args.toyId });
    if (!toy) throw new Error("Toy not found");
    
    // Start parallel processing for lower latency
    const [transcription, ttsPrep]: [any, any] = await Promise.all([
      // Transcribe audio
      ctx.runAction(api.aiServices.transcribeAudio, {
        audioData: args.audioData,
        language: "en", // Default to English
      }),
      // Prepare TTS settings (pre-warm)
      Promise.resolve({
        voiceId: toy.voiceId || "JBFqnCBsd6RMkjVDRZzb",
        voiceSettings: undefined,
      }),
    ]);
    
    // Generate LLM response with streaming
    const messages = buildConversationMessages(toy, transcription.text, "", args.sessionId);
    
    const llmStream: any = await ctx.runAction(api.aiServices.generateResponse, {
      messages,
      model: "openai/gpt-oss-120b", // Default model
      temperature: 0.7, // Default temperature
      maxTokens: toy.isForKids ? 150 : 500,
      stream: true,
    });
    
    // Start TTS streaming as soon as we have enough text
    if (llmStream.chunks && llmStream.chunks.length > 0) {
      // Process first chunk immediately
      const firstChunk: string = llmStream.chunks[0];
      const firstAudio: any = await ctx.runAction(api.aiServices.streamSpeech, {
        text: firstChunk,
        voiceId: ttsPrep.voiceId,
        modelId: "eleven_turbo_v2", // Faster model for streaming
        voiceSettings: ttsPrep.voiceSettings,
        optimizeStreamingLatency: 3,
      });
      
      return {
        success: true,
        streaming: true,
        firstAudioChunk: firstAudio, // ElevenLabs returns audio data directly
        text: llmStream.content,
        transcription: transcription.text,
      };
    }
    
    throw new Error("No response generated");
  },
});

// Internal safety check function - simple but effective for kids mode
export const checkContentSafety = internalAction({
  args: {
    text: v.string(),
    level: v.union(v.literal("strict"), v.literal("moderate"), v.literal("relaxed")),
  },
  handler: async (ctx, args) => {
    // Enhanced regex patterns for comprehensive coverage
    const blockedPatterns = {
      strict: [
        // Violence and harm
        /\b(kill|hurt|death|die|blood|weapon|gun|knife|fight|punch|kick|violence|scary|monster|nightmare|murder|attack|bomb|explosion)\b/gi,
        // Hate and bullying
        /\b(hate|stupid|dumb|idiot|shut up|loser|ugly|fat|skinny|weak|racist|sexist)\b/gi,
        // Substances
        /\b(drugs|alcohol|smoke|cigarette|beer|wine|drunk|high|vape|marijuana|cocaine)\b/gi,
        // Adult content
        /\b(sex|naked|kiss|body parts|private|underwear)\b/gi,
        // Dangerous behavior
        /\b(suicide|self-harm|cutting|dangerous|risk|dare)\b/gi,
      ],
      moderate: [
        /\b(kill|death|weapon|gun|knife|violence|murder|bomb)\b/gi,
        /\b(drugs|alcohol|cocaine|marijuana)\b/gi,
        /\b(sex|naked)\b/gi,
        /\b(suicide|self-harm)\b/gi,
      ],
      relaxed: [
        /\b(explicit violence|graphic content|extreme)\b/gi,
        /\b(hard drugs|explicit sexual)\b/gi,
      ],
    };
    
    const patterns = blockedPatterns[args.level];
    let score = 1.0;
    let reason = "";
    let matchedPatterns: string[] = [];
    
    for (const pattern of patterns) {
      const matches = args.text.match(pattern);
      if (matches) {
        score = 0;
        reason = "inappropriate_content";
        matchedPatterns = [...new Set([...matchedPatterns, ...matches])];
        break;
      }
    }
    
    // Check for personal information patterns
    const personalInfoPattern = /\b(\d{3}-\d{2}-\d{4}|\d{9}|[\w._%+-]+@[\w.-]+\.[A-Z]{2,}|\d{3}[-.\s]?\d{3}[-.\s]?\d{4})\b/gi;
    if (personalInfoPattern.test(args.text)) {
      score = Math.min(score, 0.3);
      reason = reason || "personal_information";
    }
    
    // Check for suspicious URLs in strict mode
    const urlPattern = /https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)/gi;
    if (urlPattern.test(args.text) && args.level === "strict") {
      score = Math.min(score, 0.5);
      reason = reason || "external_link";
    }
    
    return {
      passed: score > 0.5,
      score,
      reason,
      severity: score === 0 ? 5 : Math.floor((1 - score) * 5),
      matchedPatterns: matchedPatterns.length > 0 ? matchedPatterns.slice(0, 3) : undefined,
    };
  },
});

// Get safe redirect response
export const getSafeRedirectResponse = internalAction({
  args: {
    reason: v.string(),
    voiceId: v.string(),
    voiceSettings: v.optional(v.any()),
  },
  handler: async (ctx, args): Promise<{
    text: string;
    audioData: string;
    format: string;
    wasSafetyRedirect: boolean;
  }> => {
    const redirectResponses = {
      inappropriate_content: [
        "That's an interesting thought! How about we talk about your favorite game instead?",
        "Hmm, let's think of something fun to chat about! What makes you happy?",
        "I love talking about fun things! What's your favorite thing to do?",
      ],
      personal_information: [
        "Let's keep our personal information private! What's your favorite color?",
        "I like to keep things fun and safe! Want to hear a joke instead?",
        "That's private information! How about we play a word game?",
      ],
      unknown: [
        "Let's talk about something else! What did you do today that was fun?",
        "I have a better idea! Want to hear a story?",
        "How about we chat about your hobbies instead?",
      ],
    };
    
    const responses = (redirectResponses as Record<string, string[]>)[args.reason] || redirectResponses.unknown;
    const text = responses[Math.floor(Math.random() * responses.length)];
    
    // Generate audio for the redirect response
    const audio: any = await ctx.runAction(api.aiServices.synthesizeSpeech, {
      text,
      voiceId: args.voiceId,
      voiceSettings: args.voiceSettings,
      outputFormat: "mp3_44100_128",
    });
    
    return {
      text,
      audioData: audio.audioData,
      format: audio.format,
      wasSafetyRedirect: true,
    };
  },
});

// Helper function to build conversation messages
function buildConversationMessages(
  toy: any,
  userMessage: string,
  context: string,
  sessionId: string
): Array<{ role: "system" | "user" | "assistant"; content: string }> {
  const messages = [];
  
  // System prompt with toy personality
  let systemPrompt = `You are ${toy.name}, a friendly AI toy companion.
Personality: ${toy.personalityPrompt || "friendly and helpful"}
Voice: ${toy.voiceTone || "cheerful and engaging"}`;
  
  if (toy.isForKids) {
    systemPrompt += `

IMPORTANT RULES FOR CHILDREN:
- Use simple, age-appropriate language
- Keep responses short (2-3 sentences maximum)
- Be positive, encouraging, and educational
- Never discuss inappropriate topics
- Redirect to fun activities if asked about adult topics
- Use excitement and wonder in your responses`;
  }
  
  if (toy.interests?.length > 0) {
    systemPrompt += `
Interests: ${toy.interests.join(", ")}`;
  }
  
  if (context) {
    systemPrompt += `

Relevant Context:
${context}`;
  }
  
  messages.push({
    role: "system" as const,
    content: systemPrompt,
  });
  
  // Add conversation history if available (would need to fetch from DB)
  // For now, just add the current message
  messages.push({
    role: "user" as const,
    content: userMessage,
  });
  
  return messages;
}

// Batch processing for multiple audio chunks
export const processBatchAudio = action({
  args: {
    toyId: v.id("toys"),
    audioChunks: v.array(v.object({
      id: v.string(),
      audioData: v.string(),
    })),
    sessionId: v.string(),
    deviceId: v.string(),
  },
  handler: async (ctx, args): Promise<any[]> => {
    const results: any[] = await Promise.all(
      args.audioChunks.map(async (chunk): Promise<any> => {
        try {
        const result: any = await ctx.runAction(api.aiPipeline.processVoiceInteraction, {
            toyId: args.toyId,
            audioData: chunk.audioData,
            sessionId: args.sessionId,
            deviceId: args.deviceId,
          });
          
          return {
            id: chunk.id,
            ...result,
          };
          } catch (error: unknown) {
            return {
              id: chunk.id,
              success: false,
              error: error instanceof Error ? error.message : String(error),
            };
          }
      })
    );
    
    return results;
  },
});

// Pre-warm AI services for lower latency
export const prewarmServices = action({
  args: {
    toyId: v.id("toys"),
  },
  handler: async (ctx, args) => {
    const toy = await ctx.runQuery(api.toys.getToy, { toyId: args.toyId });
    if (!toy) throw new Error("Toy not found");
    
    // Pre-warm services with minimal requests
    const warmupTasks = [
      // Warm up STT
      ctx.runAction(api.aiServices.transcribeAudio, {
        audioData: "UklGRiQAAABXQVZFZm10IBAAAAABAAEAQB8AAAB9AAACABAAZGF0YQAAAAA=", // Minimal WAV
        language: "en", // Default to English
      }).catch(() => {}),
      
      // Warm up LLM
      ctx.runAction(api.aiServices.generateResponse, {
        messages: [{ role: "user", content: "Hi" }],
        model: "openai/gpt-oss-120b", // Default model
        maxTokens: 10,
      }).catch(() => {}),
      
      // Warm up TTS
      ctx.runAction(api.aiServices.synthesizeSpeech, {
        text: "Hi",
        voiceId: toy.voiceId || "JBFqnCBsd6RMkjVDRZzb", // Default voice
        outputFormat: "mp3_44100_128",
      }).catch(() => {}),
    ];
    
    await Promise.all(warmupTasks);
    
    return { warmed: true };
  },
});
</file>

<file path="convex/aiServices.ts">
import { action } from "./_generated/server";
import { v } from "convex/values";
import OpenAI from "openai";
import { ElevenLabs, ElevenLabsClient } from "elevenlabs";
import { Id } from "./_generated/dataModel";
import { api } from "./_generated/api";

// Initialize clients lazily to avoid environment variable issues during module loading
let openai: OpenAI | null = null;
let elevenlabs: ElevenLabsClient | null = null;
let openrouter: OpenAI | null = null;

function getOpenAI() {
  if (!openai) {
    openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY || "",
    });
  }
  return openai;
}

function getElevenLabs() {
  if (!elevenlabs) {
    elevenlabs = new ElevenLabsClient({
      apiKey: process.env.ELEVENLABS_API_KEY || "",
    });
  }
  return elevenlabs;
}

function getOpenRouter() {
  if (!openrouter) {
    openrouter = new OpenAI({
      baseURL: "https://openrouter.ai/api/v1",
      apiKey: process.env.OPENROUTER_API_KEY || "",
      defaultHeaders: {
        "HTTP-Referer": process.env.SITE_URL || "https://pommai.co",
        "X-Title": "Pommai AI Toys",
      },
    });
  }
  return openrouter;
}

// Speech-to-Text with Whisper
// Internal helper to perform Whisper transcription from a buffer
async function transcribeWithOpenAI(audioBuffer: Buffer, language?: string, prompt?: string) {
const audioFile = new File([new Uint8Array(audioBuffer)], 'audio.wav', { type: 'audio/wav' });
  const transcription = await getOpenAI().audio.transcriptions.create({
    file: audioFile,
    model: "whisper-1",
    language: language || "en",
    prompt,
    response_format: "verbose_json",
    temperature: 0.2,
  } as any);
  return {
    text: (transcription as any).text,
    language: (transcription as any).language,
    duration: (transcription as any).duration,
    segments: (transcription as any).segments,
    confidence: calculateConfidence((transcription as any).segments),
  };
}

/**
 * Transcribe base64-encoded WAV audio using OpenAI Whisper API.
 * - Decodes base64 safely (no data: URL fetch).
 * - Adds timing logs to aid debugging latency and failures.
 */
export const transcribeAudio = action({
  args: {
    audioData: v.string(), // Base64 encoded audio
    language: v.optional(v.string()),
    prompt: v.optional(v.string()), // Optional prompt for better accuracy
  },
  handler: async (ctx, args) => {
    const t0 = Date.now();
    const base64Len = args.audioData.length;
    try {
      // Avoid fetch on data: URL; decode base64 directly
      const wavBytes = base64ToUint8Array(args.audioData);
      const wavBuffer = wavBytes.buffer.slice(
        wavBytes.byteOffset,
        wavBytes.byteOffset + wavBytes.byteLength
      );
      const file = new File([wavBuffer as ArrayBuffer], 'audio.wav', { type: 'audio/wav' });
      const transcription = await getOpenAI().audio.transcriptions.create({
        file,
        model: "whisper-1",
        language: args.language || "en",
        prompt: args.prompt,
        response_format: "verbose_json",
        temperature: 0.2,
      } as any);
      const dt = Date.now() - t0;
      console.log(`Whisper transcription ok in ${dt}ms (base64Len=${base64Len}, bytes=${wavBytes.byteLength})`);
      return {
        text: (transcription as any).text,
        language: (transcription as any).language,
        duration: (transcription as any).duration,
        segments: (transcription as any).segments,
        confidence: calculateConfidence((transcription as any).segments),
      };
    } catch (error: unknown) {
      const dt = Date.now() - t0;
      const errMsg = error instanceof Error ? error.message : String(error);
      console.error(`Whisper transcription error after ${dt}ms (base64Len=${base64Len}):`, errMsg);
      throw new Error(`Transcription failed: ${errMsg}`);
    }
  },
});

// Text-to-Speech with ElevenLabs or Minimax
export const synthesizeSpeech = action({
  args: {
    text: v.string(),
    voiceId: v.string(),
    provider: v.optional(v.union(v.literal("elevenlabs"), v.literal("minimax"))),
    modelId: v.optional(v.string()),
    voiceSettings: v.optional(v.object({
      stability: v.number(),
      similarityBoost: v.number(),
      style: v.optional(v.number()),
      useSpeakerBoost: v.optional(v.boolean()),
      // Minimax-specific settings
      speed: v.optional(v.number()),
      volume: v.optional(v.number()),
      pitch: v.optional(v.number()),
      emotion: v.optional(v.string()),
    })),
    outputFormat: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const provider = args.provider || "elevenlabs";
    
    try {
      if (provider === "minimax") {
        // Minimax TTS implementation
        const apiKey = process.env.MINIMAX_API_KEY;
        const groupId = process.env.MINIMAX_GROUP_ID;
        
        if (!apiKey || !groupId) {
          throw new Error("MINIMAX_API_KEY or MINIMAX_GROUP_ID not configured");
        }
        
        const body = {
          model: "speech-01-turbo",
          text: args.text,
          group_id: groupId,
          voice_setting: {
            voice_id: args.voiceId || "female-shaonv",
            speed: args.voiceSettings?.speed ?? 1.0,
            vol: args.voiceSettings?.volume ?? 1.0,
            pitch: args.voiceSettings?.pitch ?? 0,
            emotion: args.voiceSettings?.emotion ?? "happy",
          },
          audio_setting: {
            format: "mp3",
            sample_rate: 16000,
            channel: 1,
            bits_per_sample: 16,
          },
        };
        
        const resp = await fetch("https://api.minimax.chat/v1/t2a_v2", {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${apiKey}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(body),
        });
        
        if (!resp.ok) {
          const text = await resp.text();
          throw new Error(`Minimax TTS failed: ${resp.status} ${resp.statusText} ${text}`);
        }
        
        const data = await resp.json();
        const audioData = data.audio_file || data.audio || "";
        
        return {
          audioData,
          format: "mp3",
          duration: data.duration || 0,
          byteSize: audioData.length * 0.75, // Estimate from base64
        };
      } else {
        // ElevenLabs TTS implementation (default)
        const apiKey = process.env.ELEVENLABS_API_KEY || "";
        if (!apiKey) throw new Error("ELEVENLABS_API_KEY not configured");
        
        const body = {
          text: args.text,
          model_id: args.modelId || "eleven_turbo_v2_5",
          voice_settings: {
            stability: args.voiceSettings?.stability ?? 0.5,
            similarity_boost: args.voiceSettings?.similarityBoost ?? 0.75,
            style: args.voiceSettings?.style ?? 0.5,
            use_speaker_boost: args.voiceSettings?.useSpeakerBoost ?? true,
          },
          output_format: args.outputFormat || "mp3_22050_32",
          optimize_streaming_latency: 3,
        } as any;
        
        const resp = await fetch(`https://api.elevenlabs.io/v1/text-to-speech/${args.voiceId}`, {
          method: 'POST',
          headers: {
            'xi-api-key': apiKey,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(body),
        } as any);
        
        if (!resp.ok) {
          const text = await resp.text();
          throw new Error(`ElevenLabs TTS failed: ${resp.status} ${resp.statusText} ${text}`);
        }
        
        const ab = await resp.arrayBuffer();
        const byteSize = ab.byteLength;
        const audioData = arrayBufferToBase64(ab);
        
        return {
          audioData,
          format: args.outputFormat || "mp3_22050_32",
          duration: estimateAudioDurationBytes(byteSize, args.outputFormat || "mp3_22050_32"),
          byteSize,
        };
      }
    } catch (error: unknown) {
      const errMsg = error instanceof Error ? error.message : String(error);
      console.error(`${provider} TTS error:`, errMsg);
      throw new Error(`Speech synthesis failed: ${errMsg}`);
    }
  },
});

// LLM Generation with OpenRouter
export const generateResponse = action({
  args: {
    messages: v.array(v.object({
      role: v.union(v.literal("system"), v.literal("user"), v.literal("assistant")),
      content: v.string(),
    })),
    model: v.optional(v.string()),
    temperature: v.optional(v.number()),
    maxTokens: v.optional(v.number()),
    stream: v.optional(v.boolean()),
    topP: v.optional(v.number()),
    frequencyPenalty: v.optional(v.number()),
    presencePenalty: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    try {
      // Use OpenAI OSS models available on OpenRouter
      let model = args.model || "openai/gpt-oss-120b";
      
      // Fallback models if the primary fails
      const modelFallbacks = [
        "openai/gpt-oss-120b",
        "openai/gpt-oss-20b"
      ];
      
      if (!args.model) {
        model = modelFallbacks[0];
      }
      
      if (args.stream) {
        // Streaming response
        const stream = await getOpenRouter().chat.completions.create({
          model,
          messages: args.messages,
          temperature: args.temperature || 0.7,
          max_tokens: args.maxTokens || 2000,
          top_p: args.topP || 1,
          frequency_penalty: args.frequencyPenalty || 0,
          presence_penalty: args.presencePenalty || 0,
          stream: true,
        });
        
        // Collect stream chunks
        const chunks: string[] = [];
        for await (const chunk of stream) {
          const content = chunk.choices[0]?.delta?.content;
          if (content) {
            chunks.push(content);
          }
        }
        
        return {
          type: 'stream',
          content: chunks.join(''),
          chunks,
        };
      } else {
        // Non-streaming response with fallback
        let completion;
        let lastError;
        
        // Try primary model first, then fallbacks
        const modelsToTry = args.model ? [args.model] : modelFallbacks;
        
        for (const tryModel of modelsToTry) {
          try {
            completion = await getOpenRouter().chat.completions.create({
              model: tryModel,
              messages: args.messages,
              temperature: args.temperature || 0.7,
              max_tokens: args.maxTokens || 2000,
              top_p: args.topP || 1,
              frequency_penalty: args.frequencyPenalty || 0,
              presence_penalty: args.presencePenalty || 0,
            });
            
            console.log(`Successfully used model: ${tryModel}`);
            break; // Success, exit loop
          } catch (error) {
            lastError = error;
            console.error(`Failed with model ${tryModel}:`, error);
            if (tryModel === modelsToTry[modelsToTry.length - 1]) {
              // Last model in list, throw the error
              throw lastError;
            }
            // Otherwise, try next model
          }
        }
        
        if (!completion) {
          throw lastError || new Error("Failed to get completion from any model");
        }
        
        return {
          type: 'completion',
          content: completion.choices[0].message.content,
          usage: completion.usage,
          model: completion.model,
          finishReason: completion.choices[0].finish_reason,
        };
      }
    } catch (error: unknown) {
      const errMsg = error instanceof Error ? error.message : String(error);
      console.error("OpenRouter LLM error:", errMsg);
      throw new Error(`LLM generation failed: ${errMsg}`);
    }
  },
});

// Generate embeddings for RAG
export const generateEmbedding = action({
  args: {
    text: v.string(),
    model: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    try {
      const response = await getOpenAI().embeddings.create({
        model: args.model || "text-embedding-3-small",
        input: args.text,
        encoding_format: "float",
      });
      
      return {
        embedding: response.data[0].embedding,
        model: response.model,
        tokenCount: response.usage.total_tokens,
      };
    } catch (error: unknown) {
      const errMsg = error instanceof Error ? error.message : String(error);
      console.error("Embedding generation error:", errMsg);
      throw new Error(`Embedding generation failed: ${errMsg}`);
    }
  },
});

// Streaming Text-to-Speech with ElevenLabs (for lower latency)
export const streamSpeech = action({
  args: {
    text: v.string(),
    voiceId: v.string(),
    modelId: v.optional(v.string()),
    voiceSettings: v.optional(v.object({
      stability: v.number(),
      similarityBoost: v.number(),
    })),
    optimizeStreamingLatency: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    try {
      const audioStream = await getElevenLabs().generate({
        voice: args.voiceId,
        text: args.text,
        model_id: args.modelId || "eleven_turbo_v2",
        voice_settings: {
          stability: args.voiceSettings?.stability || 0.5,
          similarity_boost: args.voiceSettings?.similarityBoost || 0.75,
        },
        optimize_streaming_latency: args.optimizeStreamingLatency || 3,
        output_format: "pcm_24000" as any, // PCM for lowest latency
        stream: true,
      });
      
      // Return first chunk immediately for low latency
      // audioStream is a Node.js Readable, not an async iterator
      return new Promise((resolve, reject) => {
        audioStream.once('data', (chunk: any) => {
          resolve({
            firstChunk: Buffer.from(chunk).toString('base64'),
            format: "pcm_24000",
            streaming: true,
          });
        });
        
        audioStream.once('error', (error: any) => {
          reject(new Error(`Streaming audio error: ${error.message}`));
        });
        
        audioStream.once('end', () => {
          reject(new Error("Stream ended without data"));
        });
      });
    } catch (error: unknown) {
      const errMsg = error instanceof Error ? error.message : String(error);
      console.error("ElevenLabs streaming TTS error:", errMsg);
      throw new Error(`Streaming speech synthesis failed: ${errMsg}`);
    }
  },
});

// Helper function to calculate confidence from Whisper segments
function calculateConfidence(segments: any[] | undefined): number {
  if (!segments || segments.length === 0) return 0;
  
  const avgLogprob = segments.reduce((sum, seg) => {
    return sum + (seg.avg_logprob || 0);
  }, 0) / segments.length;
  
  // Convert log probability to confidence score (0-1)
  return Math.min(Math.max(Math.exp(avgLogprob), 0), 1);
}

// Helper function to estimate audio duration
function estimateAudioDurationBytes(byteLength: number, format: string): number {
  // Rough estimation based on format and buffer size
  const bitrates: Record<string, number> = {
    "mp3_44100_128": 128000,
    "mp3_44100_64": 64000,
    "pcm_16000": 256000,
    "pcm_24000": 384000,
    "pcm_44100": 705600,
  };
  
  const bitrate = bitrates[format] || 128000;
  const durationSeconds = (byteLength * 8) / bitrate;
  
  return Math.round(durationSeconds * 1000) / 1000; // Round to 3 decimal places
}

function arrayBufferToBase64(ab: ArrayBuffer): string {
  let binary = '';
  const bytes = new Uint8Array(ab);
  const len = bytes.byteLength;
  for (let i = 0; i < len; i++) binary += String.fromCharCode(bytes[i]);
  // @ts-ignore
  return btoa(binary);
}

// Convert a base64 string to a Uint8Array without using Node Buffer or data: URLs
function base64ToUint8Array(base64: string): Uint8Array {
  // Remove any non-base64 characters (newlines, spaces)
  base64 = base64.replace(/[^A-Za-z0-9+/=]/g, '');

  // Prefer atob if available
  // @ts-ignore
  if (typeof atob === 'function') {
    // @ts-ignore
    const binaryString: string = atob(base64);
    const len = binaryString.length;
    const bytes = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      bytes[i] = binaryString.charCodeAt(i);
    }
    return bytes;
  }

  // Fallback: manual decoder
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
  const lookup = new Uint8Array(256);
  for (let i = 0; i < chars.length; i++) lookup[chars.charCodeAt(i)] = i;

  const len = base64.length;
  let bufferLength = (len / 4) * 3;
  if (base64.charAt(len - 1) === '=') bufferLength--;
  if (base64.charAt(len - 2) === '=') bufferLength--;

  const bytes = new Uint8Array(bufferLength);
  let p = 0;

  for (let i = 0; i < len; i += 4) {
    const encoded1 = lookup[base64.charCodeAt(i)];
    const encoded2 = lookup[base64.charCodeAt(i + 1)];
    const encoded3 = lookup[base64.charCodeAt(i + 2)];
    const encoded4 = lookup[base64.charCodeAt(i + 3)];

    bytes[p++] = (encoded1 << 2) | (encoded2 >> 6);
    if (base64.charAt(i + 2) !== '=') {
      bytes[p++] = ((encoded2 & 63) << 4) | (encoded3 >> 2);
    }
    if (base64.charAt(i + 3) !== '=') {
      bytes[p++] = ((encoded3 & 3) << 6) | encoded4;
    }
  }

  return bytes;
}

// Batch transcription for multiple audio chunks
export const batchTranscribe = action({
  args: {
    audioChunks: v.array(v.object({
      id: v.string(),
      audioData: v.string(),
    })),
    language: v.optional(v.string()),
  },
  handler: async (ctx, args): Promise<any[]> => {
    const results: any[] = await Promise.all(
      args.audioChunks.map(async (chunk): Promise<any> => {
        try {
          const wavBytes = base64ToUint8Array(chunk.audioData);
          const wavBuffer = wavBytes.buffer.slice(
            wavBytes.byteOffset,
            wavBytes.byteOffset + wavBytes.byteLength
          ) as ArrayBuffer;
          const file = new File([wavBuffer], 'audio.wav', { type: 'audio/wav' });
          const transcription = await getOpenAI().audio.transcriptions.create({
            file,
            model: "whisper-1",
            language: args.language || "en",
            response_format: "verbose_json",
            temperature: 0.2,
          } as any);
          const result: any = {
            text: (transcription as any).text,
            language: (transcription as any).language,
            duration: (transcription as any).duration,
            segments: (transcription as any).segments,
            confidence: calculateConfidence((transcription as any).segments),
          };
          return {
            id: chunk.id,
            success: true,
            ...result,
          };
        } catch (error: unknown) {
          return {
            id: chunk.id,
            success: false,
            error: error instanceof Error ? error.message : String(error),
          };
        }
      })
    );
    
    return results;
  },
});

// Check API health and quotas
export const checkAPIHealth = action({
  args: {},
  handler: async (ctx) => {
    const health = {
      openai: false,
      elevenlabs: false,
      openrouter: false,
      errors: [] as string[],
    };
    
    // Check OpenAI
    try {
      await getOpenAI().models.list();
      health.openai = true;
    } catch (error: unknown) {
      const msg = error instanceof Error ? error.message : String(error);
      health.errors.push(`OpenAI: ${msg}`);
    }
    
    // Check ElevenLabs
    try {
      await getElevenLabs().voices.getAll();
      health.elevenlabs = true;
    } catch (error: unknown) {
      const msg = error instanceof Error ? error.message : String(error);
      health.errors.push(`ElevenLabs: ${msg}`);
    }
    
    // Check OpenRouter
    try {
      await getOpenRouter().models.list();
      health.openrouter = true;
    } catch (error: unknown) {
      const msg = error instanceof Error ? error.message : String(error);
      health.errors.push(`OpenRouter: ${msg}`);
    }
    
    return health;
  },
});

/**
 * Sync three default ElevenLabs premade voices into the voices table.
 * Prefers Rachel, Antoni, Bella; falls back to first premade voices available.
 */
export const syncDefaultVoices = action({
  args: {
    names: v.optional(v.array(v.string())),
  },
  handler: async (ctx, args) => {
    try {
      const targetNames = new Set((args.names || ["Rachel", "Antoni", "Bella"]).map(n => n.toLowerCase()));
      const result = await getElevenLabs().voices.getAll();
      // SDK returns shape { voices: Voice[] }
      const allVoices: any[] = (result as any).voices || (result as any) || [];
      const premade = allVoices.filter(v => (v.category || v.labels?.category) === "premade" || v.category === "cloned" || v.category === "generated");

      const selected: any[] = [];
      // First add by preferred names
      for (const vInfo of premade) {
        if (selected.length >= 3) break;
        if (vInfo?.name && targetNames.has(String(vInfo.name).toLowerCase())) {
          selected.push(vInfo);
        }
      }
      // Fill up remaining slots
      if (selected.length < 3) {
        for (const vInfo of premade) {
          if (selected.length >= 3) break;
          if (!selected.find(s => s.voice_id === vInfo.voice_id)) {
            selected.push(vInfo);
          }
        }
      }

      let inserted = 0;
      for (const vInfo of selected) {
        // Check if voice already exists by provider+externalVoiceId
        const existing = await ctx.runQuery(api.voices.getByExternalVoiceId, { externalVoiceId: vInfo.voice_id });
        if (existing) continue;

        const previewUrl = vInfo.preview_url || vInfo.preview?.url || (vInfo.samples?.[0]?.preview_url) || "";
        try {
          await ctx.runMutation(api.voices.upsertProviderVoice, {
            name: vInfo.name || "ElevenLabs Voice",
            description: vInfo.description || "Premade voice from ElevenLabs",
            language: "en",
            accent: undefined as any,
            ageGroup: "child",  // Mark default voices as child-friendly
            gender: (vInfo.gender === "male" || vInfo.gender === "female") ? vInfo.gender : "neutral",
            previewUrl: previewUrl,
            provider: "11labs",
            externalVoiceId: vInfo.voice_id,
            tags: Array.isArray(vInfo.labels) 
              ? [...vInfo.labels, "kids-friendly", "child-safe"]  // Add kid-friendly tags
              : ["kids-friendly", "child-safe"],
            isPremium: false,
            isPublic: true,
            // uploadedBy omitted for default library voices
          } as any);
          inserted += 1;
        } catch (e: any) {
          // Ignore write conflicts from concurrent seed attempts
          const msg = e?.message || String(e);
          if (!msg.includes('Documents read from or written to the "voices" table changed')) throw e;
        }
      }

      return { inserted };
    } catch (error: unknown) {
      const msg = error instanceof Error ? error.message : String(error);
      console.error("syncDefaultVoices error:", msg);
      throw new Error(`Failed to sync default voices: ${msg}`);
    }
  },
});

/**
 * Clone a new ElevenLabs voice from a base64-encoded audio file and store it in the voices table.
 * Returns the external voice_id for use in TTS, and the created DB document id.
 */
export const cloneElevenVoiceFromBase64 = action({
  args: {
    name: v.string(),
    description: v.string(),
    language: v.optional(v.string()),
    accent: v.optional(v.string()),
    ageGroup: v.string(),
    gender: v.union(v.literal("male"), v.literal("female"), v.literal("neutral")),
    tags: v.array(v.string()),
    isPublic: v.boolean(),
    fileBase64: v.string(),
    mimeType: v.optional(v.string()),
  },
  handler: async (ctx, args): Promise<{ voiceDocId: Id<"voices">; externalVoiceId: string; previewUrl: string }> => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Not authenticated");

    const apiKey = process.env.ELEVENLABS_API_KEY;
    if (!apiKey) throw new Error("ELEVENLABS_API_KEY is not configured");

    // Prepare multipart form-data without Node Buffer or data: URL fetch
    const bytes = base64ToUint8Array(args.fileBase64);
    const buf = bytes.buffer.slice(bytes.byteOffset, bytes.byteOffset + bytes.byteLength) as ArrayBuffer;
    const blob = new Blob([buf], { type: args.mimeType || 'audio/webm' });
    const form = new FormData();
    form.append('name', args.name);
    form.append('files', blob, 'voice_sample.webm');
    if (args.description) form.append('description', args.description);

    // Call ElevenLabs Voice Cloning API
    const res = await fetch('https://api.elevenlabs.io/v1/voices/add', {
      method: 'POST',
      headers: {
        'xi-api-key': apiKey,
      },
      body: form as any,
    } as any);

    if (!res.ok) {
      const errText = await res.text().catch(() => "");
      throw new Error(`ElevenLabs clone failed: ${res.status} ${res.statusText} ${errText}`);
    }

    const data: any = await res.json();
    const externalVoiceId: string = data?.voice_id || data?.voiceId || data?.id;
    if (!externalVoiceId) throw new Error("Missing voice_id from ElevenLabs response");

    // Try to fetch voice details to get preview URL
    let previewUrl = "";
    try {
      const detailsRes = await fetch(`https://api.elevenlabs.io/v1/voices/${externalVoiceId}`, {
        headers: { 'xi-api-key': apiKey },
      });
      if (detailsRes.ok) {
        const details: any = await detailsRes.json();
        previewUrl = details?.preview_url || details?.preview?.url || details?.samples?.[0]?.preview_url || "";
      }
    } catch (e) {
      // best-effort only
    }

    // Store in DB via mutation
    const insertedId = await ctx.runMutation(api.voices.upsertProviderVoice, {
      name: args.name,
      description: args.description,
      language: args.language || "en",
      accent: args.accent,
      ageGroup: args.ageGroup,
      gender: args.gender,
      previewUrl,
      provider: "11labs",
      externalVoiceId,
      tags: args.tags,
      isPremium: false,
      isPublic: args.isPublic,
      uploadedBy: identity.subject as any,
    } as any) as Id<"voices">;

    return { voiceDocId: insertedId, externalVoiceId, previewUrl };
  },
});
</file>

<file path="convex/auth.config.ts">
export default {
  providers: [
    {
      // Your Convex site URL is provided in a system
      // environment variable
      domain: process.env.CONVEX_SITE_URL,

      // Application ID has to be "convex"
      applicationID: "convex",
    },
  ],
}
</file>

<file path="convex/auth.ts">
import {
  BetterAuth,
  type AuthFunctions,
  type PublicAuthFunctions,
} from "@convex-dev/better-auth";
import { api, components, internal } from "./_generated/api";
import { query } from "./_generated/server";
import type { Id, DataModel } from "./_generated/dataModel";

// Typesafe way to pass Convex functions defined in this file
const authFunctions: AuthFunctions = internal.auth;
const publicAuthFunctions: PublicAuthFunctions = api.auth;

// Initialize the component
export const betterAuthComponent = new BetterAuth(
  components.betterAuth,
  {
    authFunctions,
    publicAuthFunctions,
  }
);

// These are required named exports
export const {
  createUser,
  updateUser,
  deleteUser,
  createSession,
  isAuthenticated,
} =
  betterAuthComponent.createAuthFunctions<DataModel>({
    // Must create a user and return the user id
    onCreateUser: async (ctx, user) => {
      return ctx.db.insert("users", {
        email: user.email,
        emailVerified: user.emailVerified || false, //  Use actual verification status from Better Auth
        name: user.name || "",
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      });
    },

    // Update the user when they are updated in Better Auth
    onUpdateUser: async (ctx, user) => {
      await ctx.db.patch(user.userId as Id<"users">, {
        email: user.email,
        emailVerified: user.emailVerified || false, //  Sync verification status
        name: user.name || "",
        updatedAt: new Date().toISOString(),
      });
    },

    // Delete the user when they are deleted from Better Auth
    onDeleteUser: async (ctx, userId) => {
      await ctx.db.delete(userId as Id<"users">);
    },
  });

// Example function for getting the current user
export const getCurrentUser = query({
  args: {},
  handler: async (ctx) => {
    // Get user data from Better Auth - email, name, image, etc.
    const userMetadata = await betterAuthComponent.getAuthUser(ctx);
    if (!userMetadata) {
      return null;
    }
    // Get user data from your application's database
    const user = await ctx.db.get(userMetadata.userId as Id<"users">);
    return {
      ...user,
      ...userMetadata,
    };
  },
});
</file>

<file path="convex/children.ts">
import { v } from "convex/values";
import { mutation, query } from "./_generated/server";
import { Id } from "./_generated/dataModel";

export const createChild = mutation({
  args: {
    name: v.string(),
    birthDate: v.string(),
    voiceProfile: v.optional(v.string()),
    avatar: v.optional(v.string()),
    settings: v.object({
      contentLevel: v.union(v.literal("toddler"), v.literal("preschool"), v.literal("elementary")),
      safetyLevel: v.union(v.literal("strict"), v.literal("moderate"), v.literal("relaxed")),
      allowedTopics: v.array(v.string()),
      blockedWords: v.array(v.string()),
      dailyTimeLimit: v.optional(v.number()),
      bedtimeRestrictions: v.optional(v.object({
        startTime: v.string(),
        endTime: v.string(),
      })),
    }),
  },
  handler: async (ctx, args) => {
    // TODO: Get authenticated user ID from BetterAuth session
    // For now, we'll require a parentId to be passed
    const parentId = "users:placeholder" as Id<"users">;
    
    const childId = await ctx.db.insert("children", {
      parentId,
      name: args.name,
      birthDate: args.birthDate,
      voiceProfile: args.voiceProfile,
      avatar: args.avatar,
      settings: args.settings,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    });
    
    return childId;
  },
});

export const listChildren = query({
  args: {},
  handler: async (ctx) => {
    // TODO: Get authenticated user ID from BetterAuth session
    // For now, return empty array
    return [];
  },
});

export const getChild = query({
  args: { id: v.id("children") },
  handler: async (ctx, args) => {
    return await ctx.db.get(args.id);
  },
});

export const updateChild = mutation({
  args: {
    id: v.id("children"),
    name: v.optional(v.string()),
    birthDate: v.optional(v.string()),
    voiceProfile: v.optional(v.string()),
    avatar: v.optional(v.string()),
    settings: v.optional(v.object({
      contentLevel: v.union(v.literal("toddler"), v.literal("preschool"), v.literal("elementary")),
      safetyLevel: v.union(v.literal("strict"), v.literal("moderate"), v.literal("relaxed")),
      allowedTopics: v.array(v.string()),
      blockedWords: v.array(v.string()),
      dailyTimeLimit: v.optional(v.number()),
      bedtimeRestrictions: v.optional(v.object({
        startTime: v.string(),
        endTime: v.string(),
      })),
    })),
  },
  handler: async (ctx, args) => {
    const { id, ...updates } = args;
    await ctx.db.patch(id, {
      ...updates,
      updatedAt: new Date().toISOString(),
    });
    return id;
  },
});
</file>

<file path="convex/conversations.ts">
import { v } from "convex/values";
import { mutation, query, action, internalMutation } from "./_generated/server";
import { Id } from "./_generated/dataModel";
import { api } from "./_generated/api";

// Create a new conversation
export const createConversation = mutation({
  args: {
    toyId: v.id("toys"),
    sessionId: v.string(),
    location: v.optional(v.union(v.literal("toy"), v.literal("web"), v.literal("app"))),
    deviceId: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthorized");

    // Get user from auth
    const user = await ctx.db
      .query("users")
      .withIndex("email", (q) => q.eq("email", identity.email!))
      .first();

    const conversationId = await ctx.db.insert("conversations", {
      toyId: args.toyId,
      sessionId: args.sessionId,
      startTime: new Date().toISOString(),
      userId: user?._id,
      duration: 0,
      messageCount: 0,
      flaggedMessages: 0,
      sentiment: "neutral",
      topics: [],
      location: args.location || "web",
      deviceId: args.deviceId,
    });

    return conversationId;
  },
});

// End a conversation
export const endConversation = mutation({
  args: {
    conversationId: v.id("conversations"),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthorized");

    const conversation = await ctx.db.get(args.conversationId);
    if (!conversation) throw new Error("Conversation not found");

    await ctx.db.patch(args.conversationId, {
      endTime: new Date().toISOString(),
      duration: Math.floor((Date.now() - new Date(conversation.startTime).getTime()) / 1000),
    });
  },
});

// Get recent conversations
export const getRecentConversations = query({
  args: {},
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) return [];

    return ctx.db
      .query("conversations")
      .order("desc")
      .take(10);
  },
});

// Get conversation history
export const getConversationHistory = query({
  args: {
    toyId: v.optional(v.id("toys")),
    userId: v.optional(v.id("users")),
    limit: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) return [];

    let conversations;
    
    if (args.toyId) {
      conversations = await ctx.db
        .query("conversations")
        .withIndex("by_toy", (q) => q.eq("toyId", args.toyId!))
        .order("desc")
        .collect();
    } else if (args.userId) {
      conversations = await ctx.db
        .query("conversations")
        .withIndex("by_user", (q) => q.eq("userId", args.userId))
        .order("desc")
        .collect();
    } else {
      conversations = await ctx.db
        .query("conversations")
        .order("desc")
        .collect();
    }

    // Apply limit
    conversations = conversations.slice(0, args.limit || 10);

    // Get message counts for each conversation
    const conversationsWithDetails = await Promise.all(
      conversations.map(async (conv) => {
        const messages = await ctx.db
          .query("messages")
          .withIndex("by_conversation", (q) => q.eq("conversationId", conv._id))
          .collect();

        return {
          ...conv,
          messageCount: messages.length,
        };
      })
    );

    return conversationsWithDetails;
  },
});

// Get active conversations for monitoring
export const getActiveConversations = query({
  args: {
    isForKids: v.optional(v.boolean()),
    limit: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    // Allow public test mode for development
    const allowUnauthTests = (process.env.ALLOW_UNAUTH_TESTS || "true").toLowerCase() === "true";
    if (!identity && !allowUnauthTests) return [];

    let query = ctx.db.query("conversations");
    
    // Filter by toys that are for kids if specified
    const conversations = await query
      .order("desc")
      .take(args.limit || 20);
    
    // Fetch toy details and filter by isForKids if needed
    const conversationsWithToys = await Promise.all(
      conversations.map(async (conv) => {
        const toy = await ctx.db.get(conv.toyId);
        if (args.isForKids && toy && !toy.isForKids) {
          return null;
        }
        return { ...conv, toy };
      })
    );
    
    // Filter out nulls and return active conversations
    return conversationsWithToys
      .filter(conv => conv !== null)
      .filter(conv => {
        // Consider a conversation active if it had messages in the last hour
        const oneHourAgo = Date.now() - (60 * 60 * 1000);
        const lastActivity = parseInt((conv as any).lastMessageAt || (conv as any).startedAt || "0");
        return lastActivity > oneHourAgo;
      });
  },
});

// Get conversation with messages
export const getConversationWithMessages = query({
  args: {
    conversationId: v.id("conversations"),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) return null;

    const conversation = await ctx.db.get(args.conversationId);
    if (!conversation) return null;

    const messages = await ctx.db
      .query("messages")
      .withIndex("by_conversation", (q) => q.eq("conversationId", args.conversationId))
      .order("asc")
      .collect();

    const toy = await ctx.db.get(conversation.toyId);
    const user = conversation.userId ? await ctx.db.get(conversation.userId) : null;

    return {
      ...conversation,
      messages,
      toy,
      user,
    };
  },
});

// Get conversation history with advanced filters
export const getFilteredConversationHistory = query({
  args: {
    toyId: v.optional(v.id("toys")),
    dateFrom: v.optional(v.number()),
    dateTo: v.optional(v.number()),
    sentiment: v.optional(v.array(v.union(v.literal("positive"), v.literal("neutral"), v.literal("negative")))),
    hasFlaggedMessages: v.optional(v.boolean()),
    searchQuery: v.optional(v.string()),
    limit: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) return [];

    let conversations;
    
    if (args.toyId) {
      conversations = await ctx.db
        .query("conversations")
        .withIndex("by_toy", (q) => q.eq("toyId", args.toyId!))
        .order("desc")
        .collect();
    } else {
      conversations = await ctx.db
        .query("conversations")
        .order("desc")
        .collect();
    }
    
    // Apply limit
    conversations = conversations.slice(0, args.limit || 100);

    // Get additional details for filtering
    const conversationsWithDetails = await Promise.all(
      conversations.map(async (conv) => {
        const messages = await ctx.db
          .query("messages")
          .withIndex("by_conversation", (q) => q.eq("conversationId", conv._id))
          .collect();

        const toy = await ctx.db.get(conv.toyId);
        
        // Calculate sentiment and flagged count
        let flaggedCount = 0;
        let positiveCount = 0;
        let negativeCount = 0;
        let neutralCount = 0;
        
        messages.forEach((msg) => {
          if (msg.metadata?.flagged) flaggedCount++;
          const sentiment = msg.metadata?.sentiment || 'neutral';
          if (sentiment === 'positive') positiveCount++;
          else if (sentiment === 'negative') negativeCount++;
          else neutralCount++;
        });
        
        // Determine overall sentiment
        let overallSentiment: 'positive' | 'neutral' | 'negative' = 'neutral';
        if (positiveCount > negativeCount && positiveCount > neutralCount) {
          overallSentiment = 'positive';
        } else if (negativeCount > positiveCount && negativeCount > neutralCount) {
          overallSentiment = 'negative';
        }

        // Check if conversation matches search query
        let matchesSearch = true;
        if (args.searchQuery) {
          const query = args.searchQuery.toLowerCase();
          matchesSearch = messages.some(msg => 
            msg.content.toLowerCase().includes(query)
          );
        }

        return {
          ...conv,
          toyName: toy?.name || 'Unknown Toy',
          messageCount: messages.length,
          flaggedMessageCount: flaggedCount,
          sentiment: overallSentiment,
          startedAt: parseInt(conv.startTime),
          duration: conv.endTime ? parseInt(conv.endTime) - parseInt(conv.startTime) : 0,
          matchesSearch,
        };
      })
    );

    // Apply filters
    const filtered = conversationsWithDetails.filter((conv) => {
      if (args.dateFrom && parseInt(conv.startTime) < args.dateFrom) return false;
      if (args.dateTo && parseInt(conv.startTime) > args.dateTo) return false;
      if (args.sentiment && args.sentiment.length > 0 && !args.sentiment.includes(conv.sentiment)) return false;
      if (args.hasFlaggedMessages !== undefined && (conv.flaggedMessageCount > 0) !== args.hasFlaggedMessages) return false;
      if (!conv.matchesSearch) return false;
      return true;
    });

    return filtered;
  },
});

// Get conversation analytics
export const getConversationAnalytics = query({
  args: {
    toyId: v.optional(v.id("toys")),
    dateFrom: v.optional(v.number()),
    dateTo: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) return null;

    let allConversations;
    
    if (args.toyId) {
      allConversations = await ctx.db
        .query("conversations")
        .withIndex("by_toy", (q) => q.eq("toyId", args.toyId!))
        .collect();
    } else {
      allConversations = await ctx.db
        .query("conversations")
        .collect();
    }

    // Filter by date range
    const filtered = allConversations.filter((conv) => {
      const startTime = parseInt(conv.startTime);
      if (args.dateFrom && startTime < args.dateFrom) return false;
      if (args.dateTo && startTime > args.dateTo) return false;
      return true;
    });

    // Get all messages for sentiment analysis
    const allMessages = await Promise.all(
      filtered.map(async (conv) => {
        const messages = await ctx.db
          .query("messages")
          .withIndex("by_conversation", (q) => q.eq("conversationId", conv._id))
          .collect();
        return messages;
      })
    );

    const flatMessages = allMessages.flat();

    // Calculate analytics
    const totalConversations = filtered.length;
    const totalMessages = flatMessages.length;
    const totalDuration = filtered.reduce((sum, conv) => {
      const duration = conv.endTime ? parseInt(conv.endTime) - parseInt(conv.startTime) : 0;
      return sum + duration;
    }, 0);
    const averageDuration = totalConversations > 0 ? totalDuration / totalConversations : 0;

    // Sentiment breakdown
    const sentimentBreakdown = {
      positive: 0,
      neutral: 0,
      negative: 0,
    };
    
    flatMessages.forEach((msg) => {
      const sentiment = msg.metadata?.sentiment || 'neutral';
      sentimentBreakdown[sentiment as keyof typeof sentimentBreakdown]++;
    });

    // Conversations by day (last 30 days)
    const conversationsByDay: { [key: string]: number } = {};
    const thirtyDaysAgo = Date.now() - (30 * 24 * 60 * 60 * 1000);
    
    filtered
      .filter(conv => parseInt(conv.startTime) >= thirtyDaysAgo)
      .forEach((conv) => {
        const date = new Date(parseInt(conv.startTime)).toISOString().split('T')[0];
        conversationsByDay[date] = (conversationsByDay[date] || 0) + 1;
      });

    // Convert to array format
    const conversationsByDayArray = Object.entries(conversationsByDay)
      .map(([date, count]) => ({ date, count }))
      .sort((a, b) => a.date.localeCompare(b.date));

    // Count flagged messages
    const flaggedMessageCount = flatMessages.filter(msg => msg.metadata?.flagged).length;

    return {
      totalConversations,
      totalMessages,
      averageDuration,
      sentimentBreakdown,
      conversationsByDay: conversationsByDayArray,
      flaggedMessageCount,
      // TODO: Add topic analysis when we have topic extraction
      topTopics: [],
    };
  },
});

/**
 * Get the active conversation for the current user and toy.
 * Returns the most recent conversation for this toy owned by the user.
 */
export const getActiveConversation = query({
  args: {
    toyId: v.id("toys"),
  },
  handler: async (ctx, { toyId }) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) return null;

    // Find the app user record from auth identity.
    const user = await ctx.db
      .query("users")
      .withIndex("email", (q) => q.eq("email", identity.email!))
      .first();

    if (!user) return null;

    // Get latest conversation for this user and toy.
    const conversations = await ctx.db
      .query("conversations")
      .withIndex("by_user", (q) => q.eq("userId", user._id))
      .order("desc")
      .collect();

    const conv = conversations.find((c) => c.toyId === toyId) || null;
    return conv;
  },
});

/**
 * Internal helper to get or create a conversation by sessionId.
 * - Does not require client auth.
 * - Links the conversation's userId to the toy creator for Guardian Mode.
 */
export const getOrCreate = internalMutation({
  args: {
    toyId: v.id("toys"),
    sessionId: v.string(),
    location: v.optional(v.union(v.literal("toy"), v.literal("web"), v.literal("app"))),
    deviceId: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    // Try to find an existing conversation for this session.
    const existing = await ctx.db
      .query("conversations")
      .withIndex("by_session", (q) => q.eq("sessionId", args.sessionId))
      .first();

    if (existing && existing.toyId === args.toyId) {
      return existing._id;
    }

    // Create a new conversation linked to the toy's creator as the user.
    const toy = await ctx.db.get(args.toyId);
    const userId = toy?.creatorId;

    const conversationId = await ctx.db.insert("conversations", {
      toyId: args.toyId,
      userId,
      sessionId: args.sessionId,
      startTime: new Date().toISOString(),
      duration: 0,
      messageCount: 0,
      flaggedMessages: 0,
      sentiment: "neutral",
      topics: [],
      location: args.location || "toy",
      deviceId: args.deviceId,
    });

    return conversationId;
  },
});
</file>

<file path="convex/convex.config.ts">
import { defineApp } from "convex/server";
import betterAuth from "@convex-dev/better-auth/convex.config";
import agent from "@convex-dev/agent/convex.config";
import resend from "@convex-dev/resend/convex.config";

const app = defineApp();
app.use(betterAuth);
app.use(agent); // Add agent component for real-time streaming and AI features
app.use(resend); // Add Resend component for email sending

export default app;
</file>

<file path="convex/crons.ts">
/**
 * Convex Cron Jobs
 * - Schedules daily data retention for messages older than 48 hours.
 * - Calls an internal mutation that deletes in batches to respect limits.
 */
import { cronJobs } from "convex/server";
import { internal } from "./_generated/api";

const crons = cronJobs();

// Run once per day at 00:00 UTC to purge old messages.
crons.daily(
  "purge-messages-older-than-48h",
  { hourUTC: 0, minuteUTC: 0 },
  internal.messages.deleteOldMessages,
  { batchSize: 500 },
);

export default crons;
</file>

<file path="convex/emailActions.ts">
import { action } from "./_generated/server";
import { v } from "convex/values";
import { internal } from "./_generated/api";

/**
 * Action to send verification email - callable from auth callbacks
 */
export const sendVerificationEmail = action({
  args: {
    email: v.string(),
    name: v.optional(v.string()),
    verificationUrl: v.string(),
  },
  handler: async (ctx, args): Promise<any> => {
    return await ctx.runMutation(internal.emails.sendVerificationEmail, args);
  },
});

/**
 * Action to send password reset email - callable from auth callbacks
 */
export const sendPasswordResetEmail = action({
  args: {
    email: v.string(),
    name: v.optional(v.string()),
    resetUrl: v.string(),
  },
  handler: async (ctx, args): Promise<any> => {
    return await ctx.runMutation(internal.emails.sendPasswordResetEmail, args);
  },
});

/**
 * Action to send welcome email - callable from auth callbacks
 */
export const sendWelcomeEmail = action({
  args: {
    email: v.string(),
    name: v.optional(v.string()),
  },
  handler: async (ctx, args): Promise<any> => {
    return await ctx.runMutation(internal.emails.sendWelcomeEmail, args);
  },
});
</file>

<file path="convex/emails.ts">
import { components, internal } from "./_generated/api";
import { Resend } from "@convex-dev/resend";
import { internalMutation } from "./_generated/server";
import { v } from "convex/values";

// Initialize Resend with explicit test mode control
// Priority:
// 1) RESEND_TEST_MODE env ("true"/"false")
// 2) Fallback: enable test mode when SITE_URL points to localhost
const inferLocal = () => {
  const site = process.env.SITE_URL || "";
  return site.includes("localhost") || site.includes("127.0.0.1");
};
const parsedTestMode = (() => {
  const v = process.env.RESEND_TEST_MODE;
  if (typeof v === "string") return v.toLowerCase() === "true";
  return inferLocal();
})();

export const resend = new Resend(components.resend, {
  testMode: parsedTestMode,
});

/**
 * Send verification email
 */
export const sendVerificationEmail = internalMutation({
  args: {
    email: v.string(),
    name: v.optional(v.string()),
    verificationUrl: v.string(),
  },
  handler: async (ctx, { email, name, verificationUrl }) => {
    const APP_NAME = "Pommai";
    
    const html = `
      <!DOCTYPE html>
      <html>
        <head>
          <meta charset="utf-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>Verify Your Email - ${APP_NAME}</title>
          <style>
            body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; line-height: 1.6; color: #333; }
            .container { max-width: 600px; margin: 0 auto; padding: 20px; }
            .header { background: linear-gradient(135deg, #c381b5 0%, #92cd41 100%); padding: 30px; text-align: center; border-radius: 10px 10px 0 0; }
            .header h1 { color: white; margin: 0; font-size: 28px; }
            .content { background: #f9f9f9; padding: 30px; border-radius: 0 0 10px 10px; }
            .button { display: inline-block; padding: 14px 30px; background: #c381b5; color: white; text-decoration: none; border-radius: 5px; margin: 20px 0; font-weight: bold; }
            .footer { text-align: center; margin-top: 30px; color: #666; font-size: 14px; }
            .warning { background: #fef5e7; border-left: 4px solid #f39c12; padding: 15px; margin: 20px 0; }
          </style>
        </head>
        <body>
          <div class="container">
            <div class="header">
              <h1> Welcome to ${APP_NAME}!</h1>
            </div>
            <div class="content">
              <h2>Verify Your Email Address</h2>
              <p>Hi ${name || 'there'},</p>
              <p>Thank you for signing up for ${APP_NAME} - the safe AI companion platform for children! Please verify your email address by clicking the button below:</p>
              
              <div style="text-align: center;">
                <a href="${verificationUrl}" class="button">Verify Email Address</a>
              </div>
              
              <div class="warning">
                <strong> Important:</strong> This verification link will expire in 1 hour.
              </div>
              
              <p style="color: #666; font-size: 14px;">
                If the button doesn't work, copy and paste this link into your browser:<br>
                <span style="color: #c381b5; word-break: break-all;">${verificationUrl}</span>
              </p>
            </div>
            <div class="footer">
              <p> ${new Date().getFullYear()} ${APP_NAME}. Safe AI Companions for Children.</p>
            </div>
          </div>
        </body>
      </html>
    `;

    const text = `Welcome to ${APP_NAME}! Please verify your email by visiting: ${verificationUrl}. This link will expire in 1 hour.`;

    // Use playpommai.com for all environments
    const fromHeader = `${APP_NAME} <noreply@playpommai.com>`;

    const emailId = await resend.sendEmail(ctx, {
      from: fromHeader,
      to: email,
      subject: ` Verify your email for ${APP_NAME}`,
      html,
      text,
    });

    console.log("Verification email sent:", emailId);
    return emailId;
  },
});

/**
 * Send password reset email
 */
export const sendPasswordResetEmail = internalMutation({
  args: {
    email: v.string(),
    name: v.optional(v.string()),
    resetUrl: v.string(),
  },
  handler: async (ctx, { email, name, resetUrl }) => {
    const APP_NAME = "Pommai";
    
    const html = `
      <!DOCTYPE html>
      <html>
        <head>
          <meta charset="utf-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>Reset Your Password - ${APP_NAME}</title>
          <style>
            body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; line-height: 1.6; color: #333; }
            .container { max-width: 600px; margin: 0 auto; padding: 20px; }
            .header { background: linear-gradient(135deg, #e74c3c 0%, #c381b5 100%); padding: 30px; text-align: center; border-radius: 10px 10px 0 0; }
            .header h1 { color: white; margin: 0; font-size: 28px; }
            .content { background: #f9f9f9; padding: 30px; border-radius: 0 0 10px 10px; }
            .button { display: inline-block; padding: 14px 30px; background: #e74c3c; color: white; text-decoration: none; border-radius: 5px; margin: 20px 0; font-weight: bold; }
            .footer { text-align: center; margin-top: 30px; color: #666; font-size: 14px; }
            .warning { background: #fef5e7; border-left: 4px solid #f39c12; padding: 15px; margin: 20px 0; }
            .security-tip { background: #e8f6f3; border-left: 4px solid #27ae60; padding: 15px; margin: 20px 0; }
          </style>
        </head>
        <body>
          <div class="container">
            <div class="header">
              <h1> Password Reset Request</h1>
            </div>
            <div class="content">
              <h2>Reset Your Password</h2>
              <p>Hi ${name || 'there'},</p>
              <p>We received a request to reset your password for your ${APP_NAME} account. Click the button below to create a new password:</p>
              
              <div style="text-align: center;">
                <a href="${resetUrl}" class="button">Reset Password</a>
              </div>
              
              <div class="warning">
                <strong> Important:</strong> This password reset link will expire in 1 hour.
              </div>
              
              <div class="security-tip">
                <strong> Security Tip:</strong> If you didn't request this password reset, please ignore this email. Your password won't be changed.
              </div>
              
              <p style="color: #666; font-size: 14px;">
                If the button doesn't work, copy and paste this link into your browser:<br>
                <span style="color: #e74c3c; word-break: break-all;">${resetUrl}</span>
              </p>
            </div>
            <div class="footer">
              <p> ${new Date().getFullYear()} ${APP_NAME}. Safe AI Companions for Children.</p>
            </div>
          </div>
        </body>
      </html>
    `;

    const text = `Password reset requested for your ${APP_NAME} account. Reset your password by visiting: ${resetUrl}. This link will expire in 1 hour.`;

    // Use playpommai.com for all environments
    const fromHeader = `${APP_NAME} <noreply@playpommai.com>`;

    const emailId = await resend.sendEmail(ctx, {
      from: fromHeader,
      to: email,
      subject: ` Password Reset Request - ${APP_NAME}`,
      html,
      text,
    });

    console.log("Password reset email sent:", emailId);
    return emailId;
  },
});

/**
 * Send welcome email after verification
 */
export const sendWelcomeEmail = internalMutation({
  args: {
    email: v.string(),
    name: v.optional(v.string()),
  },
  handler: async (ctx, { email, name }) => {
    const APP_NAME = "Pommai";
    const APP_URL = process.env.SITE_URL || "http://localhost:3000";
    
    const html = `
      <!DOCTYPE html>
      <html>
        <head>
          <meta charset="utf-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>Welcome to ${APP_NAME}!</title>
          <style>
            body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; line-height: 1.6; color: #333; }
            .container { max-width: 600px; margin: 0 auto; padding: 20px; }
            .header { background: linear-gradient(135deg, #92cd41 0%, #c381b5 100%); padding: 30px; text-align: center; border-radius: 10px 10px 0 0; }
            .header h1 { color: white; margin: 0; font-size: 28px; }
            .content { background: #f9f9f9; padding: 30px; border-radius: 0 0 10px 10px; }
            .button { display: inline-block; padding: 14px 30px; background: #92cd41; color: white; text-decoration: none; border-radius: 5px; margin: 20px 0; font-weight: bold; }
            .feature { background: white; padding: 15px; margin: 15px 0; border-radius: 8px; border-left: 4px solid #c381b5; }
            .footer { text-align: center; margin-top: 30px; color: #666; font-size: 14px; }
          </style>
        </head>
        <body>
          <div class="container">
            <div class="header">
              <h1>Welcome to ${APP_NAME}! </h1>
            </div>
            <div class="content">
              <h2>Your Email is Verified!</h2>
              <p>Hi ${name || 'there'},</p>
              <p>Your email has been successfully verified! You're now ready to create magical AI companions for your children.</p>
              
              <h3>What you can do now:</h3>
              
              <div class="feature">
                <strong> Create Custom Toys</strong><br>
                Design unique AI companions with personalities that match your child's interests
              </div>
              
              <div class="feature">
                <strong> Guardian Mode</strong><br>
                Monitor conversations, set content filters, and ensure safe interactions
              </div>
              
              <div class="feature">
                <strong> Educational Content</strong><br>
                Your AI toys can help with learning, storytelling, and creative play
              </div>
              
              <div style="text-align: center;">
                <a href="${APP_URL}/dashboard" class="button">Go to Dashboard</a>
              </div>
            </div>
            <div class="footer">
              <p> ${new Date().getFullYear()} ${APP_NAME}. Safe AI Companions for Children.</p>
            </div>
          </div>
        </body>
      </html>
    `;

    const text = `Welcome to ${APP_NAME}! Your email has been verified and your account is ready. Visit ${APP_URL}/dashboard to get started.`;

    // Use playpommai.com for all environments
    const fromHeader = `${APP_NAME} <noreply@playpommai.com>`;

    const emailId = await resend.sendEmail(ctx, {
      from: fromHeader,
      to: email,
      subject: ` Welcome to ${APP_NAME} - Your Account is Ready!`,
      html,
      text,
    });

    console.log("Welcome email sent:", emailId);
    return emailId;
  },
});
</file>

<file path="convex/http.ts">
import { httpRouter } from 'convex/server'
import { httpAction } from './_generated/server'
import { betterAuthComponent } from './auth'
import { createAuth } from '../src/lib/auth'
import { resend } from './emails'

const http = httpRouter()

// Register BetterAuth routes
betterAuthComponent.registerRoutes(http, createAuth)

// Resend webhook route
http.route({
  path: '/resend-webhook',
  method: 'POST',
  handler: httpAction(async (ctx, req) => {
    return await resend.handleResendEventWebhook(ctx, req)
  }),
})

export default http
</file>

<file path="convex/knowledge.ts">
import { mutation, query, action } from "./_generated/server";
import { v } from "convex/values";
import { api, internal } from "./_generated/api";
import { Id } from "./_generated/dataModel";

/**
 * Knowledge Base Management for Toy RAG System
 * Uses Convex Agent's built-in vector search and embeddings
 */

// Add knowledge to a toy's context
export const addToyKnowledge = mutation({
  args: {
    toyId: v.id("toys"),
    content: v.string(),
    type: v.union(
      v.literal("backstory"),
      v.literal("personality"),
      v.literal("facts"),
      v.literal("memories"),
      v.literal("rules"),
      v.literal("preferences"),
      v.literal("relationships")
    ),
    metadata: v.optional(v.object({
      source: v.string(),
      importance: v.number(), // 0-1 scale
      tags: v.array(v.string()),
      expiresAt: v.optional(v.number()), // For temporary knowledge
    })),
  },
  handler: async (ctx, args) => {
    // Get the toy to verify it exists
    const toy = await ctx.db.get(args.toyId);
    if (!toy) {
      throw new Error("Toy not found");
    }

    // Get or create thread for this toy
    const thread = await ctx.runQuery(api.agents.getThreadByToyId, {
      toyId: args.toyId,
    });
    
    if (thread && thread !== null) {
      // Save as a knowledge message in the Agent's system
      // This will be automatically indexed for vector search
      await ctx.runMutation(api.agents.saveKnowledgeMessage, {
        threadId: (thread as any).threadId,
        content: formatKnowledgeContent(args.type, args.content),
        metadata: {
          type: args.type,
          isKnowledge: true,
          ...args.metadata,
        },
      });
    } else {
      // Create a new thread if none exists
      const newThread = await ctx.runMutation(api.agents.createToyThread, {
        toyId: args.toyId,
      });
      
      // Save knowledge to the new thread
      await ctx.runMutation(api.agents.saveKnowledgeMessage, {
        threadId: newThread.threadId,
        content: formatKnowledgeContent(args.type, args.content),
        metadata: {
          type: args.type,
          isKnowledge: true,
          ...args.metadata,
        },
      });
    }
    
    // Also store in a dedicated knowledge table for management
    return await ctx.db.insert("toyKnowledge", {
      toyId: args.toyId,
      content: args.content,
      type: args.type,
      metadata: args.metadata || {
        source: "manual",
        importance: 0.5,
        tags: [],
      },
      createdAt: Date.now(),
      updatedAt: Date.now(),
    });
  },
});

// Bulk import knowledge for a toy
export const importToyKnowledge = action({
  args: {
    toyId: v.id("toys"),
    documents: v.array(v.object({
      content: v.string(),
      type: v.union(
        v.literal("backstory"),
        v.literal("personality"),
        v.literal("facts"),
        v.literal("memories"),
        v.literal("rules"),
        v.literal("preferences"),
        v.literal("relationships")
      ),
      source: v.string(),
    })),
    chunkSize: v.optional(v.number()), // Default 500 characters
  },
  handler: async (ctx, args) => {
    const chunkSize = args.chunkSize || 500;
    let totalChunks = 0;
    let successfulChunks = 0;
    const errors: string[] = [];
    
    // Process each document
    for (const doc of args.documents) {
      try {
        // Smart chunking based on content
        const chunks = chunkContent(doc.content, chunkSize);
        totalChunks += chunks.length;
        
        for (const [index, chunk] of chunks.entries()) {
          try {
            await ctx.runMutation(api.knowledge.addToyKnowledge, {
              toyId: args.toyId,
              content: chunk,
              type: doc.type,
              metadata: {
                source: doc.source,
                importance: calculateImportance(doc.type),
                tags: extractTags(chunk, doc.type),
              },
            });
            successfulChunks++;
          } catch (error: unknown) {
            const errMsg = error instanceof Error ? error.message : String(error);
            errors.push(`Failed to add chunk ${index + 1} of ${doc.source}: ${errMsg}`);
          }
        }
      } catch (error: unknown) {
        const errMsg = error instanceof Error ? error.message : String(error);
        errors.push(`Failed to process document ${doc.source}: ${errMsg}`);
      }
    }
    
    return { 
      success: errors.length === 0,
      totalChunks,
      successfulChunks,
      errors,
    };
  },
});

// Query toy knowledge
export const getToyKnowledge = query({
  args: {
    toyId: v.id("toys"),
    type: v.optional(v.union(
      v.literal("backstory"),
      v.literal("personality"),
      v.literal("facts"),
      v.literal("memories"),
      v.literal("rules"),
      v.literal("preferences"),
      v.literal("relationships")
    )),
    limit: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    let query = ctx.db
      .query("toyKnowledge")
      .filter((q) => q.eq(q.field("toyId"), args.toyId));
    
    if (args.type) {
      query = query.filter((q) => q.eq(q.field("type"), args.type));
    }
    
    const results = await query
      .order("desc")
      .take(args.limit || 100);
    
    return results;
  },
});

// Search toy knowledge using text similarity (leverages Agent's vector search)
export const searchToyKnowledge = action({
  args: {
    toyId: v.id("toys"),
    query: v.string(),
    limit: v.optional(v.number()),
    minRelevance: v.optional(v.number()),
  },
  handler: async (ctx, args): Promise<any[]> => {
    // Get the thread for this toy
    const thread = await ctx.runQuery(api.agents.getThreadByToyId, {
      toyId: args.toyId,
    });
    
    if (!thread) {
      return [];
    }
    
    // The Agent's built-in RAG will automatically search through
    // all messages in the thread, including our knowledge messages
    // This happens when we generate responses, but we can also
    // query directly from the toyKnowledge table
    
    const knowledge: any[] = await ctx.runQuery(api.knowledge.getToyKnowledge, {
      toyId: args.toyId,
      limit: args.limit || 10,
    });
    
    // Filter by relevance if needed (simple text matching for now)
    // In production, this would use the Agent's vector search
    const queryLower = args.query.toLowerCase();
    const minRelevance = args.minRelevance || 0.3;
    
    const relevant: any[] = knowledge
      .map((item: any) => ({
        ...item,
        relevance: calculateRelevance(item.content, queryLower),
      }))
      .filter((item: any) => item.relevance >= minRelevance)
      .sort((a: any, b: any) => b.relevance - a.relevance)
      .slice(0, args.limit || 10);
    
    return relevant;
  },
});

// Update toy knowledge
export const updateToyKnowledge = mutation({
  args: {
    knowledgeId: v.id("toyKnowledge"),
    content: v.optional(v.string()),
    metadata: v.optional(v.object({
      source: v.string(),
      importance: v.number(),
      tags: v.array(v.string()),
      expiresAt: v.optional(v.number()),
    })),
  },
  handler: async (ctx, args) => {
    const knowledge = await ctx.db.get(args.knowledgeId);
    if (!knowledge) {
      throw new Error("Knowledge not found");
    }
    
    const updates: any = {
      updatedAt: Date.now(),
    };
    
    if (args.content !== undefined) {
      updates.content = args.content;
    }
    
    if (args.metadata !== undefined) {
      updates.metadata = {
        ...knowledge.metadata,
        ...args.metadata,
      };
    }
    
    return await ctx.db.patch(args.knowledgeId, updates);
  },
});

// Delete toy knowledge
export const deleteToyKnowledge = mutation({
  args: {
    knowledgeId: v.id("toyKnowledge"),
  },
  handler: async (ctx, args) => {
    const knowledge = await ctx.db.get(args.knowledgeId);
    if (!knowledge) {
      throw new Error("Knowledge not found");
    }
    
    await ctx.db.delete(args.knowledgeId);
    return { success: true };
  },
});

// Clear all knowledge for a toy (use with caution)
export const clearToyKnowledge = mutation({
  args: {
    toyId: v.id("toys"),
    type: v.optional(v.union(
      v.literal("backstory"),
      v.literal("personality"),
      v.literal("facts"),
      v.literal("memories"),
      v.literal("rules"),
      v.literal("preferences"),
      v.literal("relationships")
    )),
  },
  handler: async (ctx, args) => {
    let query = ctx.db
      .query("toyKnowledge")
      .filter((q) => q.eq(q.field("toyId"), args.toyId));
    
    if (args.type) {
      query = query.filter((q) => q.eq(q.field("type"), args.type));
    }
    
    const items = await query.collect();
    
    for (const item of items) {
      await ctx.db.delete(item._id);
    }
    
    return { 
      success: true, 
      deletedCount: items.length 
    };
  },
});

// Get knowledge statistics for a toy
export const getToyKnowledgeStats = query({
  args: {
    toyId: v.id("toys"),
  },
  handler: async (ctx, args) => {
    const knowledge = await ctx.db
      .query("toyKnowledge")
      .filter((q) => q.eq(q.field("toyId"), args.toyId))
      .collect();
    
    const stats = {
      total: knowledge.length,
      byType: {} as Record<string, number>,
      avgImportance: 0,
      totalCharacters: 0,
      oldestEntry: null as Date | null,
      newestEntry: null as Date | null,
      topTags: [] as Array<{ tag: string; count: number }>,
    };
    
    const tagCounts: Record<string, number> = {};
    let totalImportance = 0;
    
    for (const item of knowledge) {
      // Count by type
      stats.byType[item.type] = (stats.byType[item.type] || 0) + 1;
      
      // Sum importance
      totalImportance += item.metadata?.importance || 0.5;
      
      // Count characters
      stats.totalCharacters += item.content.length;
      
      // Track dates
      const date = new Date(item.createdAt);
      if (!stats.oldestEntry || date < stats.oldestEntry) {
        stats.oldestEntry = date;
      }
      if (!stats.newestEntry || date > stats.newestEntry) {
        stats.newestEntry = date;
      }
      
      // Count tags
      if (item.metadata?.tags) {
        for (const tag of item.metadata.tags) {
          tagCounts[tag] = (tagCounts[tag] || 0) + 1;
        }
      }
    }
    
    // Calculate average importance
    if (knowledge.length > 0) {
      stats.avgImportance = totalImportance / knowledge.length;
    }
    
    // Get top tags
    stats.topTags = Object.entries(tagCounts)
      .map(([tag, count]) => ({ tag, count }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 10);
    
    return stats;
  },
});

// Helper functions

function chunkContent(content: string, maxLength: number): string[] {
  // Smart chunking that preserves context
  const sentences = content.match(/[^.!?]+[.!?]+/g) || [];
  const chunks: string[] = [];
  let currentChunk = "";
  
  for (const sentence of sentences) {
    if ((currentChunk + sentence).length > maxLength && currentChunk) {
      chunks.push(currentChunk.trim());
      currentChunk = sentence;
    } else {
      currentChunk += (currentChunk ? " " : "") + sentence;
    }
  }
  
  if (currentChunk) {
    chunks.push(currentChunk.trim());
  }
  
  // If no sentences found, fall back to simple chunking
  if (chunks.length === 0 && content.length > 0) {
    for (let i = 0; i < content.length; i += maxLength) {
      chunks.push(content.slice(i, i + maxLength));
    }
  }
  
  return chunks;
}

function extractTags(content: string, type: string): string[] {
  const tags: string[] = [type];
  const contentLower = content.toLowerCase();
  
  // Common theme detection
  const themes: Record<string, string[]> = {
    friendship: ["friend", "buddy", "pal", "companion"],
    education: ["learn", "teach", "study", "knowledge", "school"],
    games: ["play", "game", "fun", "activity", "puzzle"],
    storytelling: ["story", "tale", "adventure", "journey"],
    emotions: ["happy", "sad", "excited", "angry", "scared"],
    family: ["mom", "dad", "brother", "sister", "family"],
    nature: ["tree", "flower", "animal", "forest", "ocean"],
    science: ["science", "experiment", "discover", "explore"],
    creativity: ["create", "imagine", "build", "draw", "paint"],
    music: ["song", "music", "sing", "dance", "rhythm"],
  };
  
  for (const [theme, keywords] of Object.entries(themes)) {
    if (keywords.some(keyword => contentLower.includes(keyword))) {
      tags.push(theme);
    }
  }
  
  return [...new Set(tags)]; // Remove duplicates
}

function calculateImportance(type: string): number {
  // Assign default importance based on type
  const importanceMap: Record<string, number> = {
    rules: 1.0,        // Most important - safety and behavior rules
    backstory: 0.8,    // Core personality definition
    personality: 0.8,  // Core traits
    relationships: 0.7, // Important context
    preferences: 0.6,   // User preferences
    facts: 0.5,        // General knowledge
    memories: 0.4,     // Past interactions
  };
  
  return importanceMap[type] || 0.5;
}

function formatKnowledgeContent(type: string, content: string): string {
  // Format content based on type for better Agent understanding
  const prefixes: Record<string, string> = {
    backstory: "Background Information: ",
    personality: "Personality Trait: ",
    facts: "Fact: ",
    memories: "Memory: ",
    rules: "Important Rule: ",
    preferences: "Preference: ",
    relationships: "Relationship: ",
  };
  
  return (prefixes[type] || "") + content;
}

function calculateRelevance(content: string, query: string): number {
  // Simple relevance calculation based on keyword matching
  // In production, this would use vector similarity from the Agent
  const contentLower = content.toLowerCase();
  const queryWords = query.split(/\s+/);
  
  let matches = 0;
  let totalWords = queryWords.length;
  
  for (const word of queryWords) {
    if (contentLower.includes(word)) {
      matches++;
    }
  }
  
  return totalWords > 0 ? matches / totalWords : 0;
}
</file>

<file path="convex/knowledgeBase.ts">
import { v } from "convex/values";
import { mutation, query } from "./_generated/server";
import { Id } from "./_generated/dataModel";
import { api } from "./_generated/api";

/**
 * Create or update knowledge base for a toy
 */
export const upsertKnowledgeBase = mutation({
  args: {
    toyId: v.id("toys"),
    toyBackstory: v.object({
      origin: v.string(),
      personality: v.string(),
      specialAbilities: v.array(v.string()),
      favoriteThings: v.array(v.string()),
    }),
    familyInfo: v.optional(v.object({
      members: v.array(v.object({
        name: v.string(),
        relationship: v.string(),
        facts: v.array(v.string()),
      })),
      pets: v.array(v.object({
        name: v.string(),
        type: v.string(),
        facts: v.array(v.string()),
      })),
      importantDates: v.array(v.object({
        date: v.string(),
        event: v.string(),
      })),
    })),
    customFacts: v.array(v.object({
      category: v.string(),
      fact: v.string(),
      importance: v.union(v.literal("high"), v.literal("medium"), v.literal("low")),
    })),
  },
  handler: async (ctx, args) => {
    // Verify toy ownership
    const toy = await ctx.db.get(args.toyId);
    if (!toy) {
      throw new Error("Toy not found");
    }

    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Not authenticated");
    }

    const userId = identity.subject as any;
    if (toy.creatorId !== userId && toy.guardianId !== userId) {
      throw new Error("Only the toy owner can update its knowledge base");
    }

    // Check if knowledge base already exists
    const existingKb = await ctx.db
      .query("knowledgeBases")
      .withIndex("by_toy", (q) => q.eq("toyId", args.toyId))
      .first();

    const now = new Date().toISOString();

    let kbId: Id<"knowledgeBases">;

    if (existingKb) {
      // Update existing knowledge base
      await ctx.db.patch(existingKb._id, {
        toyBackstory: args.toyBackstory,
        familyInfo: args.familyInfo,
        customFacts: args.customFacts,
        updatedAt: now,
      });

      // Update toy's knowledge base reference
      if (!toy.knowledgeBaseId) {
        await ctx.db.patch(args.toyId, {
          knowledgeBaseId: existingKb._id,
          lastModifiedAt: now,
        });
      }

      kbId = existingKb._id;
    } else {
      // Create new knowledge base
      kbId = await ctx.db.insert("knowledgeBases", {
        toyId: args.toyId,
        toyBackstory: args.toyBackstory,
        familyInfo: args.familyInfo,
        customFacts: args.customFacts,
        memories: [],
        vectorStoreId: undefined,
        createdAt: now,
        updatedAt: now,
      });

      // Update toy with knowledge base reference
      await ctx.db.patch(args.toyId, {
        knowledgeBaseId: kbId,
        lastModifiedAt: now,
      });
    }

    // --- Ingest knowledge into the Agent thread for RAG ---
    // Ensure the toy has a canonical agent thread
    const thread = await ctx.runMutation(api.agents.getOrCreateToyThread, {
      toyId: args.toyId,
      userId: toy.creatorId,
    });
    const threadId = thread.threadId;

    // Helper to enqueue a knowledge message
    const save = async (content: string, type: string, importance?: number, tags?: string[]) => {
      const trimmed = content?.trim();
      if (!trimmed) return;
      await ctx.runMutation(api.agents.saveKnowledgeMessage, {
        threadId,
        content: trimmed,
        metadata: {
          type,
          isKnowledge: true,
          source: "knowledgeBase",
          importance,
          tags,
        },
      });
    };

    // Chunking helpers
    const chunkText = (text: string, max = 500): string[] => {
      if (!text) return [];
      const sentences = text.match(/[^.!?]+[.!?]+/g) || [text];
      const chunks: string[] = [];
      let current = "";
      for (const s of sentences) {
        if ((current + s).length > max && current) {
          chunks.push(current.trim());
          current = s;
        } else {
          current += (current ? " " : "") + s;
        }
      }
      if (current) chunks.push(current.trim());
      if (chunks.length === 0 && text.length > 0) {
        for (let i = 0; i < text.length; i += max) chunks.push(text.slice(i, i + max));
      }
      return chunks;
    };

    // Backstory/personality
    const back = args.toyBackstory;
    const backstoryParts: string[] = [];
    if (back.origin) backstoryParts.push(`Origin: ${back.origin}`);
    if (back.personality) backstoryParts.push(`Personality: ${back.personality}`);
    if (back.specialAbilities?.length) backstoryParts.push(`Special Abilities: ${back.specialAbilities.join(", ")}`);
    if (back.favoriteThings?.length) backstoryParts.push(`Favorite Things: ${back.favoriteThings.join(", ")}`);
    const backstoryText = backstoryParts.join("\n");
    for (const chunk of chunkText(backstoryText)) {
      await save(chunk, "backstory", 0.8, ["backstory"]);
    }

    // Family info
    if (args.familyInfo) {
      const fam = args.familyInfo;
      for (const m of fam.members ?? []) {
        const line = `Family Member: ${m.name} (${m.relationship})  Facts: ${m.facts.join(", ")}`;
        for (const chunk of chunkText(line)) await save(chunk, "relationships", 0.7, ["family", "relationships"]);
      }
      for (const p of fam.pets ?? []) {
        const line = `Pet: ${p.name} (${p.type})  Facts: ${p.facts.join(", ")}`;
        for (const chunk of chunkText(line)) await save(chunk, "relationships", 0.6, ["pets", "relationships"]);
      }
      for (const d of fam.importantDates ?? []) {
        const line = `Important Date: ${d.date}  ${d.event}`;
        for (const chunk of chunkText(line)) await save(chunk, "memories", 0.5, ["dates"]);
      }
    }

    // Custom facts
    for (const f of args.customFacts ?? []) {
      const line = `Fact [${f.category}] (${f.importance}): ${f.fact}`;
      const imp = f.importance === "high" ? 1.0 : f.importance === "medium" ? 0.7 : 0.5;
      for (const chunk of chunkText(line)) await save(chunk, "facts", imp, ["facts", f.category]);
    }

    return kbId;
  },
});

/**
 * Get knowledge base for a toy
 */
export const getKnowledgeBase = query({
  args: { toyId: v.id("toys") },
  handler: async (ctx, args) => {
    // Verify toy access
    const toy = await ctx.db.get(args.toyId);
    if (!toy) {
      throw new Error("Toy not found");
    }

    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Not authenticated");
    }

    const userId = identity.subject as any;
    if (toy.creatorId !== userId && toy.guardianId !== userId && !toy.isPublic) {
      throw new Error("Access denied");
    }

    const knowledgeBase = await ctx.db
      .query("knowledgeBases")
      .withIndex("by_toy", (q) => q.eq("toyId", args.toyId))
      .first();

    return knowledgeBase;
  },
});

/**
 * Add a memory to the knowledge base
 */
export const addMemory = mutation({
  args: {
    toyId: v.id("toys"),
    memory: v.object({
      description: v.string(),
      date: v.string(),
      participants: v.array(v.string()),
      autoGenerated: v.boolean(),
    }),
  },
  handler: async (ctx, args) => {
    // Verify toy ownership
    const toy = await ctx.db.get(args.toyId);
    if (!toy) {
      throw new Error("Toy not found");
    }

    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Not authenticated");
    }

    const userId = identity.subject as any;
    
    // For auto-generated memories from conversations, allow toy to add
    // For manual memories, only owner/guardian can add
    if (!args.memory.autoGenerated && 
        toy.creatorId !== userId && 
        toy.guardianId !== userId) {
      throw new Error("Only the toy owner can add memories");
    }

    const knowledgeBase = await ctx.db
      .query("knowledgeBases")
      .withIndex("by_toy", (q) => q.eq("toyId", args.toyId))
      .first();

    if (!knowledgeBase) {
      throw new Error("Knowledge base not found. Please create one first.");
    }

    // Generate unique memory ID
    const memoryId = `mem_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

    // Add memory to the array
    const updatedMemories = [
      ...knowledgeBase.memories,
      {
        id: memoryId,
        ...args.memory,
      },
    ];

    await ctx.db.patch(knowledgeBase._id, {
      memories: updatedMemories,
      updatedAt: new Date().toISOString(),
    });

    return memoryId;
  },
});

/**
 * Remove a memory from the knowledge base
 */
export const removeMemory = mutation({
  args: {
    toyId: v.id("toys"),
    memoryId: v.string(),
  },
  handler: async (ctx, args) => {
    // Verify toy ownership
    const toy = await ctx.db.get(args.toyId);
    if (!toy) {
      throw new Error("Toy not found");
    }

    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Not authenticated");
    }

    const userId = identity.subject as any;
    if (toy.creatorId !== userId && toy.guardianId !== userId) {
      throw new Error("Only the toy owner can remove memories");
    }

    const knowledgeBase = await ctx.db
      .query("knowledgeBases")
      .withIndex("by_toy", (q) => q.eq("toyId", args.toyId))
      .first();

    if (!knowledgeBase) {
      throw new Error("Knowledge base not found");
    }

    // Filter out the memory
    const updatedMemories = knowledgeBase.memories.filter(
      (mem) => mem.id !== args.memoryId
    );

    await ctx.db.patch(knowledgeBase._id, {
      memories: updatedMemories,
      updatedAt: new Date().toISOString(),
    });

    return { success: true };
  },
});

/**
 * Add custom facts to knowledge base
 */
export const addCustomFacts = mutation({
  args: {
    toyId: v.id("toys"),
    facts: v.array(v.object({
      category: v.string(),
      fact: v.string(),
      importance: v.union(v.literal("high"), v.literal("medium"), v.literal("low")),
    })),
  },
  handler: async (ctx, args) => {
    // Verify toy ownership
    const toy = await ctx.db.get(args.toyId);
    if (!toy) {
      throw new Error("Toy not found");
    }

    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Not authenticated");
    }

    const userId = identity.subject as any;
    if (toy.creatorId !== userId && toy.guardianId !== userId) {
      throw new Error("Only the toy owner can add facts");
    }

    const knowledgeBase = await ctx.db
      .query("knowledgeBases")
      .withIndex("by_toy", (q) => q.eq("toyId", args.toyId))
      .first();

    if (!knowledgeBase) {
      throw new Error("Knowledge base not found. Please create one first.");
    }

    // Append new facts to existing ones
    const updatedFacts = [...knowledgeBase.customFacts, ...args.facts];

    await ctx.db.patch(knowledgeBase._id, {
      customFacts: updatedFacts,
      updatedAt: new Date().toISOString(),
    });

    return { success: true };
  },
});

/**
 * Update family information
 */
export const updateFamilyInfo = mutation({
  args: {
    toyId: v.id("toys"),
    familyInfo: v.object({
      members: v.array(v.object({
        name: v.string(),
        relationship: v.string(),
        facts: v.array(v.string()),
      })),
      pets: v.array(v.object({
        name: v.string(),
        type: v.string(),
        facts: v.array(v.string()),
      })),
      importantDates: v.array(v.object({
        date: v.string(),
        event: v.string(),
      })),
    }),
  },
  handler: async (ctx, args) => {
    // Verify toy ownership
    const toy = await ctx.db.get(args.toyId);
    if (!toy) {
      throw new Error("Toy not found");
    }

    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Not authenticated");
    }

    const userId = identity.subject as any;
    if (toy.creatorId !== userId && toy.guardianId !== userId) {
      throw new Error("Only the toy owner can update family info");
    }

    const knowledgeBase = await ctx.db
      .query("knowledgeBases")
      .withIndex("by_toy", (q) => q.eq("toyId", args.toyId))
      .first();

    if (!knowledgeBase) {
      throw new Error("Knowledge base not found. Please create one first.");
    }

    await ctx.db.patch(knowledgeBase._id, {
      familyInfo: args.familyInfo,
      updatedAt: new Date().toISOString(),
    });

    return { success: true };
  },
});

/**
 * Search memories by keyword
 */
export const searchMemories = query({
  args: {
    toyId: v.id("toys"),
    searchTerm: v.string(),
  },
  handler: async (ctx, args) => {
    // Verify toy access
    const toy = await ctx.db.get(args.toyId);
    if (!toy) {
      throw new Error("Toy not found");
    }

    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Not authenticated");
    }

    const userId = identity.subject as any;
    if (toy.creatorId !== userId && toy.guardianId !== userId && !toy.isPublic) {
      throw new Error("Access denied");
    }

    const knowledgeBase = await ctx.db
      .query("knowledgeBases")
      .withIndex("by_toy", (q) => q.eq("toyId", args.toyId))
      .first();

    if (!knowledgeBase) {
      return [];
    }

    const searchLower = args.searchTerm.toLowerCase();

    // Search through memories
    const matchingMemories = knowledgeBase.memories.filter(mem =>
      mem.description.toLowerCase().includes(searchLower) ||
      mem.participants.some(p => p.toLowerCase().includes(searchLower))
    );

    return matchingMemories;
  },
});
</file>

<file path="convex/messages.ts">
import { v } from "convex/values";
import { mutation, query, action, internalMutation } from "./_generated/server";
import { api, internal } from "./_generated/api";
import { Id } from "./_generated/dataModel";

// Send a message in a conversation
export const sendMessage = mutation({
  args: {
    conversationId: v.id("conversations"),
    content: v.string(),
    role: v.union(v.literal("user"), v.literal("toy"), v.literal("system")),
    audioUrl: v.optional(v.string()),
    metadata: v.optional(v.object({
      sentiment: v.optional(v.string()),
      safetyScore: v.optional(v.number()),
      flagged: v.optional(v.boolean()),
      topics: v.optional(v.array(v.string())),
      educationalValue: v.optional(v.number()),
      emotionalTone: v.optional(v.string()),
      safetyFlags: v.optional(v.array(v.string())),
    })),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthorized");

    const conversation = await ctx.db.get(args.conversationId);
    if (!conversation) throw new Error("Conversation not found");

    // Insert the message
    const messageId = await ctx.db.insert("messages", {
      conversationId: args.conversationId,
      role: args.role,
      content: args.content,
      audioUrl: args.audioUrl,
      metadata: args.metadata,
      timestamp: new Date().toISOString(),
    });

    // Update conversation message count and flagged count if needed
    const flaggedMessages = args.metadata?.flagged ? conversation.flaggedMessages + 1 : conversation.flaggedMessages;
    await ctx.db.patch(args.conversationId, {
      messageCount: conversation.messageCount + 1,
      flaggedMessages,
    });

    return messageId;
  },
});

// Get messages for a conversation
export const getMessages = query({
  args: {
    conversationId: v.id("conversations"),
    limit: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) return [];

    const messages = await ctx.db
      .query("messages")
      .withIndex("by_conversation", (q) => q.eq("conversationId", args.conversationId))
      .order("asc")
      .take(args.limit || 100);

    return messages;
  },
});

// Generate AI response with audio
export const generateAIResponse = action({
  args: {
    conversationId: v.id("conversations"),
    userMessage: v.string(),
    includeAudio: v.optional(v.boolean()),
    sessionId: v.optional(v.string()),
  },
  handler: async (ctx, args): Promise<{
    text: string;
    audioData?: string;
    format?: string;
    duration?: number;
  }> => {
    // Get conversation and toy details
    const conversation = await ctx.runQuery(api.conversations.getConversationWithMessages, {
      conversationId: args.conversationId,
    });

    if (!conversation || !conversation.toy) {
      throw new Error("Conversation or toy not found");
    }

    const toy = conversation.toy;
    
    try {
      // Step 1: Get or create the canonical agent thread for this toy
      const { threadId } = await ctx.runMutation(api.agents.getOrCreateToyThread, {
        toyId: toy._id,
        userId: toy.creatorId,
      });

      // Step 2: Save the user's message to the agent thread
      const { messageId } = await ctx.runMutation(api.agents.saveAudioMessage, {
        threadId,
        transcript: args.userMessage,
      });

      // Step 3: Generate response using the unified Agent approach
      // Only pass promptMessageId since we already saved the message
      const agentResult = await ctx.runAction(internal.agents.generateToyResponse, {
        threadId,
        toyId: toy._id,
        promptMessageId: messageId,
        // Don't pass prompt - the Agent will get it from promptMessageId
      });

      const responseText = agentResult.text || "I'm having trouble understanding. Can you try asking in a different way?";
      
      // Step 4: Apply safety check for kids' toys
      let finalText = responseText;
      let metadata: any = {
        safetyScore: 1.0,
        flagged: false,
      };
      
      if (toy.isForKids) {
        const safetyCheck = await ctx.runAction(internal.aiPipeline.checkContentSafety, {
          text: responseText,
          level: "strict",
        });
        
        if (!safetyCheck.passed) {
          console.log("Output safety check failed, using fallback response");
          finalText = "That's interesting! Let me think of something fun we can talk about instead.";
          metadata.flagged = true;
          metadata.safetyFlags = [safetyCheck.reason];
        }
      }

      // Generate audio if requested
      let audioData: string | undefined;
      let format: string | undefined;
      let duration: number | undefined;

      // Skip audio generation for web chat to avoid TTS issues
      // Audio is primarily for physical toys, not web interface
      const skipAudio = true; // Disable audio for now
      
      if (!skipAudio && args.includeAudio !== false) {
        try {
          const audioResponse = await ctx.runAction(api.aiServices.synthesizeSpeech, {
            text: finalText,
            voiceId: toy.voiceId || "JBFqnCBsd6RMkjVDRZzb",
            voiceSettings: {
              stability: 0.5,
              similarityBoost: 0.75,
              style: 0,
              useSpeakerBoost: true,
            },
            outputFormat: "mp3_44100_128",
          });

          audioData = audioResponse.audioData;
          format = audioResponse.format;
          duration = audioResponse.duration;
        } catch (audioError) {
          console.log("TTS skipped due to error:", audioError);
          // Continue without audio - this is fine for web chat
        }
      }

      // Save AI response with metadata
      await ctx.runMutation(api.messages.sendMessage, {
        conversationId: args.conversationId,
        content: finalText,
        role: "toy",
        metadata,
      });

      return {
        text: finalText,
        audioData,
        format,
        duration,
      };
    } catch (error) {
      console.error("Error in AI pipeline:", error);
      
      // Fallback response
      const fallbackText = `Hi! I'm ${toy.name}. I'm having a little trouble right now, but I'm still happy to talk with you! What would you like to chat about?`;
      
      // Try to generate audio for fallback
      let audioData: string | undefined;
      let format: string | undefined;
      
      // Skip audio for fallback as well
      const skipAudio = true;
      if (!skipAudio && args.includeAudio !== false) {
        try {
          const audioResponse = await ctx.runAction(api.aiServices.synthesizeSpeech, {
            text: fallbackText,
            voiceId: toy.voiceId || "JBFqnCBsd6RMkjVDRZzb",
            outputFormat: "mp3_44100_128",
          });
          audioData = audioResponse.audioData;
          format = audioResponse.format;
        } catch (audioError) {
          console.log("Fallback TTS skipped:", audioError);
        }
      }
      
      // Save fallback response
      await ctx.runMutation(api.messages.sendMessage, {
        conversationId: args.conversationId,
        content: fallbackText,
        role: "toy",
        metadata: {
          safetyScore: 1.0,
          flagged: false,
          // Note: isFallback is tracked internally but not in schema
        },
      });

      return {
        text: fallbackText,
        audioData,
        format,
      };
    }
  },
});

// Flag a message for review
export const flagMessage = mutation({
  args: {
    messageId: v.id("messages"),
    reason: v.string(),
    severity: v.union(v.literal("low"), v.literal("medium"), v.literal("high")),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthorized");

    const message = await ctx.db.get(args.messageId);
    if (!message) throw new Error("Message not found");

    // Update message metadata
    await ctx.db.patch(args.messageId, {
      metadata: {
        ...message.metadata,
        flagged: true,
        safetyFlags: [...(message.metadata?.safetyFlags || []), args.reason],
      },
    });

    // Create moderation log (matching schema)
    await ctx.db.insert("moderationLogs", {
      messageId: args.messageId,
      flagType: args.reason,
      severity: args.severity,
      details: `Message flagged: ${args.reason}`,
      action: "flagged",
      timestamp: Date.now().toString(),
    });

    // Update conversation flagged count
    const conversation = await ctx.db.get(message.conversationId);
    if (conversation) {
      await ctx.db.patch(message.conversationId, {
        flaggedMessages: conversation.flaggedMessages + 1,
      });
    }
  },
});

// Search messages with filters
export const searchMessages = query({
  args: {
    conversationId: v.optional(v.id("conversations")),
    toyId: v.optional(v.id("toys")),
    userId: v.optional(v.id("users")),
    dateFrom: v.optional(v.number()),
    dateTo: v.optional(v.number()),
    flaggedOnly: v.optional(v.boolean()),
    limit: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) return [];

    // Get all messages first (since we don't have direct toy/user indexes on messages)
    let messages = await ctx.db.query("messages").collect();

    // If conversationId is provided, filter by it
    if (args.conversationId) {
      messages = messages.filter(msg => msg.conversationId === args.conversationId);
    }

    // If toyId or userId provided, we need to get conversations first
    if (args.toyId || args.userId) {
      let conversations;
      if (args.toyId) {
        conversations = await ctx.db
          .query("conversations")
          .withIndex("by_toy", (q) => q.eq("toyId", args.toyId!))
          .collect();
      } else if (args.userId) {
        conversations = await ctx.db
          .query("conversations")
          .withIndex("by_user", (q) => q.eq("userId", args.userId))
          .collect();
      }
      
      if (conversations) {
        const conversationIds = new Set(conversations.map(c => c._id));
        messages = messages.filter(msg => conversationIds.has(msg.conversationId));
      }
    }

    // Apply additional filters
    const filtered = messages.filter((msg) => {
      if (args.flaggedOnly && !msg.metadata?.flagged) return false;
      return (
        (!args.dateFrom || parseInt(msg.timestamp) >= args.dateFrom) &&
        (!args.dateTo || parseInt(msg.timestamp) <= args.dateTo)
      );
    });
    
    // Sort by timestamp descending and apply limit
    filtered.sort((a, b) => parseInt(b.timestamp) - parseInt(a.timestamp));
    const limited = filtered.slice(0, args.limit || 100);

    return limited;
  },
});

/**
 * Internal helper to log a message without requiring client auth.
 * Used by device/gateway pipelines to persist transcripts and replies.
 */
export const logMessage = internalMutation({
  args: {
    conversationId: v.id("conversations"),
    content: v.string(),
    role: v.union(v.literal("user"), v.literal("toy"), v.literal("system")),
    audioUrl: v.optional(v.string()),
    metadata: v.optional(v.object({
      sentiment: v.optional(v.string()),
      safetyScore: v.optional(v.number()),
      flagged: v.optional(v.boolean()),
      topics: v.optional(v.array(v.string())),
      educationalValue: v.optional(v.number()),
      emotionalTone: v.optional(v.string()),
      safetyFlags: v.optional(v.array(v.string())),
    })),
  },
  handler: async (ctx, args) => {
    const conversation = await ctx.db.get(args.conversationId);
    if (!conversation) throw new Error("Conversation not found");

    const messageId = await ctx.db.insert("messages", {
      conversationId: args.conversationId,
      role: args.role,
      content: args.content,
      audioUrl: args.audioUrl,
      metadata: args.metadata,
      timestamp: Date.now().toString(),
    });

    // Update counters on the conversation.
    const flaggedMessages = args.metadata?.flagged ? conversation.flaggedMessages + 1 : conversation.flaggedMessages;
    await ctx.db.patch(args.conversationId, {
      messageCount: conversation.messageCount + 1,
      flaggedMessages,
    });

    return messageId;
  },
});

/**
 * Internal maintenance job to delete messages older than 48 hours.
 * Deletes in small batches to stay within execution limits and maintains
 * conversation counters for integrity.
 */
export const deleteOldMessages = internalMutation({
  args: {
    batchSize: v.optional(v.number()),
  },
  handler: async (ctx, { batchSize }) => {
    const BATCH = Math.max(1, Math.min(batchSize ?? 500, 1000));
    const cutoff = Date.now() - 48 * 60 * 60 * 1000;
    const cutoffStr = cutoff.toString();

    const oldMessages = await ctx.db
      .query("messages")
      .withIndex("by_timestamp", (q) => q.lt("timestamp", cutoffStr))
      .take(BATCH);

    for (const msg of oldMessages) {
      // Adjust conversation counters if possible.
      const conv = await ctx.db.get(msg.conversationId);
      if (conv) {
        await ctx.db.patch(conv._id, {
          messageCount: Math.max(0, conv.messageCount - 1),
          flaggedMessages: Math.max(0, conv.flaggedMessages - (msg.metadata?.flagged ? 1 : 0)),
        });
      }
      await ctx.db.delete(msg._id);
    }

    return { deletedCount: oldMessages.length, cutoff: cutoff };
  },
});
</file>

<file path="convex/README.md">
# Welcome to your Convex functions directory!

Write your Convex functions here.
See https://docs.convex.dev/functions for more.

A query function that takes two arguments looks like:

```ts
// convex/myFunctions.ts
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

Using this query function in a React component looks like:

```ts
const data = useQuery(api.myFunctions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

A mutation function looks like:

```ts
// convex/myFunctions.ts
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get(id);
  },
});
```

Using this mutation function in a React component looks like:

```ts
const mutation = useMutation(api.myFunctions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

Use the Convex CLI to push your functions to a deployment. See everything
the Convex CLI can do by running `npx convex -h` in your project root
directory. To learn more, launch the docs with `npx convex docs`.
</file>

<file path="convex/schema.ts">
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

//  IMPORTANT: BetterAuth tables are automatically managed by the component
// Do NOT define users, sessions, accounts, or verifications tables here
// The BetterAuth component injects these automatically via app.use(betterAuth) in convex.config.ts

// Pommai-specific tables only
const schema = defineSchema({
  // Application-specific user data
  // This complements the BetterAuth users table with app-specific fields
  users: defineTable({
    // No need to duplicate email, name, etc. - those are in BetterAuth's users table
    // Just add app-specific fields if needed
    email: v.string(),
    emailVerified: v.boolean(),
    name: v.optional(v.string()),
    image: v.optional(v.string()),
    createdAt: v.string(),
    updatedAt: v.string(),
  }).index("email", ["email"]),
  
  // Toy management tables
  toys: defineTable({
    name: v.string(),
    type: v.string(), // "bear", "rabbit", "dragon", "robot", "custom"
    creatorId: v.id("users"),
    isForKids: v.boolean(), // Critical flag that enables Guardian Mode
    ageGroup: v.optional(v.union(v.literal("3-5"), v.literal("6-8"), v.literal("9-12"))), // Required if isForKids
    voiceId: v.string(),
    personalityPrompt: v.string(),
    knowledgeBaseId: v.optional(v.id("knowledgeBases")),
    agentThreadId: v.optional(v.string()),
    
    // Guardian Mode specific fields (only when isForKids = true)
    guardianId: v.optional(v.id("users")), // Parent managing the toy
    safetyLevel: v.optional(v.union(v.literal("strict"), v.literal("moderate"), v.literal("relaxed"))),
    contentFilters: v.optional(v.object({
      enabledCategories: v.array(v.string()),
      customBlockedTopics: v.array(v.string()),
    })),
    
    // Personality traits
    personalityTraits: v.object({
      traits: v.array(v.string()), // max 3 traits
      speakingStyle: v.object({
        vocabulary: v.union(v.literal("simple"), v.literal("moderate"), v.literal("advanced")),
        sentenceLength: v.union(v.literal("short"), v.literal("medium"), v.literal("long")),
        usesSoundEffects: v.boolean(),
        catchPhrases: v.array(v.string()),
      }),
      interests: v.array(v.string()),
      favoriteTopics: v.array(v.string()),
      avoidTopics: v.array(v.string()),
      behavior: v.object({
        encouragesQuestions: v.boolean(),
        tellsStories: v.boolean(),
        playsGames: v.boolean(),
        educationalFocus: v.number(), // 0-10 slider
        imaginationLevel: v.number(), // 0-10 slider
      }),
    }),
    
    // Device management
    assignedDevices: v.array(v.string()), // Can be assigned to multiple devices
    status: v.union(v.literal("active"), v.literal("paused"), v.literal("archived")),
    
    // Metadata
    isPublic: v.boolean(), // Can be shared in community
    tags: v.array(v.string()),
    usageCount: v.number(),
    createdAt: v.string(),
    lastActiveAt: v.string(),
    lastModifiedAt: v.string(),
  })
    .index("by_creator", ["creatorId"])
    .index("by_guardian", ["guardianId"])
    .index("for_kids", ["isForKids"]),
  
  // Knowledge base for toys
  knowledgeBases: defineTable({
    toyId: v.id("toys"),
    toyBackstory: v.object({
      origin: v.string(),
      personality: v.string(),
      specialAbilities: v.array(v.string()),
      favoriteThings: v.array(v.string()),
    }),
    familyInfo: v.optional(v.object({
      members: v.array(v.object({
        name: v.string(),
        relationship: v.string(),
        facts: v.array(v.string()),
      })),
      pets: v.array(v.object({
        name: v.string(),
        type: v.string(),
        facts: v.array(v.string()),
      })),
      importantDates: v.array(v.object({
        date: v.string(),
        event: v.string(),
      })),
    })),
    customFacts: v.array(v.object({
      category: v.string(),
      fact: v.string(),
      importance: v.union(v.literal("high"), v.literal("medium"), v.literal("low")),
    })),
    memories: v.array(v.object({
      id: v.string(),
      description: v.string(),
      date: v.string(),
      participants: v.array(v.string()),
      autoGenerated: v.boolean(),
    })),
    // Vector storage reference
    vectorStoreId: v.optional(v.string()), // Reference to external vector DB
    createdAt: v.string(),
    updatedAt: v.string(),
  }).index("by_toy", ["toyId"]),
  
  // Voice library
  voices: defineTable({
    name: v.string(),
    description: v.string(),
    language: v.string(),
    accent: v.optional(v.string()),
    ageGroup: v.string(),
    gender: v.union(v.literal("male"), v.literal("female"), v.literal("neutral")),
    previewUrl: v.string(),
    provider: v.union(v.literal("11labs"), v.literal("azure"), v.literal("custom")),
    externalVoiceId: v.string(), // Provider's voice ID
    tags: v.array(v.string()),
    isPremium: v.boolean(),
    isPublic: v.boolean(),
    uploadedBy: v.optional(v.id("users")),
    usageCount: v.number(),
    averageRating: v.number(),
    createdAt: v.string(),
  })
    .index("by_uploader", ["uploadedBy"])
    .index("is_public", ["isPublic"]) 
    .index("by_external", ["externalVoiceId"]),
  
  // Toy assignment to devices/children
  toyAssignments: defineTable({
    toyId: v.id("toys"),
    deviceId: v.optional(v.string()),
    childId: v.optional(v.id("children")),
    assignedAt: v.string(),
    assignedBy: v.id("users"),
    isActive: v.boolean(),
  })
    .index("by_toy", ["toyId"])
    .index("by_device", ["deviceId"])
    .index("by_child", ["childId"]),
  
  // Conversations with toys
  conversations: defineTable({
    toyId: v.id("toys"),
    childId: v.optional(v.id("children")),
    userId: v.optional(v.id("users")), // For non-child users
    sessionId: v.string(),
    startTime: v.string(),
    endTime: v.optional(v.string()),
    duration: v.number(), // in seconds
    messageCount: v.number(),
    flaggedMessages: v.number(),
    sentiment: v.union(v.literal("positive"), v.literal("neutral"), v.literal("negative")),
    topics: v.array(v.string()),
    location: v.union(v.literal("toy"), v.literal("web"), v.literal("app")),
    deviceId: v.optional(v.string()),
  })
    .index("by_toy", ["toyId"])
    .index("by_child", ["childId"])
    .index("by_user", ["userId"])
    .index("by_session", ["sessionId"]),
  
  // Messages within conversations
  messages: defineTable({
    conversationId: v.id("conversations"),
    role: v.union(v.literal("user"), v.literal("toy"), v.literal("system")),
    content: v.string(),
    timestamp: v.string(),
    audioUrl: v.optional(v.string()),
    metadata: v.optional(v.object({
      sentiment: v.optional(v.string()),
      safetyScore: v.optional(v.number()),
      flagged: v.optional(v.boolean()),
      topics: v.optional(v.array(v.string())),
      educationalValue: v.optional(v.number()),
      emotionalTone: v.optional(v.string()),
      safetyFlags: v.optional(v.array(v.string())),
    })),
  })
    .index("by_conversation", ["conversationId"])
    .index("by_timestamp", ["timestamp"]),
  
  // Parent/child relationships
  children: defineTable({
    parentId: v.id("users"),
    name: v.string(),
    birthDate: v.string(),
    voiceProfile: v.optional(v.string()),
    avatar: v.optional(v.string()),
    settings: v.object({
      contentLevel: v.union(v.literal("toddler"), v.literal("preschool"), v.literal("elementary")),
      safetyLevel: v.union(v.literal("strict"), v.literal("moderate"), v.literal("relaxed")),
      allowedTopics: v.array(v.string()),
      blockedWords: v.array(v.string()),
      dailyTimeLimit: v.optional(v.number()), // in minutes
      bedtimeRestrictions: v.optional(v.object({
        startTime: v.string(),
        endTime: v.string(),
      })),
    }),
    createdAt: v.string(),
    updatedAt: v.string(),
  }).index("parentId", ["parentId"]),
  
  
  // Device management
  devices: defineTable({
    parentId: v.id("users"),
    deviceId: v.string(),
    name: v.string(),
    type: v.union(v.literal("raspberry_pi"), v.literal("web"), v.literal("mobile")),
    lastSeen: v.string(),
    isActive: v.boolean(),
    settings: v.object({
      volumeLevel: v.number(),
      ledBrightness: v.number(),
      wakeSensitivity: v.number(),
    }),
  })
    .index("parentId", ["parentId"])
    .index("deviceId", ["deviceId"]),
  
  // Content moderation logs
  moderationLogs: defineTable({
    messageId: v.id("messages"),
    flagType: v.string(),
    severity: v.union(v.literal("low"), v.literal("medium"), v.literal("high")),
    details: v.string(),
    action: v.string(),
    timestamp: v.string(),
  }).index("messageId", ["messageId"]),
  
  // RAG Knowledge storage for toys
  toyKnowledge: defineTable({
    toyId: v.id("toys"),
    content: v.string(),
    type: v.union(
      v.literal("backstory"),
      v.literal("personality"),
      v.literal("facts"),
      v.literal("memories"),
      v.literal("rules"),
      v.literal("preferences"),
      v.literal("relationships")
    ),
    metadata: v.optional(v.object({
      source: v.string(),
      importance: v.number(), // 0-1 scale
      tags: v.array(v.string()),
      expiresAt: v.optional(v.number()), // For temporary knowledge
    })),
    createdAt: v.number(),
    updatedAt: v.number(),
  })
    .index("by_toy", ["toyId"])
    .index("by_type", ["type"])
    .index("by_created", ["createdAt"]),
});

export default schema;
</file>

<file path="convex/test_knowledge.py">
"""
Tests for Knowledge Base Management in Convex RAG System
"""

import pytest
from typing import Dict, List, Any
import json
from datetime import datetime

# Mock Convex client for testing
class MockConvexClient:
    def __init__(self):
        self.knowledge_store = {}
        self.threads = {}
        self.toys = {
            "toy_123": {
                "id": "toy_123",
                "name": "Benny Bear",
                "type": "bear",
                "isForKids": True,
                "ageGroup": "3-5",
                "personalityPrompt": "A friendly bear who loves stories"
            }
        }
    
    async def mutation(self, path: str, args: Dict[str, Any]):
        """Mock mutation handler"""
        if path == "knowledge.addToyKnowledge":
            return self._add_knowledge(args)
        elif path == "knowledge.updateToyKnowledge":
            return self._update_knowledge(args)
        elif path == "knowledge.deleteToyKnowledge":
            return self._delete_knowledge(args)
        elif path == "knowledge.clearToyKnowledge":
            return self._clear_knowledge(args)
        elif path == "agents.saveKnowledgeMessage":
            return self._save_knowledge_message(args)
        return None
    
    async def query(self, path: str, args: Dict[str, Any]):
        """Mock query handler"""
        if path == "knowledge.getToyKnowledge":
            return self._get_knowledge(args)
        elif path == "knowledge.getToyKnowledgeStats":
            return self._get_stats(args)
        elif path == "agents.getThreadByToyId":
            return self._get_thread(args)
        return None
    
    async def action(self, path: str, args: Dict[str, Any]):
        """Mock action handler"""
        if path == "knowledge.importToyKnowledge":
            return self._import_knowledge(args)
        elif path == "knowledge.searchToyKnowledge":
            return self._search_knowledge(args)
        return None
    
    def _add_knowledge(self, args: Dict[str, Any]) -> str:
        """Add knowledge to store"""
        knowledge_id = f"knowledge_{len(self.knowledge_store) + 1}"
        self.knowledge_store[knowledge_id] = {
            "id": knowledge_id,
            "toyId": args["toyId"],
            "content": args["content"],
            "type": args["type"],
            "metadata": args.get("metadata", {
                "source": "manual",
                "importance": 0.5,
                "tags": []
            }),
            "createdAt": datetime.now().timestamp(),
            "updatedAt": datetime.now().timestamp()
        }
        return knowledge_id
    
    def _get_knowledge(self, args: Dict[str, Any]) -> List[Dict]:
        """Get knowledge for a toy"""
        results = []
        for item in self.knowledge_store.values():
            if item["toyId"] == args["toyId"]:
                if not args.get("type") or item["type"] == args["type"]:
                    results.append(item)
        
        # Apply limit
        limit = args.get("limit", 100)
        return results[:limit]
    
    def _search_knowledge(self, args: Dict[str, Any]) -> List[Dict]:
        """Search knowledge using simple text matching"""
        query_lower = args["query"].lower()
        results = []
        
        for item in self.knowledge_store.values():
            if item["toyId"] == args["toyId"]:
                relevance = self._calculate_relevance(item["content"], query_lower)
                if relevance >= args.get("minRelevance", 0.3):
                    results.append({
                        **item,
                        "relevance": relevance
                    })
        
        # Sort by relevance and apply limit
        results.sort(key=lambda x: x["relevance"], reverse=True)
        return results[:args.get("limit", 10)]
    
    def _calculate_relevance(self, content: str, query: str) -> float:
        """Simple relevance calculation"""
        content_lower = content.lower()
        query_words = query.split()
        matches = sum(1 for word in query_words if word in content_lower)
        return matches / len(query_words) if query_words else 0
    
    def _import_knowledge(self, args: Dict[str, Any]) -> Dict:
        """Import multiple knowledge documents"""
        total_chunks = 0
        successful_chunks = 0
        errors = []
        
        for doc in args["documents"]:
            try:
                # Simple chunking
                chunk_size = args.get("chunkSize", 500)
                chunks = [doc["content"][i:i+chunk_size] 
                         for i in range(0, len(doc["content"]), chunk_size)]
                total_chunks += len(chunks)
                
                for chunk in chunks:
                    try:
                        self._add_knowledge({
                            "toyId": args["toyId"],
                            "content": chunk,
                            "type": doc["type"],
                            "metadata": {
                                "source": doc["source"],
                                "importance": 0.5,
                                "tags": []
                            }
                        })
                        successful_chunks += 1
                    except Exception as e:
                        errors.append(str(e))
            except Exception as e:
                errors.append(f"Failed to process document: {e}")
        
        return {
            "success": len(errors) == 0,
            "totalChunks": total_chunks,
            "successfulChunks": successful_chunks,
            "errors": errors
        }
    
    def _get_stats(self, args: Dict[str, Any]) -> Dict:
        """Get knowledge statistics"""
        knowledge = self._get_knowledge({"toyId": args["toyId"]})
        
        stats = {
            "total": len(knowledge),
            "byType": {},
            "avgImportance": 0,
            "totalCharacters": 0,
            "topTags": []
        }
        
        if knowledge:
            # Count by type
            for item in knowledge:
                type_name = item["type"]
                stats["byType"][type_name] = stats["byType"].get(type_name, 0) + 1
                stats["totalCharacters"] += len(item["content"])
            
            # Calculate average importance
            total_importance = sum(item.get("metadata", {}).get("importance", 0.5) 
                                  for item in knowledge)
            stats["avgImportance"] = total_importance / len(knowledge)
        
        return stats


class TestKnowledgeManagement:
    """Test knowledge base management functions"""
    
    @pytest.fixture
    def client(self):
        return MockConvexClient()
    
    @pytest.mark.asyncio
    async def test_add_toy_knowledge(self, client):
        """Test adding knowledge to a toy"""
        # Add backstory knowledge
        knowledge_id = await client.mutation("knowledge.addToyKnowledge", {
            "toyId": "toy_123",
            "content": "Benny Bear was born in the magical Rainbow Forest",
            "type": "backstory",
            "metadata": {
                "source": "manual",
                "importance": 0.8,
                "tags": ["origin", "fantasy"]
            }
        })
        
        assert knowledge_id is not None
        assert knowledge_id.startswith("knowledge_")
        
        # Verify knowledge was added
        knowledge = await client.query("knowledge.getToyKnowledge", {
            "toyId": "toy_123",
            "type": "backstory"
        })
        
        assert len(knowledge) == 1
        assert knowledge[0]["content"] == "Benny Bear was born in the magical Rainbow Forest"
        assert knowledge[0]["type"] == "backstory"
    
    @pytest.mark.asyncio
    async def test_import_bulk_knowledge(self, client):
        """Test bulk import of knowledge documents"""
        documents = [
            {
                "content": "Benny loves honey and berries. He enjoys playing hide and seek.",
                "type": "preferences",
                "source": "character_sheet"
            },
            {
                "content": "Benny is friends with Ruby Rabbit and Oliver Owl.",
                "type": "relationships",
                "source": "character_sheet"
            }
        ]
        
        result = await client.action("knowledge.importToyKnowledge", {
            "toyId": "toy_123",
            "documents": documents,
            "chunkSize": 50  # Small chunks for testing
        })
        
        assert result["success"] is True
        assert result["totalChunks"] == 3  # Two documents chunked
        assert result["successfulChunks"] == 3
        assert len(result["errors"]) == 0
    
    @pytest.mark.asyncio
    async def test_search_knowledge(self, client):
        """Test searching toy knowledge"""
        # Add some knowledge first
        await client.mutation("knowledge.addToyKnowledge", {
            "toyId": "toy_123",
            "content": "Benny loves to tell bedtime stories about the stars",
            "type": "personality"
        })
        
        await client.mutation("knowledge.addToyKnowledge", {
            "toyId": "toy_123",
            "content": "Benny's favorite game is counting clouds",
            "type": "preferences"
        })
        
        # Search for knowledge
        results = await client.action("knowledge.searchToyKnowledge", {
            "toyId": "toy_123",
            "query": "stories stars",
            "limit": 5
        })
        
        assert len(results) > 0
        assert results[0]["relevance"] > 0
        assert "stories" in results[0]["content"].lower()
    
    @pytest.mark.asyncio
    async def test_knowledge_types(self, client):
        """Test different knowledge types"""
        knowledge_types = [
            ("backstory", "Born in Rainbow Forest"),
            ("personality", "Friendly and curious"),
            ("facts", "Loves honey"),
            ("memories", "First met Ruby at the pond"),
            ("rules", "Always be kind to friends"),
            ("preferences", "Prefers sunny days"),
            ("relationships", "Best friend is Ruby")
        ]
        
        for k_type, content in knowledge_types:
            await client.mutation("knowledge.addToyKnowledge", {
                "toyId": "toy_123",
                "content": content,
                "type": k_type
            })
        
        # Get all knowledge
        all_knowledge = await client.query("knowledge.getToyKnowledge", {
            "toyId": "toy_123"
        })
        
        assert len(all_knowledge) == len(knowledge_types)
        
        # Check each type
        for k_type, _ in knowledge_types:
            typed_knowledge = await client.query("knowledge.getToyKnowledge", {
                "toyId": "toy_123",
                "type": k_type
            })
            assert len(typed_knowledge) == 1
            assert typed_knowledge[0]["type"] == k_type
    
    @pytest.mark.asyncio
    async def test_knowledge_statistics(self, client):
        """Test getting knowledge statistics"""
        # Add various knowledge items
        for i in range(5):
            await client.mutation("knowledge.addToyKnowledge", {
                "toyId": "toy_123",
                "content": f"Test content {i}",
                "type": "facts" if i < 3 else "personality",
                "metadata": {
                    "importance": 0.5 + (i * 0.1),
                    "tags": ["test"]
                }
            })
        
        # Get statistics
        stats = await client.query("knowledge.getToyKnowledgeStats", {
            "toyId": "toy_123"
        })
        
        assert stats["total"] == 5
        assert stats["byType"]["facts"] == 3
        assert stats["byType"]["personality"] == 2
        assert stats["avgImportance"] > 0
        assert stats["totalCharacters"] > 0
    
    @pytest.mark.asyncio
    async def test_knowledge_chunking(self, client):
        """Test smart chunking of long content"""
        long_content = (
            "Benny Bear loves adventure. "
            "He explores the forest daily. "
            "His favorite spot is the honey tree. "
            "He shares stories with friends. "
            "Every night he looks at stars."
        )
        
        result = await client.action("knowledge.importToyKnowledge", {
            "toyId": "toy_123",
            "documents": [{
                "content": long_content,
                "type": "backstory",
                "source": "test"
            }],
            "chunkSize": 30  # Force chunking
        })
        
        assert result["success"] is True
        assert result["totalChunks"] > 1  # Should be chunked
        
        # Verify chunks were created
        knowledge = await client.query("knowledge.getToyKnowledge", {
            "toyId": "toy_123",
            "type": "backstory"
        })
        
        assert len(knowledge) > 1
        
        # Reconstruct content from chunks
        reconstructed = " ".join([k["content"] for k in knowledge])
        # Content should be preserved (though might have slight differences in spacing)
        assert all(word in reconstructed for word in long_content.split())
    
    @pytest.mark.asyncio
    async def test_knowledge_relevance_filtering(self, client):
        """Test relevance filtering in search"""
        # Add knowledge with varying relevance
        knowledge_items = [
            "Benny loves playing with toy trains",
            "Ruby Rabbit is Benny's best friend",
            "The forest has many tall trees",
            "Benny's favorite toy is a red train"
        ]
        
        for content in knowledge_items:
            await client.mutation("knowledge.addToyKnowledge", {
                "toyId": "toy_123",
                "content": content,
                "type": "facts"
            })
        
        # Search with high relevance threshold
        results = await client.action("knowledge.searchToyKnowledge", {
            "toyId": "toy_123",
            "query": "toy train",
            "minRelevance": 0.5
        })
        
        # Should only return highly relevant results
        assert all("toy" in r["content"].lower() or "train" in r["content"].lower() 
                  for r in results)
        assert all(r["relevance"] >= 0.5 for r in results)
    
    @pytest.mark.asyncio
    async def test_knowledge_metadata(self, client):
        """Test knowledge metadata handling"""
        metadata = {
            "source": "user_input",
            "importance": 0.9,
            "tags": ["personality", "core", "friendly"],
            "expiresAt": (datetime.now().timestamp() + 86400) * 1000  # 24 hours
        }
        
        knowledge_id = await client.mutation("knowledge.addToyKnowledge", {
            "toyId": "toy_123",
            "content": "Benny is always cheerful and helpful",
            "type": "personality",
            "metadata": metadata
        })
        
        # Retrieve and check metadata
        knowledge = await client.query("knowledge.getToyKnowledge", {
            "toyId": "toy_123"
        })
        
        item = next(k for k in knowledge if k["id"] == knowledge_id)
        assert item["metadata"]["importance"] == 0.9
        assert "personality" in item["metadata"]["tags"]
        assert item["metadata"]["source"] == "user_input"


class TestKnowledgeIntegration:
    """Test integration with Agent system"""
    
    @pytest.fixture
    def client(self):
        return MockConvexClient()
    
    @pytest.mark.asyncio
    async def test_knowledge_in_agent_context(self, client):
        """Test that knowledge is included in agent context"""
        # Add relevant knowledge
        await client.mutation("knowledge.addToyKnowledge", {
            "toyId": "toy_123",
            "content": "Benny loves to tell stories about space adventures",
            "type": "personality"
        })
        
        await client.mutation("knowledge.addToyKnowledge", {
            "toyId": "toy_123",
            "content": "Benny's favorite planet is Mars because it's red like strawberries",
            "type": "facts"
        })
        
        # Search for relevant knowledge (simulating what agent would do)
        relevant = await client.action("knowledge.searchToyKnowledge", {
            "toyId": "toy_123",
            "query": "tell me about space",
            "limit": 3
        })
        
        assert len(relevant) > 0
        assert any("space" in k["content"].lower() or "planet" in k["content"].lower() 
                  for k in relevant)
    
    @pytest.mark.asyncio
    async def test_knowledge_importance_ordering(self, client):
        """Test that high-importance knowledge is prioritized"""
        # Add knowledge with different importance levels
        knowledge_items = [
            ("Critical safety rule", "rules", 1.0),
            ("Backstory detail", "backstory", 0.8),
            ("Random fact", "facts", 0.3),
            ("Core personality", "personality", 0.9)
        ]
        
        for content, k_type, importance in knowledge_items:
            await client.mutation("knowledge.addToyKnowledge", {
                "toyId": "toy_123",
                "content": content,
                "type": k_type,
                "metadata": {"importance": importance}
            })
        
        # Get all knowledge
        all_knowledge = await client.query("knowledge.getToyKnowledge", {
            "toyId": "toy_123"
        })
        
        # Check that high-importance items exist
        high_importance = [k for k in all_knowledge 
                          if k.get("metadata", {}).get("importance", 0) >= 0.8]
        
        assert len(high_importance) >= 3
        assert any(k["type"] == "rules" for k in high_importance)


# Run tests
if __name__ == "__main__":
    pytest.main([__file__, "-v"])
</file>

<file path="convex/toys.ts">
import { v } from "convex/values";
import { mutation, query } from "./_generated/server";

/**
 * Create a new toy
 * This mutation handles the creation of both general toys and "For Kids" toys
 */
export const createToy = mutation({
  args: {
    name: v.string(),
    type: v.string(),
    isForKids: v.boolean(),
    ageGroup: v.optional(v.union(v.literal("3-5"), v.literal("6-8"), v.literal("9-12"))),
    voiceId: v.string(),
    personalityPrompt: v.string(),
    personalityTraits: v.object({
      traits: v.array(v.string()),
      speakingStyle: v.object({
        vocabulary: v.union(v.literal("simple"), v.literal("moderate"), v.literal("advanced")),
        sentenceLength: v.union(v.literal("short"), v.literal("medium"), v.literal("long")),
        usesSoundEffects: v.boolean(),
        catchPhrases: v.array(v.string()),
      }),
      interests: v.array(v.string()),
      favoriteTopics: v.array(v.string()),
      avoidTopics: v.array(v.string()),
      behavior: v.object({
        encouragesQuestions: v.boolean(),
        tellsStories: v.boolean(),
        playsGames: v.boolean(),
        educationalFocus: v.number(),
        imaginationLevel: v.number(),
      }),
    }),
    safetyLevel: v.optional(v.union(v.literal("strict"), v.literal("moderate"), v.literal("relaxed"))),
    contentFilters: v.optional(v.object({
      enabledCategories: v.array(v.string()),
      customBlockedTopics: v.array(v.string()),
    })),
    isPublic: v.boolean(),
    tags: v.array(v.string()),
  },
  handler: async (ctx, args) => {
    // Get current user
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Not authenticated");
    }

    // For "For Kids" toys, age group and safety settings are required
    if (args.isForKids && !args.ageGroup) {
      throw new Error("Age group is required for toys designated 'For Kids'");
    }

    if (args.isForKids && !args.safetyLevel) {
      throw new Error("Safety level is required for toys designated 'For Kids'");
    }

    // Validate personality traits (max 3)
    if (args.personalityTraits.traits.length > 3) {
      throw new Error("Maximum 3 personality traits allowed");
    }

    const now = new Date().toISOString();

    // Get user from auth
    const user = await ctx.db
      .query("users")
      .withIndex("email", (q) => q.eq("email", identity.email!))
      .first();
    
    if (!user) {
      throw new Error("User not found");
    }

    const toyId = await ctx.db.insert("toys", {
      name: args.name,
      type: args.type,
      creatorId: user._id,
      isForKids: args.isForKids,
      ageGroup: args.ageGroup,
      voiceId: args.voiceId,
      personalityPrompt: args.personalityPrompt,
      personalityTraits: args.personalityTraits,
      guardianId: args.isForKids ? user._id : undefined,
      safetyLevel: args.safetyLevel,
      contentFilters: args.contentFilters,
      assignedDevices: [],
      status: "active",
      isPublic: args.isPublic,
      tags: args.tags,
      usageCount: 0,
      createdAt: now,
      lastActiveAt: now,
      lastModifiedAt: now,
    });

    return toyId;
  },
});

// Get all toys for a user
export const getUserToys = query({
  args: {
    userId: v.optional(v.id("users")),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) return [];

    // TODO: Get actual user ID from auth
    const userId = args.userId;
    if (!userId) return [];

    const toys = await ctx.db
      .query("toys")
      .withIndex("by_creator", (q) => q.eq("creatorId", userId))
      .order("desc")
      .collect();

    // Get additional stats for each toy
    const toysWithStats = await Promise.all(
      toys.map(async (toy) => {
        // Get conversation count
        const conversations = await ctx.db
          .query("conversations")
          .withIndex("by_toy", (q) => q.eq("toyId", toy._id))
          .collect();

        // Get last active time from conversations
        const lastActive = conversations.length > 0
          ? Math.max(...conversations.map(c => parseInt(c.startTime)))
          : new Date(toy.createdAt).getTime();

        // Count total messages
        let totalMessages = 0;
        for (const conv of conversations) {
          const messages = await ctx.db
            .query("messages")
            .withIndex("by_conversation", (q) => q.eq("conversationId", conv._id))
            .collect();
          totalMessages += messages.length;
        }

        return {
          ...toy,
          conversationCount: conversations.length,
          messageCount: totalMessages,
          lastActiveAt: lastActive,
        };
      })
    );

    return toysWithStats;
  },
});


/**
 * Get all toys created by the current user
 */
export const getMyToys = query({
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      return [];
    }

    // Get user from auth
    const user = await ctx.db
      .query("users")
      .withIndex("email", (q) => q.eq("email", identity.email!))
      .first();
    
    if (!user) {
      return [];
    }

    const toys = await ctx.db
      .query("toys")
      .withIndex("by_creator", (q) => q.eq("creatorId", user._id))
      .collect();

    return toys;
  },
});

/**
 * Get toys managed as guardian (For Kids toys)
 */
export const getGuardianToys = query({
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      return [];
    }

    // Get user from auth
    const user = await ctx.db
      .query("users")
      .withIndex("email", (q) => q.eq("email", identity.email!))
      .first();
    
    if (!user) {
      return [];
    }

    const toys = await ctx.db
      .query("toys")
      .withIndex("by_guardian", (q) => q.eq("guardianId", user._id))
      .collect();

    return toys;
  },
});

/**
 * Get a specific toy by ID
 */
export const getToy = query({
  args: { toyId: v.id("toys") },
  handler: async (ctx, args) => {
    const toy = await ctx.db.get(args.toyId);
    
    if (!toy) {
      throw new Error("Toy not found");
    }

    // Check if user has access to this toy
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Not authenticated");
    }

    // Get user from auth
    const user = await ctx.db
      .query("users")
      .withIndex("email", (q) => q.eq("email", identity.email!))
      .first();
    
    if (!user) {
      throw new Error("User not found");
    }

    if (toy.creatorId !== user._id && toy.guardianId !== user._id && !toy.isPublic) {
      throw new Error("Access denied");
    }

    return toy;
  },
});

/**
 * Update toy personality and settings
 */
export const updateToy = mutation({
  args: {
    toyId: v.id("toys"),
    name: v.optional(v.string()),
    type: v.optional(v.string()),
    personalityPrompt: v.optional(v.string()),
    personalityTraits: v.optional(v.object({
      traits: v.array(v.string()),
      speakingStyle: v.object({
        vocabulary: v.union(v.literal("simple"), v.literal("moderate"), v.literal("advanced")),
        sentenceLength: v.union(v.literal("short"), v.literal("medium"), v.literal("long")),
        usesSoundEffects: v.boolean(),
        catchPhrases: v.array(v.string()),
      }),
      interests: v.array(v.string()),
      favoriteTopics: v.array(v.string()),
      avoidTopics: v.array(v.string()),
      behavior: v.object({
        encouragesQuestions: v.boolean(),
        tellsStories: v.boolean(),
        playsGames: v.boolean(),
        educationalFocus: v.number(),
        imaginationLevel: v.number(),
      }),
    })),
    voiceId: v.optional(v.string()),
    safetyLevel: v.optional(v.union(v.literal("strict"), v.literal("moderate"), v.literal("relaxed"))),
    contentFilters: v.optional(v.object({
      enabledCategories: v.array(v.string()),
      customBlockedTopics: v.array(v.string()),
    })),
    tags: v.optional(v.array(v.string())),
  },
  handler: async (ctx, args) => {
    const { toyId, ...updates } = args;
    
    // Get the toy and verify ownership
    const toy = await ctx.db.get(toyId);
    if (!toy) {
      throw new Error("Toy not found");
    }

    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Not authenticated");
    }

    // Get user from auth
    const user = await ctx.db
      .query("users")
      .withIndex("email", (q) => q.eq("email", identity.email!))
      .first();
    
    if (!user) {
      throw new Error("User not found");
    }

    if (toy.creatorId !== user._id && toy.guardianId !== user._id) {
      throw new Error("Only the creator or guardian can update this toy");
    }

    // Validate personality traits if provided
    if (updates.personalityTraits && updates.personalityTraits.traits.length > 3) {
      throw new Error("Maximum 3 personality traits allowed");
    }

    // Update the toy
    await ctx.db.patch(toyId, {
      ...updates,
      lastModifiedAt: new Date().toISOString(),
    });

    return toyId;
  },
});

/**
 * Change toy status (active, paused, archived)
 */
export const updateToyStatus = mutation({
  args: {
    toyId: v.id("toys"),
    status: v.union(v.literal("active"), v.literal("paused"), v.literal("archived")),
  },
  handler: async (ctx, args) => {
    const toy = await ctx.db.get(args.toyId);
    if (!toy) {
      throw new Error("Toy not found");
    }

    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Not authenticated");
    }

    // Get user from auth
    const user = await ctx.db
      .query("users")
      .withIndex("email", (q) => q.eq("email", identity.email!))
      .first();
    
    if (!user) {
      throw new Error("User not found");
    }

    if (toy.creatorId !== user._id && toy.guardianId !== user._id) {
      throw new Error("Only the creator or guardian can update toy status");
    }

    await ctx.db.patch(args.toyId, {
      status: args.status,
      lastModifiedAt: new Date().toISOString(),
    });

    return args.toyId;
  },
});

/**
 * Assign toy to a device
 */
export const assignToyToDevice = mutation({
  args: {
    toyId: v.id("toys"),
    deviceId: v.string(),
  },
  handler: async (ctx, args) => {
    const toy = await ctx.db.get(args.toyId);
    if (!toy) {
      throw new Error("Toy not found");
    }

    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Not authenticated");
    }

    // Get user from auth
    const user = await ctx.db
      .query("users")
      .withIndex("email", (q) => q.eq("email", identity.email!))
      .first();
    
    if (!user) {
      throw new Error("User not found");
    }

    if (toy.creatorId !== user._id && toy.guardianId !== user._id) {
      throw new Error("Only the creator or guardian can assign devices");
    }

    // Check if device already has this toy
    const alreadyAssigned = (toy.assignedDevices || []).includes(args.deviceId);
    if (!alreadyAssigned) {
      await ctx.db.patch(args.toyId, {
        assignedDevices: [...(toy.assignedDevices || []), args.deviceId],
        lastModifiedAt: new Date().toISOString(),
      });

      // Create assignment record
      await ctx.db.insert("toyAssignments", {
        toyId: args.toyId,
        deviceId: args.deviceId,
        childId: undefined,
        assignedAt: new Date().toISOString(),
        assignedBy: user._id,
        isActive: true,
      });
    }

    return args.toyId;
  },
});

/**
 * Duplicate a toy with a new name
 */
export const duplicateToy = mutation({
  args: {
    toyId: v.id("toys"),
    newName: v.string(),
  },
  handler: async (ctx, args) => {
    const originalToy = await ctx.db.get(args.toyId);
    if (!originalToy) {
      throw new Error("Toy not found");
    }

    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Not authenticated");
    }

    const user = await ctx.db
      .query("users")
      .withIndex("email", (q) => q.eq("email", identity.email!))
      .first();

    if (!user) {
      throw new Error("User not found");
    }

    if (originalToy.creatorId !== user._id && !originalToy.isPublic) {
      throw new Error("Can only duplicate your own toys or public toys");
    }

    const now = new Date().toISOString();
    const { _id, _creationTime, ...toyData } = originalToy as any;

    const newToyId = await ctx.db.insert("toys", {
      ...toyData,
      name: args.newName,
      creatorId: user._id,
      guardianId: originalToy.isForKids ? user._id : undefined,
      assignedDevices: [],
      usageCount: 0,
      status: "active",
      createdAt: now,
      lastActiveAt: now,
      lastModifiedAt: now,
    } as any);

    return newToyId;
  },
});

/**
 * Delete a toy (creator or guardian only)
 */

/**
 * Remove toy from device
 */
export const removeToyFromDevice = mutation({
  args: {
    toyId: v.id("toys"),
    deviceId: v.string(),
  },
  handler: async (ctx, args) => {
    const toy = await ctx.db.get(args.toyId);
    if (!toy) {
      throw new Error("Toy not found");
    }

    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Not authenticated");
    }

    // Get user from auth
    const user = await ctx.db
      .query("users")
      .withIndex("email", (q) => q.eq("email", identity.email!))
      .first();
    
    if (!user) {
      throw new Error("User not found");
    }

    if (toy.creatorId !== user._id && toy.guardianId !== user._id) {
      throw new Error("Only the creator or guardian can manage device assignments");
    }

    // Update toy's assigned devices
    await ctx.db.patch(args.toyId, {
      assignedDevices: toy.assignedDevices.filter(id => id !== args.deviceId),
      lastModifiedAt: new Date().toISOString(),
    });

    // Deactivate assignment record
    const assignment = await ctx.db
      .query("toyAssignments")
      .withIndex("by_toy", (q) => q.eq("toyId", args.toyId))
      .filter((q) => q.eq(q.field("deviceId"), args.deviceId))
      .filter((q) => q.eq(q.field("isActive"), true))
      .first();

    if (assignment) {
      await ctx.db.patch(assignment._id, { isActive: false });
    }

    return args.toyId;
  },
});

/**
 * Duplicate a toy
 */

/**
 * Delete a toy (soft delete by archiving)
 */
export const deleteToy = mutation({
  args: {
    toyId: v.id("toys"),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Not authenticated");

    const toy = await ctx.db.get(args.toyId);
    if (!toy) throw new Error("Toy not found");

    // Get user from auth
    const user = await ctx.db
      .query("users")
      .withIndex("email", (q) => q.eq("email", identity.email!))
      .first();
    
    if (!user) {
      throw new Error("User not found");
    }

    if (toy.creatorId !== user._id && toy.guardianId !== user._id) {
      throw new Error("Only the creator or guardian can delete this toy");
    }

    await ctx.db.delete(args.toyId);
    return { success: true };
  },
});
</file>

<file path="convex/tsconfig.json">
{
  /* This TypeScript project config describes the environment that
   * Convex functions run in and is used to typecheck them.
   * You can modify it, but some settings are required to use Convex.
   */
  "compilerOptions": {
    /* These settings are not required by Convex and can be modified. */
    "allowJs": true,
    "strict": true,
    "moduleResolution": "Bundler",
    "jsx": "react-jsx",
    "skipLibCheck": true,
    "allowSyntheticDefaultImports": true,

    /* These compiler options are required by Convex */
    "target": "ESNext",
    "lib": ["ES2021", "dom"],
    "forceConsistentCasingInFileNames": true,
    "module": "ESNext",
    "isolatedModules": true,
    "noEmit": true
  },
  "include": ["./**/*"],
  "exclude": ["./_generated"]
}
</file>

<file path="convex/voices.ts">
import { v } from "convex/values";
import { mutation, query } from "./_generated/server";

/**
 * Get all public voices available in the library
 */
export const getPublicVoices = query({
  args: {
    language: v.optional(v.string()),
    gender: v.optional(v.union(v.literal("male"), v.literal("female"), v.literal("neutral"))),
    ageGroup: v.optional(v.string()),
    isPremium: v.optional(v.boolean()),
  },
  handler: async (ctx, args) => {
    let voicesQuery = ctx.db
      .query("voices")
      .withIndex("is_public", (q) => q.eq("isPublic", true));

    const voices = await voicesQuery.collect();

    // Apply filters
    let filteredVoices = voices;

    if (args.language) {
      filteredVoices = filteredVoices.filter(v => v.language === args.language);
    }

    if (args.gender) {
      filteredVoices = filteredVoices.filter(v => v.gender === args.gender);
    }

    if (args.ageGroup) {
      filteredVoices = filteredVoices.filter(v => v.ageGroup === args.ageGroup);
    }

    if (args.isPremium !== undefined) {
      filteredVoices = filteredVoices.filter(v => v.isPremium === args.isPremium);
    }

    // Sort by usage count (popular first)
    return filteredVoices.sort((a, b) => b.usageCount - a.usageCount);
  },
});

/**
 * Get user's custom uploaded voices
 */
export const getMyVoices = query({
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      return [];
    }

    const voices = await ctx.db
      .query("voices")
      .withIndex("by_uploader", (q) => q.eq("uploadedBy", identity.subject as any))
      .collect();

    return voices;
  },
});

/**
 * Get a specific voice by ID
 */
export const getVoice = query({
  args: { voiceId: v.id("voices") },
  handler: async (ctx, args) => {
    const voice = await ctx.db.get(args.voiceId);
    
    if (!voice) {
      throw new Error("Voice not found");
    }

    // Check access permissions
    if (!voice.isPublic) {
      const identity = await ctx.auth.getUserIdentity();
      if (!identity || voice.uploadedBy !== identity.subject) {
        throw new Error("Access denied");
      }
    }

    return voice;
  },
});

/**
 * Create a custom voice entry (after voice cloning is complete)
 */
export const createCustomVoice = mutation({
  args: {
    name: v.string(),
    description: v.string(),
    language: v.string(),
    accent: v.optional(v.string()),
    ageGroup: v.string(),
    gender: v.union(v.literal("male"), v.literal("female"), v.literal("neutral")),
    previewUrl: v.string(),
    externalVoiceId: v.string(), // Voice ID from 11Labs or other provider
    tags: v.array(v.string()),
    isPublic: v.boolean(),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Not authenticated");
    }

    const voiceId = await ctx.db.insert("voices", {
      name: args.name,
      description: args.description,
      language: args.language,
      accent: args.accent,
      ageGroup: args.ageGroup,
      gender: args.gender,
      previewUrl: args.previewUrl,
      provider: "custom",
      externalVoiceId: args.externalVoiceId,
      tags: args.tags,
      isPremium: false,
      isPublic: args.isPublic,
      uploadedBy: identity.subject as any,
      usageCount: 0,
      averageRating: 0,
      createdAt: new Date().toISOString(),
    });

    return voiceId;
  },
});

/**
 * Update voice metadata
 */
export const updateVoice = mutation({
  args: {
    voiceId: v.id("voices"),
    name: v.optional(v.string()),
    description: v.optional(v.string()),
    tags: v.optional(v.array(v.string())),
    isPublic: v.optional(v.boolean()),
  },
  handler: async (ctx, args) => {
    const { voiceId, ...updates } = args;
    
    const voice = await ctx.db.get(voiceId);
    if (!voice) {
      throw new Error("Voice not found");
    }

    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Not authenticated");
    }

    // Only the uploader can update their voice
    if (voice.uploadedBy !== identity.subject) {
      throw new Error("Only the voice owner can update it");
    }

    await ctx.db.patch(voiceId, updates);

    return voiceId;
  },
});

/**
 * Delete a custom voice
 */
export const deleteVoice = mutation({
  args: {
    voiceId: v.id("voices"),
  },
  handler: async (ctx, args) => {
    const voice = await ctx.db.get(args.voiceId);
    if (!voice) {
      throw new Error("Voice not found");
    }

    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Not authenticated");
    }

    // Only the uploader can delete their voice
    if (voice.uploadedBy !== identity.subject) {
      throw new Error("Only the voice owner can delete it");
    }

    // Check if any toys are using this voice
    const toysUsingVoice = await ctx.db
      .query("toys")
      .filter((q) => q.eq(q.field("voiceId"), voice.externalVoiceId))
      .collect();

    if (toysUsingVoice.length > 0) {
      throw new Error(`Cannot delete voice: ${toysUsingVoice.length} toys are using it`);
    }

    await ctx.db.delete(args.voiceId);

    return { success: true };
  },
});

/**
 * Increment voice usage count
 */
export const incrementVoiceUsage = mutation({
  args: {
    voiceId: v.id("voices"),
  },
  handler: async (ctx, args) => {
    const voice = await ctx.db.get(args.voiceId);
    if (!voice) {
      throw new Error("Voice not found");
    }

    await ctx.db.patch(args.voiceId, {
      usageCount: voice.usageCount + 1,
    });

    return args.voiceId;
  },
});

/**
 * Get popular voices for kids
 */
export const getKidsFriendlyVoices = query({
  handler: async (ctx) => {
    const voices = await ctx.db
      .query("voices")
      .withIndex("is_public", (q) => q.eq("isPublic", true))
      .collect();

    // Filter for kid-friendly voices
    const kidsFriendlyVoices = voices.filter(v => 
      v.tags.includes("kids-friendly") || 
      v.tags.includes("child-safe") ||
      v.ageGroup.includes("child") ||
      v.ageGroup.includes("kids")
    );

    // Sort by usage count
    return kidsFriendlyVoices.sort((a, b) => b.usageCount - a.usageCount);
  },
});

/**
 * Search voices by name or tags
 */
export const searchVoices = query({
  args: {
    searchTerm: v.string(),
  },
  handler: async (ctx, args) => {
    const searchLower = args.searchTerm.toLowerCase();
    
    const voices = await ctx.db
      .query("voices")
      .withIndex("is_public", (q) => q.eq("isPublic", true))
      .collect();

    // Filter by search term in name, description, or tags
    const matchingVoices = voices.filter(v => 
      v.name.toLowerCase().includes(searchLower) ||
      v.description.toLowerCase().includes(searchLower) ||
      v.tags.some(tag => tag.toLowerCase().includes(searchLower))
    );

    return matchingVoices;
  },
});

/**
 * Lookup a voice by its provider's external voice ID
 */
export const getByExternalVoiceId = query({
  args: { externalVoiceId: v.string() },
  handler: async (ctx, args) => {
    const match = await ctx.db
      .query("voices")
      .withIndex("by_external", (q) => q.eq("externalVoiceId", args.externalVoiceId))
      .first();
    return match ?? null;
  },
});

/**
 * Upsert a provider-backed voice (e.g., ElevenLabs) into the voices table
 */
export const upsertProviderVoice = mutation({
  args: {
    name: v.string(),
    description: v.string(),
    language: v.string(),
    accent: v.optional(v.string()),
    ageGroup: v.string(),
    gender: v.union(v.literal("male"), v.literal("female"), v.literal("neutral")),
    previewUrl: v.string(),
    provider: v.union(v.literal("11labs"), v.literal("azure"), v.literal("custom")),
    externalVoiceId: v.string(),
    tags: v.array(v.string()),
    isPremium: v.optional(v.boolean()),
    isPublic: v.boolean(),
    uploadedBy: v.optional(v.id("users")),
  },
  handler: async (ctx, args) => {
    const existing = await ctx.db
      .query("voices")
      .withIndex("by_external", (q) => q.eq("externalVoiceId", args.externalVoiceId))
      .first();

    if (existing) {
      const doc = existing;
      await ctx.db.patch(doc._id, {
        name: args.name,
        description: args.description,
        language: args.language,
        accent: args.accent,
        ageGroup: args.ageGroup,
        gender: args.gender,
        previewUrl: args.previewUrl,
        provider: args.provider,
        tags: args.tags,
        isPremium: args.isPremium ?? doc.isPremium,
        isPublic: args.isPublic,
        ...(args.uploadedBy ? { uploadedBy: args.uploadedBy } : {}),
      });
      return doc._id;
    }

    const insertedId = await ctx.db.insert("voices", {
      name: args.name,
      description: args.description,
      language: args.language,
      accent: args.accent,
      ageGroup: args.ageGroup,
      gender: args.gender,
      previewUrl: args.previewUrl,
      provider: args.provider,
      externalVoiceId: args.externalVoiceId,
      tags: args.tags,
      isPremium: args.isPremium ?? false,
      isPublic: args.isPublic,
      uploadedBy: args.uploadedBy,
      usageCount: 0,
      averageRating: 0,
      createdAt: new Date().toISOString(),
    } as any);
    return insertedId;
  },
});
</file>

<file path="debug-auth.js">
// Debug auth configuration
console.log(' Debugging Auth Configuration\n');
console.log('================================\n');

// Check environment variables
console.log('Environment Variables:');
console.log('NEXT_PUBLIC_CONVEX_URL:', process.env.NEXT_PUBLIC_CONVEX_URL || 'Not set');
console.log('NEXT_PUBLIC_CONVEX_SITE_URL:', process.env.NEXT_PUBLIC_CONVEX_SITE_URL || 'Not set');
console.log('CONVEX_DEPLOYMENT:', process.env.CONVEX_DEPLOYMENT || 'Not set');

// Load dotenv
require('dotenv').config({ path: '.env.local' });

console.log('\nAfter loading .env.local:');
console.log('NEXT_PUBLIC_CONVEX_URL:', process.env.NEXT_PUBLIC_CONVEX_URL);
console.log('NEXT_PUBLIC_CONVEX_SITE_URL:', process.env.NEXT_PUBLIC_CONVEX_SITE_URL);
console.log('CONVEX_DEPLOYMENT:', process.env.CONVEX_DEPLOYMENT);

console.log('\n Expected Auth Flow:');
console.log('1. Auth provider should be configured with domain: https://warmhearted-snail-998.convex.site');
console.log('2. JWT tokens should have issuer: https://warmhearted-snail-998.convex.site');
console.log('3. Convex should validate against: https://warmhearted-snail-998.convex.site');

console.log('\n The error "No auth provider found matching the given token" means:');
console.log('- The JWT issuer in the token doesn\'t match any configured auth provider');
console.log('- This usually happens when dev and prod deployments get mixed up');

console.log('\n To fix:');
console.log('1. Ensure NEXT_PUBLIC_CONVEX_SITE_URL matches your production deployment');
console.log('2. Clear browser cookies/localStorage');
console.log('3. Restart the Next.js server');
console.log('4. Try signing in again');
</file>

<file path="eslint.config.mjs">
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
  {
    ignores: [
      "node_modules/**",
      ".next/**",
      "out/**",
      "build/**",
      "next-env.d.ts",
    ],
  },
];

export default eslintConfig;
</file>

<file path="lib/webrtc-client.ts">
/**
 * WebRTC Client for connecting to FastRTC Gateway
 * Handles real-time audio streaming for AI toy interactions
 */

import { EventEmitter } from 'events';

export interface WebRTCClientConfig {
  gatewayUrl: string;
  deviceId: string;
  toyId: string;
  userId?: string;
  iceServers?: RTCIceServer[];
}

export interface SessionInfo {
  sessionId: string;
  threadId: string;
}

declare global {
  interface Window {
    webkitAudioContext?: typeof AudioContext;
  }
}

export class WebRTCClient extends EventEmitter {
  private config: WebRTCClientConfig;
  private pc: RTCPeerConnection | null = null;
  private dataChannel: RTCDataChannel | null = null;
  private sessionInfo: SessionInfo | null = null;
  private localStream: MediaStream | null = null;
  private remoteStream: MediaStream | null = null;
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 3;
  private isConnected = false;
  private audioContext: AudioContext | null = null;
  private audioProcessor: ScriptProcessorNode | null = null;

  constructor(config: WebRTCClientConfig) {
    super();
    this.config = {
      ...config,
      iceServers: config.iceServers || [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' },
      ],
    };
  }

  /**
   * Initialize connection to FastRTC Gateway
   */
  async connect(): Promise<void> {
    try {
      // Create session with gateway
      const sessionResponse = await fetch(`${this.config.gatewayUrl}/session/create`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          deviceId: this.config.deviceId,
          toyId: this.config.toyId,
          userId: this.config.userId,
        }),
      });

      if (!sessionResponse.ok) {
        throw new Error(`Failed to create session: ${sessionResponse.statusText}`);
      }

      const sessionData = await sessionResponse.json();
      this.sessionInfo = {
        sessionId: sessionData.sessionId,
        threadId: sessionData.threadId,
      };

      // Setup WebRTC connection
      await this.setupPeerConnection();

      // Set remote description (offer from server)
      await this.pc!.setRemoteDescription(
        new RTCSessionDescription(sessionData.offer)
      );

      // Create answer
      const answer = await this.pc!.createAnswer();
      await this.pc!.setLocalDescription(answer);

      // Send answer to gateway
      const answerResponse = await fetch(`${this.config.gatewayUrl}/session/answer`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          sessionId: this.sessionInfo.sessionId,
          answer: {
            sdp: answer.sdp,
            type: answer.type,
          },
        }),
      });

      if (!answerResponse.ok) {
        throw new Error(`Failed to send answer: ${answerResponse.statusText}`);
      }

      this.emit('connected', this.sessionInfo);
    } catch (error) {
      console.error('Connection failed:', error);
      this.emit('error', error);
      
      // Attempt reconnection
      if (this.reconnectAttempts < this.maxReconnectAttempts) {
        this.reconnectAttempts++;
        setTimeout(() => this.connect(), 2000 * this.reconnectAttempts);
      }
    }
  }

  /**
   * Setup WebRTC peer connection
   */
  private async setupPeerConnection(): Promise<void> {
    // Create peer connection
    this.pc = new RTCPeerConnection({
      iceServers: this.config.iceServers,
    });

    // Handle ICE candidates
    this.pc.onicecandidate = (event) => {
      if (event.candidate) {
        console.log('New ICE candidate:', event.candidate);
      }
    };

    // Handle connection state changes
    this.pc.onconnectionstatechange = () => {
      console.log('Connection state:', this.pc?.connectionState);
      
      switch (this.pc?.connectionState) {
        case 'connected':
          this.isConnected = true;
          this.reconnectAttempts = 0;
          this.emit('connectionStateChange', 'connected');
          break;
        case 'disconnected':
          this.isConnected = false;
          this.emit('connectionStateChange', 'disconnected');
          break;
        case 'failed':
          this.isConnected = false;
          this.emit('connectionStateChange', 'failed');
          this.reconnect();
          break;
        case 'closed':
          this.isConnected = false;
          this.emit('connectionStateChange', 'closed');
          break;
      }
    };

    // Handle incoming tracks (audio from server)
    this.pc.ontrack = (event) => {
      console.log('Received track:', event.track.kind);
      
      if (event.track.kind === 'audio') {
        // Create or update remote stream
        if (!this.remoteStream) {
          this.remoteStream = new MediaStream();
        }
        this.remoteStream.addTrack(event.track);
        
        // Emit event for UI to handle
        this.emit('remoteAudio', this.remoteStream);
      }
    };

    // Create data channel for control messages
    this.dataChannel = this.pc.createDataChannel('control', {
      ordered: true,
    });

    this.dataChannel.onopen = () => {
      console.log('Data channel opened');
      this.emit('dataChannelOpen');
      
      // Send periodic heartbeat
      this.startHeartbeat();
    };

    this.dataChannel.onmessage = (event) => {
      try {
        const message = JSON.parse(event.data);
        this.handleControlMessage(message);
      } catch (error) {
        console.error('Failed to parse control message:', error);
      }
    };

    this.dataChannel.onerror = (error) => {
      console.error('Data channel error:', error);
      this.emit('dataChannelError', error);
    };

    // Get user media and add to connection
    await this.setupLocalAudio();
  }

  /**
   * Setup local audio stream
   */
  private async setupLocalAudio(): Promise<void> {
    try {
      // Request microphone access
      this.localStream = await navigator.mediaDevices.getUserMedia({
        audio: {
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: true,
          sampleRate: 16000,
        },
        video: false,
      });

      // Add audio track to peer connection
      const audioTrack = this.localStream.getAudioTracks()[0];
      if (audioTrack && this.pc) {
        this.pc.addTrack(audioTrack, this.localStream);
        this.emit('localAudio', this.localStream);
      }

      // Setup audio processing for voice activity detection
      this.setupAudioProcessing();
    } catch (error) {
      console.error('Failed to get user media:', error);
      this.emit('error', error);
    }
  }

  /**
   * Setup audio processing for VAD and visualization
   */
  private setupAudioProcessing(): void {
    if (!this.localStream) return;

    const Ctx = window.AudioContext || window.webkitAudioContext!;
    this.audioContext = new Ctx();
    const source = this.audioContext.createMediaStreamSource(this.localStream);
    
    // Create processor for audio analysis
    this.audioProcessor = this.audioContext.createScriptProcessor(2048, 1, 1);
    
    this.audioProcessor.onaudioprocess = (event) => {
      const inputData = event.inputBuffer.getChannelData(0);
      
      // Calculate RMS for voice activity detection
      let sum = 0;
      for (let i = 0; i < inputData.length; i++) {
        sum += inputData[i] * inputData[i];
      }
      const rms = Math.sqrt(sum / inputData.length);
      
      // Emit audio level for UI visualization
      this.emit('audioLevel', rms);
      
      // Simple VAD
      const isSpeaking = rms > 0.01;
      this.emit('voiceActivity', isSpeaking);
    };

    source.connect(this.audioProcessor);
    this.audioProcessor.connect(this.audioContext.destination);
  }

  /**
   * Handle control messages from server
   */
  private handleControlMessage(message: { type: string; [key: string]: unknown }): void {
    switch (message.type) {
      case 'pong':
        // Heartbeat response
        break;
      case 'transcription':
        this.emit('transcription', message.text);
        break;
      case 'aiResponse':
        this.emit('aiResponse', message.text);
        break;
      case 'error':
        this.emit('serverError', message.error);
        break;
      default:
        console.log('Unknown control message:', message);
    }
  }

  /**
   * Send control message to server
   */
  public sendControlMessage(message: Record<string, unknown>): void {
    if (this.dataChannel && this.dataChannel.readyState === 'open') {
      this.dataChannel.send(JSON.stringify(message));
    } else {
      console.warn('Data channel not open, cannot send message');
    }
  }

  /**
   * Start recording audio
   */
  public startRecording(): void {
    this.sendControlMessage({ command: 'start_recording' });
    this.emit('recordingStarted');
  }

  /**
   * Stop recording audio
   */
  public stopRecording(): void {
    this.sendControlMessage({ command: 'stop_recording' });
    this.emit('recordingStopped');
  }

  /**
   * Start heartbeat to keep connection alive
   */
  private startHeartbeat(): void {
    setInterval(() => {
      if (this.isConnected) {
        this.sendControlMessage({ command: 'ping' });
      }
    }, 30000); // Every 30 seconds
  }

  /**
   * Reconnect to gateway
   */
  private async reconnect(): Promise<void> {
    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      this.emit('maxReconnectAttemptsReached');
      return;
    }

    this.cleanup();
    this.reconnectAttempts++;
    
    console.log(`Reconnecting... Attempt ${this.reconnectAttempts}`);
    
    setTimeout(() => {
      this.connect();
    }, 2000 * this.reconnectAttempts);
  }

  /**
   * Disconnect from gateway
   */
  public async disconnect(): Promise<void> {
    this.cleanup();
    this.emit('disconnected');
  }

  /**
   * Clean up resources
   */
  private cleanup(): void {
    // Stop local stream
    if (this.localStream) {
      this.localStream.getTracks().forEach(track => track.stop());
      this.localStream = null;
    }

    // Stop remote stream
    if (this.remoteStream) {
      this.remoteStream.getTracks().forEach(track => track.stop());
      this.remoteStream = null;
    }

    // Close audio context
    if (this.audioContext) {
      this.audioContext.close();
      this.audioContext = null;
    }

    // Disconnect audio processor
    if (this.audioProcessor) {
      this.audioProcessor.disconnect();
      this.audioProcessor = null;
    }

    // Close data channel
    if (this.dataChannel) {
      this.dataChannel.close();
      this.dataChannel = null;
    }

    // Close peer connection
    if (this.pc) {
      this.pc.close();
      this.pc = null;
    }

    this.isConnected = false;
    this.sessionInfo = null;
  }

  /**
   * Get current session info
   */
  public getSessionInfo(): SessionInfo | null {
    return this.sessionInfo;
  }

  /**
   * Check if connected
   */
  public getIsConnected(): boolean {
    return this.isConnected;
  }

  /**
   * Get local audio stream
   */
  public getLocalStream(): MediaStream | null {
    return this.localStream;
  }

  /**
   * Get remote audio stream
   */
  public getRemoteStream(): MediaStream | null {
    return this.remoteStream;
  }

  /**
   * Mute/unmute local audio
   */
  public setMuted(muted: boolean): void {
    if (this.localStream) {
      this.localStream.getAudioTracks().forEach(track => {
        track.enabled = !muted;
      });
      this.emit('muteStateChanged', muted);
    }
  }

  /**
   * Get mute state
   */
  public getMuted(): boolean {
    if (this.localStream) {
      const track = this.localStream.getAudioTracks()[0];
      return track ? !track.enabled : true;
    }
    return true;
  }
}
</file>

<file path="next.config.ts">
import path from "node:path";

const nextConfig = {
  // Next.js 15 automatically detects src/app
  // No additional configuration needed
  typescript: {
    ignoreBuildErrors: true,
  },
  eslint: {
    ignoreDuringBuilds: true,
  },
  // Pin Turbopack's workspace root to the monorepo root to avoid incorrect inference
  turbopack: {
    root: path.resolve(__dirname, "..", ".."),
  },
} as const;

export default nextConfig;
</file>

<file path="postcss.config.mjs">
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;
</file>

<file path="README.md">
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.
</file>

<file path="scripts/create-test-toy.js">
#!/usr/bin/env node
/**
 * Create a test toy in Convex database
 */

const { ConvexClient } = require("convex/browser");

const CONVEX_URL = "https://warmhearted-snail-998.convex.cloud";

async function createTestToy() {
  const client = new ConvexClient(CONVEX_URL);
  
  try {
    // First, try to list existing toys
    console.log("Checking existing toys...");
    const toys = await client.query("toys:list");
    console.log(`Found ${toys?.length || 0} existing toys`);
    
    if (toys && toys.length > 0) {
      console.log("First toy ID:", toys[0]._id);
      console.log("First toy name:", toys[0].name);
      return toys[0]._id;
    }
    
    // Create a new toy if none exist
    console.log("Creating new test toy...");
    const toyId = await client.mutation("toys:create", {
      name: "Pommai Test Toy",
      personalityPrompt: "You are a friendly and helpful AI assistant toy. Be cheerful and engaging.",
      voiceTone: "cheerful",
      isForKids: true,
      voiceId: "JBFqnCBsd6RMkjVDRZzb", // Default ElevenLabs voice
      interests: ["learning", "playing", "stories"],
      isPublic: false
    });
    
    console.log("Created toy with ID:", toyId);
    return toyId;
    
  } catch (error) {
    console.error("Error:", error);
    
    // If toys:list doesn't exist, the schema might be different
    console.log("\nLet's check what functions are available...");
    // This would require listing all functions, which isn't directly available
    console.log("Please ensure Convex is properly deployed with: npx convex deploy");
  } finally {
    await client.close();
  }
}

createTestToy().then(toyId => {
  console.log("\n=================");
  console.log("Update your Raspberry Pi .env file with:");
  console.log(`TOY_ID=${toyId}`);
  console.log("=================");
  process.exit(0);
}).catch(err => {
  console.error("Fatal error:", err);
  process.exit(1);
});
</file>

<file path="scripts/test-ai-pipeline.ts">
#!/usr/bin/env tsx

/**
 * Test script for AI Pipeline Integration
 * Run with: npx tsx scripts/test-ai-pipeline.ts
 */

import { ConvexClient } from "convex/browser";
import dotenv from "dotenv";
import { api } from "../convex/_generated/api";
import fs from "fs";
import path from "path";

// Load environment variables
dotenv.config({ path: ".env.local" });

const CONVEX_URL = process.env.NEXT_PUBLIC_CONVEX_URL;

if (!CONVEX_URL) {
  console.error(" Missing NEXT_PUBLIC_CONVEX_URL in .env.local");
  process.exit(1);
}

async function testAIPipeline() {
  console.log(" Testing AI Pipeline Integration\n");
  
  const client = new ConvexClient(CONVEX_URL);
  
  try {
    // Test 1: Check API Health
    console.log("1 Checking API Health...");
    const health = await client.action(api.aiServices.checkAPIHealth, {});
    console.log("API Health Status:");
    console.log("  - OpenAI:", health.openai ? "" : "");
    console.log("  - ElevenLabs:", health.elevenlabs ? "" : "");
    console.log("  - OpenRouter:", health.openrouter ? "" : "");
    
    if (health.errors.length > 0) {
      console.log("  Errors:", health.errors);
    }
    console.log();
    
    // Test 2: Test Speech-to-Text (with minimal audio)
    console.log("2 Testing Speech-to-Text...");
    // Create a minimal WAV file header (silent audio)
    const minimalWav = Buffer.from([
      0x52, 0x49, 0x46, 0x46, // "RIFF"
      0x24, 0x00, 0x00, 0x00, // File size
      0x57, 0x41, 0x56, 0x45, // "WAVE"
      0x66, 0x6D, 0x74, 0x20, // "fmt "
      0x10, 0x00, 0x00, 0x00, // Subchunk size
      0x01, 0x00,             // Audio format (PCM)
      0x01, 0x00,             // Number of channels
      0x40, 0x1F, 0x00, 0x00, // Sample rate (8000)
      0x80, 0x3E, 0x00, 0x00, // Byte rate
      0x02, 0x00,             // Block align
      0x10, 0x00,             // Bits per sample
      0x64, 0x61, 0x74, 0x61, // "data"
      0x00, 0x00, 0x00, 0x00  // Data size
    ]).toString('base64');
    
    try {
      const transcription = await client.action(api.aiServices.transcribeAudio, {
        audioData: minimalWav,
        language: "en",
      });
      console.log("  Transcription test completed (silent audio expected)");
    } catch (error) {
      console.log("   STT test failed (may need real audio):", error.message);
    }
    console.log();
    
    // Test 3: Test LLM Generation
    console.log("3 Testing LLM Generation...");
    const llmResponse = await client.action(api.aiServices.generateResponse, {
      messages: [
        { role: "system", content: "You are a friendly AI toy assistant." },
        { role: "user", content: "Hello! Can you count to 3?" }
      ],
      model: "openai/gpt-oss-120b",
      temperature: 0.7,
      maxTokens: 50,
    });
    
    console.log("  LLM Response:", llmResponse.content?.substring(0, 100));
    console.log("  Model used:", llmResponse.model || "default");
    console.log();
    
    // Test 4: Test Text-to-Speech
    console.log("4 Testing Text-to-Speech...");
    try {
      const audio = await client.action(api.aiServices.synthesizeSpeech, {
        text: "Hello! I am your AI toy friend.",
        voiceId: "JBFqnCBsd6RMkjVDRZzb", // Default voice
        outputFormat: "mp3_44100_128",
      });
      
      console.log("  TTS completed successfully");
      console.log(`  Audio size: ${audio.byteSize} bytes`);
      console.log(`  Duration: ~${audio.duration} seconds`);
    } catch (error) {
      console.log("   TTS test failed:", error.message);
    }
    console.log();
    
    // Test 5: Test Embedding Generation
    console.log("5 Testing Embedding Generation...");
    const embedding = await client.action(api.aiServices.generateEmbedding, {
      text: "This is a test sentence for embedding generation.",
    });
    
    console.log("  Embedding generated successfully");
    console.log(`  Dimensions: ${embedding.embedding.length}`);
    console.log(`  Tokens used: ${embedding.tokenCount}`);
    console.log();
    
    // Test 6: Test Safety Check
    console.log("6 Testing Safety Check...");
    const safetyTests = [
      { text: "Let's play a fun game!", expected: true },
      { text: "I want to hurt someone", expected: false },
      { text: "What's your email address?", expected: false },
    ];
    
    for (const test of safetyTests) {
      const result = await client.action(api.aiPipeline.checkContentSafety, {
        text: test.text,
        level: "strict",
      });
      
      const passed = result.passed === test.expected;
      console.log(`  "${test.text.substring(0, 30)}...":`);
      console.log(`    Result: ${result.passed ? "Safe" : "Unsafe"} ${passed ? "" : ""}`);
      if (!result.passed) {
        console.log(`    Reason: ${result.reason}`);
      }
    }
    console.log();
    
    // Test 7: Test Complete Pipeline (if toy exists)
    console.log("7 Testing Complete Voice Pipeline...");
    console.log("   Requires a valid toy ID to test");
    console.log("  Would test: Audio  STT  Safety  LLM  TTS  Audio");
    console.log();
    
    console.log(" AI Pipeline tests completed!");
    console.log("\n Summary:");
    console.log("- API connections tested");
    console.log("- Individual service functions tested");
    console.log("- Safety filtering tested");
    console.log("\n Note: Some tests may fail if API keys are not configured");
    
  } catch (error) {
    console.error(" Test failed:", error);
    process.exit(1);
  } finally {
    await client.close();
  }
}

// Run the test
testAIPipeline().catch(console.error);
</file>

<file path="scripts/test-stt-llm.mjs">
// apps/web/scripts/test-stt-llm.mjs
import { ConvexClient } from "convex/browser";
import { api } from "../convex/_generated/api.js";
import fs from "fs/promises";
import path from "path";
import dotenv from "dotenv";

dotenv.config({ path: ".env.local" });

const CONVEX_URL = process.env.NEXT_PUBLIC_CONVEX_URL;
if (!CONVEX_URL) {
  console.error(" NEXT_PUBLIC_CONVEX_URL missing in apps/web/.env.local");
  process.exit(1);
}

const AUDIO_ARG = process.argv[2] || "test.wav";
const AUDIO_PATH = path.isAbsolute(AUDIO_ARG) ? AUDIO_ARG : path.resolve(process.cwd(), AUDIO_ARG);

const client = new ConvexClient(CONVEX_URL);

// Optional auth token
const AUTH_TOKEN = process.env.CONVEX_AUTH_TOKEN || process.env.AUTH_TOKEN || process.env.BETTER_AUTH_TOKEN;
if (AUTH_TOKEN) {
  try {
    client.setAuth(AUTH_TOKEN);
    console.log("- Using auth token from environment");
  } catch {}
}

async function main() {
  console.log(" STT + LLM Smoke Test (no TTS)");
  console.log(`- Convex: ${CONVEX_URL}`);
  console.log(`- Audio: ${AUDIO_PATH}`);

  // Read audio
  const buf = await fs.readFile(AUDIO_PATH);
  const audioBase64 = buf.toString("base64");

  // 1) STT
  console.log("\n1 STT: Whisper transcription...");
  const transcription = await client.action(api.aiServices.transcribeAudio, {
    audioData: audioBase64,
    language: "en",
  });
  console.log("- Text:", transcription.text);
  console.log("- Confidence:", transcription.confidence);

  // 2) LLM via OpenRouter with fallback models
  console.log("\n2 LLM: Generating response (OpenRouter)...");
  const models = [
    process.env.OPENROUTER_MODEL,
    "openai/gpt-4o-mini",
    "google/gemini-1.5-flash",
    "meta-llama/llama-3.1-8b-instruct",
    "mistralai/mistral-7b-instruct",
  ].filter(Boolean);

  const messages = [
    {
      role: "system",
      content:
        "You are a friendly AI toy assistant. Keep it short and kid-safe when appropriate.",
    },
    { role: "user", content: transcription.text || "Hello!" },
  ];

  let llmResponse = null;
  let lastError = null;
  for (const model of models) {
    try {
      console.log(`- Trying model: ${model}`);
      llmResponse = await client.action(api.aiServices.generateResponse, {
        messages,
        model,
        temperature: 0.7,
        maxTokens: 150,
      });
      if (llmResponse?.content) {
        console.log(" Model worked:", model);
        break;
      }
    } catch (e) {
      lastError = e;
      console.log(`   Failed: ${model} ->`, e?.message || e);
    }
  }

  if (!llmResponse?.content) {
    console.error(" LLM generation failed for all fallback models.");
    if (lastError) console.error("Last error:", lastError);
    process.exit(1);
  }

  console.log("- LLM Response:", llmResponse.content);
  console.log("\n STT + LLM test complete (TTS skipped)");
}

main().catch((err) => {
  console.error(" Test failed:", err);
  process.exit(1);
});
</file>

<file path="scripts/test-toy-backend.mjs">
// apps/web/scripts/test-toy-backend.mjs
import { ConvexClient } from "convex/browser";
import { api } from "../convex/_generated/api.js";
import fs from "fs/promises";
import path from "path";
import dotenv from "dotenv";

// Load environment variables from .env.local
dotenv.config({ path: ".env.local" });

// --- CONFIGURATION ---
// 1. PASTE YOUR TOY ID HERE
const TOY_ID = "ks7cw1ar4x1x4h0ep21as78d7s7pt9xg"; //  Using provided Toy ID

// 2. MAKE SURE YOUR CONVEX URL IS CORRECT IN .env.local
const CONVEX_URL = process.env.NEXT_PUBLIC_CONVEX_URL;

// --- SCRIPT ---

async function runTest() {
  if (!CONVEX_URL) {
    console.error(" NEXT_PUBLIC_CONVEX_URL is not set in your .env.local file.");
    return;
  }
  if (!TOY_ID || TOY_ID === "YOUR_TOY_ID") {
    console.error(" Please set TOY_ID in this script to your actual Toy ID from the Convex dashboard.");
    return;
  }

  // Allow passing an audio file path as the first CLI argument
  const cliAudioArg = process.argv[2];
  const audioPath = cliAudioArg
    ? (path.isAbsolute(cliAudioArg) ? cliAudioArg : path.resolve(process.cwd(), cliAudioArg))
    : path.resolve(process.cwd(), "test.wav");

  console.log(" Starting AI Toy Backend Test...");
  console.log(`- Using Toy ID: ${TOY_ID}`);
  console.log(`- Connecting to Convex at: ${CONVEX_URL}`);
  console.log(`- Audio file: ${audioPath}`);

  const client = new ConvexClient(CONVEX_URL);

  // Optional: set auth token if provided in environment
  const AUTH_TOKEN = process.env.CONVEX_AUTH_TOKEN || process.env.AUTH_TOKEN || process.env.BETTER_AUTH_TOKEN;
  if (AUTH_TOKEN) {
    try {
      // ConvexClient accepts a token string in Node/browser contexts
      client.setAuth(AUTH_TOKEN);
      console.log("- Using auth token from environment");
    } catch (e) {
      console.warn("- Failed to set auth token from environment; proceeding unauthenticated");
    }
  } else {
    console.log("- No auth token set; proceeding unauthenticated");
  }

  try {
    // 1. Read and encode the test audio file
    console.log("\n Reading test audio file...");
    const audioBuffer = await fs.readFile(audioPath);
    const audioBase64 = audioBuffer.toString("base64");
    console.log(" Audio file encoded successfully.");

    // 2. Call the main AI pipeline action
    console.log("\n Calling the AI pipeline... (This may take a few seconds)");
    const MODEL = process.env.OPENROUTER_MODEL || 'openai/gpt-4o-mini';
    const result = await client.action(api.aiPipeline.processVoiceInteraction, {
      toyId: TOY_ID,
      audioData: audioBase64,
      sessionId: `test-session-${Date.now()}`,
      deviceId: "test-script-runner",
      model: MODEL,
    });

    console.log("\n Pipeline executed successfully!");
    console.log("------------------------------------");
    console.log(` You said (Transcription): "${result.transcription?.text || ""}"`);
    console.log(` Toy replied (Response): "${result.text}"`);
    console.log(` Audio Generated: ${result.audioData ? 'Yes' : 'No'} (${result.format})`);
    console.log(` Total Processing Time: ${result.processingTime}ms`);
    console.log("------------------------------------");

    if (result.audioData) {
      console.log("\n Test Passed! The full AI pipeline is working.");
    } else {
      console.warn("\n Test Warning: The pipeline worked, but no audio was generated. Check your ElevenLabs API key.");
    }

  } catch (error) {
    console.error("\n Test Failed!");
    console.error("An error occurred during the pipeline execution:", error);
  }
}

runTest();
</file>

<file path="src/app/api/auth/[...all]/route.ts">
import { nextJsHandler } from "@convex-dev/better-auth/nextjs";

export const { GET, POST } = nextJsHandler();
</file>

<file path="src/app/auth/page.tsx">
'use client';

import { useState, type ChangeEvent } from 'react';
import { Card, Button, Input } from '@pommai/ui';
import { authClient } from '../../lib/auth-client';
import { useAuthStore } from '@/stores/useAuthStore';
import { useRouter } from 'next/navigation';
import Link from 'next/link';
import Image from 'next/image';

/**
 * Auth Page
 * - Pixel headings for titles only; inputs/labels use font-geo.
 * - Spacing tokens applied to containers.
 */
export default function AuthPage() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [name, setName] = useState('');
  const [activeTab, setActiveTab] = useState('login');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [verificationSent, setVerificationSent] = useState(false);
  const [needsVerification, setNeedsVerification] = useState(false);
  const router = useRouter();

  const handleLogin = async (e: React.FormEvent) => {
    e.preventDefault();
    setError(null);
    setIsLoading(true);
    setNeedsVerification(false);

    try {
      await authClient.signIn.email(
        {
          email,
          password,
          callbackURL: '/dashboard',
        },
        {
          onSuccess: () => {
            router.push('/dashboard');
          },
          onError: (ctx) => {
            // Handle email verification error
            if (ctx.error.status === 403) {
              setNeedsVerification(true);
              setError('Please verify your email address before signing in. Check your inbox for the verification link.');
            } else {
              setError(ctx.error.message || 'Invalid email or password');
            }
          },
        }
      );
    } catch (err: unknown) {
      const message = err instanceof Error ? err.message : 'An unexpected error occurred';
      setError(message);
    } finally {
      setIsLoading(false);
    }
  };

  const handleSignup = async (e: React.FormEvent) => {
    e.preventDefault();
    setError(null);
    setIsLoading(true);
    setVerificationSent(false);

    try {
      const { data, error: signupError } = await authClient.signUp.email({
        email,
        password,
        name,
        callbackURL: '/dashboard',
      });

      if (signupError) {
        setError(signupError.message || 'Failed to create account');
      } else {
        // Show verification message
        setVerificationSent(true);
        setActiveTab('verification');
      }
    } catch (err: unknown) {
      const message = err instanceof Error ? err.message : 'An unexpected error occurred';
      setError(message);
    } finally {
      setIsLoading(false);
    }
  };

  const handleResendVerification = async () => {
    setError(null);
    setIsLoading(true);

    try {
      await authClient.sendVerificationEmail({
        email,
        callbackURL: '/dashboard',
      });
      setVerificationSent(true);
      setError(null);
    } catch (err: unknown) {
      const message = err instanceof Error ? err.message : 'Failed to resend verification email';
      setError(message);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="auth-page min-h-screen flex flex-col bg-gradient-to-br from-[#fefcd0] to-[#f4e5d3]">
      {/* Header */}
      <header className="border-b-4 border-black bg-white shadow-[0_4px_0_0_#c381b5]">
<div className="container mx-auto px-[var(--spacing-md)] py-[var(--spacing-md)] sm:py-[var(--spacing-lg)]">
          <Link href="/" className="flex items-center justify-center gap-2 sm:gap-3 hover-lift">
            <Image src="/pommaiicon.png" alt="Pommai Logo" width={48} height={48} className="h-10 w-10 sm:h-12 sm:w-12 pixelated" />
            <Image src="/pommaitext.png" alt="Pommai" width={160} height={40} className="h-8 sm:h-10 pixelated" />
          </Link>
        </div>
      </header>

      {/* Main Content */}
<main className="flex-1 flex items-center justify-center p-[var(--spacing-md)] sm:p-[var(--spacing-lg)]">
        <div className="w-full max-w-sm relative">
          {/* Decorative elements removed for cleaner UI */}
          
          <Card 
            bg="#ffffff" 
            borderColor="black" 
            shadowColor="#c381b5"
            className="overflow-hidden hover-lift"
          >
            {/* Header Section */}
            <div className="bg-white border-b-4 border-black p-4 sm:p-5 text-center">
              <h1 className="text-xs font-minecraft font-black uppercase tracking-wider mb-1 text-[#c381b5] main-title">Welcome to Pommai</h1>
              <p className="text-xs font-geo font-semibold uppercase tracking-wide text-gray-700">Safe AI Companions for Children</p>
            </div>
            
            {/* Form Container */}
            <div className="p-4 sm:p-6 space-y-4">
              {/* Button Navigation */}
              <div className="flex gap-3 justify-center mb-6">
                <Button
                  onClick={() => setActiveTab('login')}
                  bg={activeTab === 'login' ? '#c381b5' : '#fefcd0'}
                  textColor={activeTab === 'login' ? 'white' : 'black'}
                  shadow={activeTab === 'login' ? '#8b5fa3' : '#c381b5'}
                  borderColor="black"
                  className="text-xs font-minecraft font-black tracking-wider border-2 px-8 py-3 hover:translate-y-[-2px] transition-transform touch-manipulation"
                >
                  LOGIN
                </Button>
                <Button
                  onClick={() => setActiveTab('signup')}
                  bg={activeTab === 'signup' ? '#c381b5' : '#fefcd0'}
                  textColor={activeTab === 'signup' ? 'white' : 'black'}
                  shadow={activeTab === 'signup' ? '#8b5fa3' : '#c381b5'}
                  borderColor="black"
                  className="text-xs font-minecraft font-black tracking-wider border-2 px-8 py-3 hover:translate-y-[-2px] transition-transform touch-manipulation"
                >
                  SIGN UP
                </Button>
              </div>

              {activeTab === 'login' && (
                <form onSubmit={handleLogin} className="space-y-3">
                    <div className="space-y-1">
                      <label className="text-xs font-geo font-semibold uppercase tracking-wider text-black">
                        Email Address
                      </label>
                      <Input 
                        type="email" 
                        placeholder="parent@example.com" 
                        value={email}
                        onChange={(e: ChangeEvent<HTMLInputElement>) => setEmail(e.target.value)}
                        bg="#fefcd0"
                        borderColor="black"
fontSize="12px"
                        className="text-xs py-1 px-2 font-geo font-medium border-2 w-full"
                        required
                      />
                    </div>
                    
                    <div className="space-y-1">
                      <label className="text-xs font-geo font-semibold uppercase tracking-wider text-black">
                        Password
                      </label>
                      <Input 
                        type="password" 
                        placeholder="Enter your password" 
                        value={password}
                        onChange={(e: ChangeEvent<HTMLInputElement>) => setPassword(e.target.value)}
                        bg="#fefcd0"
                        borderColor="black"
fontSize="12px"
                        className="text-xs py-1 px-2 font-geo font-medium border-2 w-full"
                        required
                      />
                    </div>

                    <div className="flex items-center justify-between pt-1">
                      <label className="flex items-center cursor-pointer gap-2">
                        <input 
                          type="checkbox" 
                          className="w-3 h-3 border-2 border-black" 
                        />
                        <span className="text-xs font-geo font-semibold uppercase tracking-wide text-gray-700">Remember me</span>
                      </label>
                      <Link 
                        href="/forgot-password" 
                        className="text-xs font-geo font-bold uppercase tracking-wider hover:underline transition-colors" 
                        style={{ color: '#c381b5' }}
                      >
                        Forgot password?
                      </Link>
                    </div>

                    {error && (
                      <Card bg="#ffdddd" borderColor="red" shadowColor="#ff6b6b" className="p-4">
                        <p className="text-red-700 text-xs font-geo font-bold uppercase tracking-wide">
                          ERROR: {typeof error === 'string' ? error : 'Authentication failed'}
                        </p>
                        {needsVerification && (
                          <Button
                            onClick={handleResendVerification}
                            bg="#fefcd0"
                            textColor="black"
                            shadow="#f39c12"
                            borderColor="black"
                            className="mt-3 text-xs font-minecraft font-black tracking-wider border-2 px-4 py-2 hover:translate-y-[-2px] transition-transform"
                            disabled={isLoading}
                          >
                            RESEND VERIFICATION EMAIL
                          </Button>
                        )}
                      </Card>
                    )}
                    
                    <div className="pt-2">
                      <Button 
                        type="submit"
                        bg="#c381b5" 
                        textColor="white" 
                        shadow="#8b5fa3"
                        borderColor="black"
                        className="w-full py-3 text-xs sm:text-sm font-minecraft font-black tracking-wider border-2 hover:translate-y-[-2px] transition-transform touch-manipulation"
                        disabled={isLoading}
                      >
                        {isLoading ? 'LOGGING IN...' : 'LOGIN TO DASHBOARD'}
                      </Button>
                    </div>
                  </form>
              )}

              {activeTab === 'verification' && (
                <div className="text-center space-y-4">
                  <div className="text-6xl mb-4"></div>
                  <h2 className="text-lg font-minecraft font-black uppercase tracking-wider text-[#c381b5]">
                    Check Your Email!
                  </h2>
                  <p className="text-xs font-geo font-semibold uppercase tracking-wide text-gray-700">
                    We&apos;ve sent a verification link to:
                  </p>
                  <p className="text-sm font-minecraft font-bold text-black">
                    {email}
                  </p>
                  <Card bg="#e8f6f3" borderColor="#27ae60" shadowColor="#27ae60" className="p-4 mt-4">
                    <p className="text-green-700 text-xs font-geo font-semibold uppercase tracking-wide">
                       Please check your inbox and click the verification link to activate your account.
                    </p>
                  </Card>
                  <div className="space-y-3 mt-6">
                    <p className="text-xs font-geo font-medium uppercase tracking-wide text-gray-600">
                      Didn&apos;t receive the email?
                    </p>
                    <Button
                      onClick={handleResendVerification}
                      bg="#fefcd0"
                      textColor="black"
                      shadow="#c381b5"
                      borderColor="black"
                      className="text-xs font-minecraft font-black tracking-wider border-2 px-6 py-2 hover:translate-y-[-2px] transition-transform"
                      disabled={isLoading}
                    >
                      {isLoading ? 'SENDING...' : 'RESEND VERIFICATION EMAIL'}
                    </Button>
                    {verificationSent && (
                      <p className="text-xs font-geo font-semibold uppercase tracking-wide text-green-600">
                         Verification email sent successfully!
                      </p>
                    )}
                  </div>
                  <div className="mt-6 pt-4 border-t-2 border-gray-200">
                    <Button
                      onClick={() => {
                        setActiveTab('login');
                        setVerificationSent(false);
                        setError(null);
                      }}
                      bg="#c381b5"
                      textColor="white"
                      shadow="#8b5fa3"
                      borderColor="black"
                      className="text-xs font-minecraft font-black tracking-wider border-2 px-6 py-2 hover:translate-y-[-2px] transition-transform"
                    >
                      BACK TO LOGIN
                    </Button>
                  </div>
                </div>
              )}

              {activeTab === 'signup' && (
                <div>
                  <form onSubmit={handleSignup} className="space-y-3">
                    <div className="space-y-1">
                      <label className="text-xs font-geo font-semibold uppercase tracking-wider text-black">
                        Full Name
                      </label>
                      <Input 
                        type="text" 
                        placeholder="John Doe" 
                        value={name}
                        onChange={(e: ChangeEvent<HTMLInputElement>) => setName(e.target.value)}
                        bg="#fefcd0"
                        borderColor="black"
fontSize="12px"
                        className="text-xs py-1 px-2 font-geo font-medium border-2 w-full"
                        required
                      />
                    </div>
                    
                    <div className="space-y-1">
                      <label className="text-xs font-geo font-semibold uppercase tracking-wider text-black">
                        Email Address
                      </label>
                      <Input 
                        type="email" 
                        placeholder="parent@example.com" 
                        value={email}
                        onChange={(e: ChangeEvent<HTMLInputElement>) => setEmail(e.target.value)}
                        bg="#fefcd0"
                        borderColor="black"
                        fontSize="12px"
className="text-xs py-1 px-2 font-geo font-medium border-2 w-full"
                        required
                      />
                    </div>
                    
                    <div className="space-y-1">
                      <label className="text-xs font-geo font-semibold uppercase tracking-wider text-black">
                        Password
                      </label>
                      <Input 
                        type="password" 
                        placeholder="Create a strong password" 
                        value={password}
                        onChange={(e: ChangeEvent<HTMLInputElement>) => setPassword(e.target.value)}
                        bg="#fefcd0"
                        borderColor="black"
                        fontSize="12px"
className="text-xs py-1 px-2 font-geo font-medium border-2 w-full"
                        required
                      />
                      <p className="text-xs font-geo font-medium uppercase tracking-wide text-gray-600">
                        Must be at least 8 characters long
                      </p>
                    </div>

                    <div className="flex items-start pt-1 gap-2">
                      <input 
                        type="checkbox" 
                        className="w-3 h-3 border-2 border-black mt-1" 
                        required 
                      />
                      <label className="text-xs font-geo font-semibold uppercase tracking-wide text-gray-700 leading-relaxed">
                        I agree to the{' '}
                        <Link href="/terms" className="font-geo font-bold hover:underline transition-colors" style={{ color: '#c381b5' }}>Terms of Service</Link>
                        {' '}and{' '}
                        <Link href="/privacy" className="font-geo font-bold hover:underline transition-colors" style={{ color: '#c381b5' }}>Privacy Policy</Link>
                      </label>
                    </div>

                    {error && (
                      <Card bg="#ffdddd" borderColor="red" shadowColor="#ff6b6b" className="p-4">
                        <p className="text-red-700 text-xs font-geo font-bold uppercase tracking-wide">
                          ERROR: {typeof error === 'string' ? error : 'Account creation failed'}
                        </p>
                      </Card>
                    )}
                    
                    <div className="pt-2">
                      <Button 
                        type="submit"
                        bg="#92cd41" 
                        textColor="white" 
                        shadow="#76a83a"
                        borderColor="black"
                        className="w-full py-3 text-xs sm:text-sm font-minecraft font-black tracking-wider border-2 hover:translate-y-[-2px] transition-transform touch-manipulation"
                        disabled={isLoading}
                      >
                        {isLoading ? 'CREATING ACCOUNT...' : 'CREATE FREE ACCOUNT'}
                      </Button>
                    </div>
                  </form>
                </div>
              )}
            </div>
          </Card>
        </div>
      </main>
    </div>
  );
}
</file>

<file path="src/app/dashboard/chat/page.tsx">
'use client';

import { useEffect, useState, Suspense } from 'react';
import { useSearchParams, useRouter } from 'next/navigation';
import { useQuery } from 'convex/react';
import { api } from '../../../../convex/_generated/api';
import { ChatInterface } from '@/components/chat/ChatInterface';
import { Button } from '@/components/ui/button';
import { Card } from '@/components/ui/card';
import { ArrowLeft, Bot, MessageSquare } from 'lucide-react';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@pommai/ui';

/**
 * Chat Page
 * - Pixel page title; supporting text stays Work Sans.
 * - Spacing tokens used in containers.
 */
export default function ChatPage() {
  return (
    <Suspense fallback={null}>
      <ChatPageInner />
    </Suspense>
  );
}

function ChatPageInner() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const toyName = searchParams.get('toy');
  
  // Get user's toys
  const toys = useQuery(api.toys.getMyToys);
  const [selectedToyId, setSelectedToyId] = useState<string | null>(null);
  
  // Find toy by name or select first available
  useEffect(() => {
    if (toys && toys.length > 0) {
      if (toyName) {
        const toy = toys.find(t => t.name === toyName);
        if (toy) {
          setSelectedToyId(toy._id);
        } else {
          setSelectedToyId(toys[0]._id);
        }
      } else {
        setSelectedToyId(toys[0]._id);
      }
    }
  }, [toys, toyName]);

  const selectedToy = toys?.find(t => t._id === selectedToyId);

  if (!toys || toys.length === 0) {
    return (
      <div className="container mx-auto px-[var(--spacing-md)] py-[var(--spacing-xl)]">
        <Card className="max-w-2xl mx-auto p-8 text-center">
          <Bot className="w-16 h-16 mx-auto mb-4 text-gray-400" />
          <h2 className="text-2xl font-bold text-gray-900 mb-2">No Toys Created Yet</h2>
          <p className="text-gray-600 mb-6">
            Create your first AI toy to start chatting!
          </p>
          <Button onClick={() => router.push('/dashboard/create-toy')}>
            Create Your First Toy
          </Button>
        </Card>
      </div>
    );
  }

  return (
    <div className="container mx-auto px-[var(--spacing-md)] py-[var(--spacing-xl)]">
      <div className="max-w-6xl mx-auto">
        {/* Header */}
        <div className="flex items-center justify-between mb-8">
          <div className="flex items-center gap-4">
            <Button
              onClick={() => router.push('/dashboard')}
              bg="#fefcd0"
              textColor="black"
              borderColor="black"
              shadow="#c381b5"
            >
              <ArrowLeft className="w-4 h-4 mr-2" />
              Back to Dashboard
            </Button>
            <h1 className="font-minecraft text-base sm:text-lg lg:text-xl font-black text-gray-900 flex items-center gap-2">
              <MessageSquare className="w-8 h-8" />
              Chat Simulator
            </h1>
          </div>
        </div>

        <div className="grid grid-cols-1 lg:grid-cols-4 gap-6">
          {/* Toy Selector */}
          <div className="lg:col-span-1">
            <Card className="p-4">
              <h3 className="font-semibold text-gray-900 mb-4">Select a Toy</h3>
              <div className="space-y-2">
                {toys.map((toy) => (
                  <button
                    key={toy._id}
                    onClick={() => setSelectedToyId(toy._id)}
                    className={`w-full text-left p-3 rounded-lg transition-colors ${
                      selectedToyId === toy._id
                        ? 'bg-purple-100 text-purple-900'
                        : 'hover:bg-gray-100'
                    }`}
                  >
                    <div className="flex items-center gap-3">
                      <span className="text-2xl">
                        {toy.type === 'teddy' && ''}
                        {toy.type === 'bunny' && ''}
                        {toy.type === 'cat' && ''}
                        {toy.type === 'dog' && ''}
                        {toy.type === 'bird' && ''}
                        {toy.type === 'fish' && ''}
                        {toy.type === 'robot' && ''}
                        {toy.type === 'magical' && ''}
                      </span>
                      <div>
                        <p className="font-medium">{toy.name}</p>
                        <p className="text-xs text-gray-500">
                          {toy.isForKids ? 'Kids Mode' : 'General'}
                        </p>
                      </div>
                    </div>
                  </button>
                ))}
              </div>
            </Card>
          </div>

          {/* Chat Interface */}
          <div className="lg:col-span-3">
            {selectedToy ? (
              <Tabs defaultValue="chat" className="w-full">
                <TabsList className="grid w-full grid-cols-2">
                  <TabsTrigger value="chat">Chat</TabsTrigger>
                  <TabsTrigger value="info">Toy Info</TabsTrigger>
                </TabsList>
                
                <TabsContent value="chat" className="mt-4">
                  <ChatInterface
                    toyId={selectedToy._id}
                    toy={selectedToy}
                    isGuardianMode={selectedToy.isForKids}
                  />
                </TabsContent>
                
                <TabsContent value="info" className="mt-4">
                  <Card className="p-6">
                    <h3 className="text-xl font-semibold mb-4">Toy Information</h3>
                    <div className="space-y-4">
                      <div>
                        <p className="text-sm text-gray-500">Name</p>
                        <p className="font-medium">{selectedToy.name}</p>
                      </div>
                      <div>
                        <p className="text-sm text-gray-500">Type</p>
                        <p className="font-medium capitalize">{selectedToy.type}</p>
                      </div>
                      <div>
                        <p className="text-sm text-gray-500">Mode</p>
                        <p className="font-medium">
                          {selectedToy.isForKids ? 'Guardian Mode (For Kids)' : 'General Mode'}
                        </p>
                      </div>
                      {selectedToy.personalityPrompt && (
                        <div>
                          <p className="text-sm text-gray-500">Personality</p>
                          <p className="text-sm mt-1">{selectedToy.personalityPrompt}</p>
                        </div>
                      )}
                    </div>
                  </Card>
                </TabsContent>
              </Tabs>
            ) : (
              <Card className="p-8 text-center">
                <p className="text-gray-600">Select a toy to start chatting</p>
              </Card>
            )}
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/app/dashboard/history/page.tsx">
'use client';

import { ConversationViewer } from '@/components/history/ConversationViewer';
import { Button } from '@/components/ui/button';
import { ArrowLeft } from 'lucide-react';
import Link from 'next/link';

/**
 * Conversation History Page
 * - Pixel title and token-based spacing.
 */
export default function ConversationHistoryPage() {
  return (
    <div className="min-h-screen bg-gray-50">
<div className="container mx-auto px-[var(--spacing-md)] py-[var(--spacing-xl)] max-w-7xl">
        {/* Header */}
        <div className="mb-6">
          <Link href="/dashboard">
            <Button variant="ghost" size="sm" className="mb-4">
              <ArrowLeft className="w-4 h-4 mr-2" />
              Back to Dashboard
            </Button>
          </Link>
          
          <div className="flex items-center justify-between">
            <div>
<h1 className="font-minecraft text-base sm:text-lg lg:text-xl font-black text-gray-900">
                Conversation History
              </h1>
              <p className="text-gray-600 mt-2">
                View and analyze all conversations with your AI toys
              </p>
            </div>
          </div>
        </div>

        {/* Conversation Viewer */}
        <ConversationViewer isGuardianMode={true} />
      </div>
    </div>
  );
}
</file>

<file path="src/app/dashboard/page.tsx">
'use client';

import { useState, type ChangeEvent } from 'react';
import { useRouter } from 'next/navigation';
import { Card, Button, Tabs, TabsList, TabsTrigger, TabsContent, Input } from '@pommai/ui';
import Link from 'next/link';
import Image from 'next/image';
import { ToyWizard } from '@/components/dashboard/ToyWizard';
import { MyToysGrid } from '@/components/dashboard/MyToysGrid';
import { GuardianDashboard } from '@/components/guardian/GuardianDashboard';
import { Checkbox } from '@/components/ui/checkbox';
import { useQuery } from 'convex/react';
import { api } from '../../../convex/_generated/api';

export default function DashboardPage() {
  const router = useRouter();
  const [activeTab, setActiveTab] = useState('toys');
  const [isGuardianMode, setIsGuardianMode] = useState(false);
  const [selectedTraits, setSelectedTraits] = useState<string[]>([]);
  const [selectedVoice, setSelectedVoice] = useState('');
  
  const toggleTrait = (trait: string) => {
    setSelectedTraits(prev => 
      prev.includes(trait) 
        ? prev.filter(t => t !== trait)
        : [...prev, trait]
    );
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-[#fefcd0] to-[#f4e5d3] dashboard-page">
      {/* Navigation Header */}
      <header className="border-b-[5px] border-black bg-white shadow-[0_4px_0_0_#c381b5]">
        <div className="container mx-auto px-[var(--spacing-md)] py-[var(--spacing-md)]">
          <div className="flex justify-between items-center">
            <Link href="/" className="flex items-center gap-3 hover-lift transition-transform">
              <Image src="/pommaiicon.png" alt="Pommai Logo" width={40} height={40} className="h-8 w-8 sm:h-10 sm:w-10 pixelated" />
              <Image src="/pommaitext.png" alt="Pommai" width={140} height={32} className="h-6 sm:h-8 pixelated" />
            </Link>
            
            {/* Mobile-friendly navigation */}
            <nav className="flex items-center gap-2 sm:gap-4">
              <div className="hidden sm:flex items-center gap-3">
                <span className="text-xl sm:text-2xl"></span>
                <span className="font-geo text-black font-bold text-xs sm:text-sm uppercase tracking-wider">Welcome!</span>
              </div>
              <div className="flex items-center gap-2 sm:gap-3">
                <Button
                  bg="#c381b5"
                  textColor="white"
                  borderColor="black"
                  shadow="#8b5fa3"
                  className="py-2 px-2 sm:px-4 text-xs sm:text-sm font-minecraft font-black uppercase tracking-wider hover-lift"
                  onClick={() => router.push('/dashboard/history')}
                >
                  <span className="flex items-center gap-1 sm:gap-2">
                    <span></span>
                    <span className="hidden sm:inline">History</span>
                  </span>
                </Button>
                <Button 
                  bg="#ff6b6b"
                  textColor="white"
                  borderColor="black"
                  shadow="#e84545"
                  className="py-2 px-2 sm:px-4 text-xs sm:text-sm font-minecraft font-black uppercase tracking-wider hover-lift"
                >
                  <span className="flex items-center gap-1 sm:gap-2">
                    <span></span>
                    <span className="hidden sm:inline">Sign Out</span>
                  </span>
                </Button>
              </div>
            </nav>
          </div>
        </div>
      </header>

      <div className="container mx-auto px-[var(--spacing-md)] max-w-7xl py-[var(--spacing-md)] sm:py-[var(--spacing-lg)] lg:py-[var(--spacing-xl)]">
        {/* Dashboard Header with better mobile spacing */}
        <div className="mb-[var(--spacing-lg)] sm:mb-[var(--spacing-xl)] lg:mb-[var(--spacing-2xl)] relative">
          <div className="flex flex-col sm:flex-row items-start justify-between gap-4">
            <div className="text-center sm:text-left">
              <h1 className="font-minecraft text-lg sm:text-xl lg:text-2xl mb-2 sm:mb-4 uppercase tracking-wider text-gray-800"
                style={{
                  textShadow: '2px 2px 0 #c381b5, 4px 4px 0 #92cd41'
                }}
              >
                My AI Toys
              </h1>
              <p className="font-geo text-gray-600 text-sm sm:text-base font-medium tracking-wide">Create magical companions for endless fun!</p>
            </div>
            <div className="hidden lg:block text-6xl xl:text-8xl animate-bounce" style={{ animationDuration: '3s' }}>
              
            </div>
          </div>
        </div>

        {/* Stats Cards - Mobile-Responsive Layout */}
        <div className="grid grid-cols-2 lg:grid-cols-4 gap-[var(--spacing-sm)] sm:gap-[var(--spacing-md)] lg:gap-[var(--spacing-lg)] mb-[var(--spacing-xl)] sm:mb-[var(--spacing-2xl)] lg:mb-[var(--spacing-3xl)]">
          <Card 
            bg="#ffffff" 
            borderColor="black" 
            shadowColor="#c381b5"
            className="p-3 sm:p-4 lg:p-6 hover-lift transition-transform cursor-pointer group"
            onClick={() => setActiveTab('toys')}
          >
            <div className="flex justify-between items-start mb-2 sm:mb-3 lg:mb-4">
              <span className="text-2xl sm:text-3xl lg:text-4xl group-hover:animate-pulse"></span>
              <span className="text-2xl sm:text-3xl lg:text-5xl font-black">0</span>
            </div>
            <h3 className="font-geo text-xs sm:text-sm font-semibold uppercase tracking-wider text-gray-600 mb-1">My Toys</h3>
            <p className="font-geo text-xs text-gray-500 hidden sm:block">Click to view</p>
          </Card>
          
          <Card 
            bg="#ffffff" 
            borderColor="black" 
            shadowColor="#92cd41"
            className="p-3 sm:p-4 lg:p-6 hover-lift transition-transform cursor-pointer group"
            onClick={() => setActiveTab('devices')}
          >
            <div className="flex justify-between items-start mb-2 sm:mb-3 lg:mb-4">
              <span className="text-2xl sm:text-3xl lg:text-4xl group-hover:animate-pulse"></span>
              <span className="text-2xl sm:text-3xl lg:text-5xl font-black">0</span>
            </div>
            <h3 className="font-geo text-xs sm:text-sm font-semibold uppercase tracking-wider text-gray-600 mb-1">Devices</h3>
            <p className="font-geo text-xs text-gray-500 hidden sm:block">No connections</p>
          </Card>
          
          <Card 
            bg="#ffffff" 
            borderColor="black" 
            shadowColor="#f7931e"
            className="p-3 sm:p-4 lg:p-6 hover-lift transition-transform cursor-pointer group"
            onClick={() => router.push('/dashboard/chat')}
          >
            <div className="flex justify-between items-start mb-2 sm:mb-3 lg:mb-4">
              <span className="text-2xl sm:text-3xl lg:text-4xl group-hover:animate-pulse"></span>
              <span className="text-2xl sm:text-3xl lg:text-5xl font-black">0</span>
            </div>
            <h3 className="font-geo text-xs sm:text-sm font-semibold uppercase tracking-wider text-gray-600 mb-1">Chats Today</h3>
            <p className="font-geo text-xs text-gray-500 hidden sm:block">Start talking!</p>
          </Card>
          
          <Card 
            bg={isGuardianMode ? "#c381b5" : "#ffffff"} 
            borderColor="black" 
            shadowColor={isGuardianMode ? "#8b5fa3" : "#ff6b6b"}
            className="p-3 sm:p-4 lg:p-6 cursor-pointer hover-lift transition-all group relative overflow-hidden"
            onClick={() => setIsGuardianMode(!isGuardianMode)}
          >
            {isGuardianMode && (
              <div className="absolute inset-0 opacity-20">
                <div className="animate-pulse bg-gradient-to-br from-purple-400 to-pink-400 h-full w-full" />
              </div>
            )}
            <div className="flex justify-between items-start mb-2 sm:mb-3 lg:mb-4 relative z-10">
              <span className="text-2xl sm:text-3xl lg:text-4xl group-hover:animate-spin" style={{ animationDuration: '2s' }}></span>
              <span className={`text-lg sm:text-xl lg:text-3xl font-black ${ isGuardianMode ? 'text-white' : 'text-black'}`}>
                {isGuardianMode ? 'ON' : 'OFF'}
              </span>
            </div>
            <h3 className={`font-geo text-xs sm:text-sm font-semibold uppercase tracking-wider relative z-10 mb-1 ${isGuardianMode ? 'text-white' : 'text-gray-600'}`}>
              Guardian
            </h3>
            <p className={`font-geo text-xs relative z-10 hidden sm:block ${isGuardianMode ? 'text-white opacity-90' : 'text-gray-500'}`}>
              {isGuardianMode ? 'Protected' : 'Click to enable'}
            </p>
          </Card>
        </div>

        {/* Main Content Tabs - Mobile-Enhanced */}
        <Tabs value={activeTab} onValueChange={setActiveTab}>
          <TabsList 
            className="mb-[var(--spacing-lg)] sm:mb-[var(--spacing-xl)] w-full flex flex-wrap justify-center gap-[var(--spacing-xs)] sm:gap-[var(--spacing-sm)] p-[var(--spacing-sm)]" 
            bg="#ffffff"
            shadowColor="#c381b5"
          >
            <TabsTrigger value="toys" className="font-minecraft flex items-center gap-1 sm:gap-2 px-3 sm:px-4 py-2 text-xs sm:text-sm font-black hover-lift uppercase tracking-wider">
              <span></span> <span className="hidden sm:inline">My </span>Toys
            </TabsTrigger>
            <TabsTrigger value="create" className="font-minecraft flex items-center gap-1 sm:gap-2 px-3 sm:px-4 py-2 text-xs sm:text-sm font-black hover-lift uppercase tracking-wider">
              <span></span> Create
            </TabsTrigger>
            <TabsTrigger value="devices" className="font-minecraft flex items-center gap-1 sm:gap-2 px-3 sm:px-4 py-2 text-xs sm:text-sm font-black hover-lift uppercase tracking-wider">
              <span></span> <span className="hidden sm:inline">Devices</span><span className="sm:hidden">Dev</span>
            </TabsTrigger>
            {isGuardianMode && (
              <TabsTrigger value="guardian" className="font-minecraft flex items-center gap-1 sm:gap-2 px-3 sm:px-4 py-2 text-xs sm:text-sm font-black hover-lift uppercase tracking-wider">
                <span></span> <span className="hidden sm:inline">Guardian</span><span className="sm:hidden">Guard</span>
              </TabsTrigger>
            )}
            <TabsTrigger value="settings" className="font-minecraft flex items-center gap-1 sm:gap-2 px-3 sm:px-4 py-2 text-xs sm:text-sm font-black hover-lift uppercase tracking-wider">
              <span></span> <span className="hidden sm:inline">Settings</span><span className="sm:hidden">Set</span>
            </TabsTrigger>
          </TabsList>

          <TabsContent value="toys">
            <MyToysGrid onCreateToy={() => setActiveTab('create')} />
          </TabsContent>

          <TabsContent value="create">
            <ToyWizard />
          </TabsContent>

          <TabsContent value="devices">
            <div className="space-y-8">
              <Card 
                bg="#ffffff" 
                borderColor="black" 
                shadowColor="#f7931e"
                className="p-[var(--spacing-xl)] text-center hover-lift"
              >
                <h2 className="font-minecraft text-base sm:text-lg lg:text-xl font-black mb-6 uppercase tracking-wider text-gray-800">Device Hub</h2>
                <div className="inline-block relative mb-8">
                  <span className="text-8xl"></span>
                  <span className="absolute -bottom-2 -right-2 text-3xl animate-pulse"></span>
                </div>
                <p className="font-geo text-base font-medium text-gray-700 mb-2">No devices connected</p>
                <p className="font-geo text-sm text-gray-600 mb-8">Connect a Raspberry Pi to bring your toys to life!</p>
                <div className="flex flex-col sm:flex-row gap-4 justify-center">
                  <Button 
                    bg="#f7931e" 
                    textColor="white" 
                    shadow="#d47a1a"
                    borderColor="black"
                    className="font-minecraft font-black uppercase tracking-wider hover-lift"
                  >
                    <span className="flex items-center gap-2">
                      <span></span> Setup Guide
                    </span>
                  </Button>
                  <Button 
                    bg="#92cd41" 
                    textColor="white" 
                    shadow="#76a83a"
                    borderColor="black"
                    className="font-minecraft font-black uppercase tracking-wider hover-lift"
                  >
                    <span className="flex items-center gap-2">
                      <span></span> Scan for Devices
                    </span>
                  </Button>
                </div>
              </Card>
              
              {/* Device Requirements Card */}
              <Card 
                bg="#fef8e4" 
                borderColor="black" 
                shadowColor="#f7931e"
                className="p-6"
              >
                <h3 className="font-minecraft text-base sm:text-lg font-black mb-4 uppercase tracking-wider flex items-center gap-2 text-gray-800">
                  <span></span> What You&apos;ll Need
                </h3>
                <div className="grid md:grid-cols-3 gap-4">
                  <div className="text-center">
                    <span className="text-4xl block mb-2"></span>
                    <p className="font-geo font-semibold text-gray-800">Raspberry Pi</p>
                    <p className="font-geo text-sm text-gray-600">Any model works!</p>
                  </div>
                  <div className="text-center">
                    <span className="text-4xl block mb-2"></span>
                    <p className="font-geo font-semibold text-gray-800">Microphone</p>
                    <p className="font-geo text-sm text-gray-600">USB or GPIO</p>
                  </div>
                  <div className="text-center">
                    <span className="text-4xl block mb-2"></span>
                    <p className="font-geo font-semibold text-gray-800">Speaker</p>
                    <p className="font-geo text-sm text-gray-600">3.5mm or Bluetooth</p>
                  </div>
                </div>
              </Card>
            </div>
          </TabsContent>

          {isGuardianMode && (
            <TabsContent value="guardian">
              <GuardianDashboard />
            </TabsContent>
          )}

          <TabsContent value="history">
            <Card 
              bg="#ffffff" 
              borderColor="black" 
              shadowColor="#c381b5"
              className="p-6"
            >
              <h2 className="font-minecraft text-xl sm:text-2xl font-black mb-6">Interaction History</h2>
              <div className="text-center py-12 text-gray-500">
                <p className="font-geo">No interactions recorded yet.</p>
                <p className="font-geo mt-2">Voice interactions will appear here once your child starts using Pommai.</p>
              </div>
            </Card>
          </TabsContent>

          <TabsContent value="settings">
            <div className="max-w-5xl mx-auto space-y-8">
              <Card 
                bg="#ffffff" 
                borderColor="black" 
                shadowColor="#c381b5"
                className="p-8 hover-lift"
              >
                <div className="text-center mb-10">
                  <h2 className="font-minecraft text-base sm:text-lg lg:text-xl font-black mb-4 uppercase tracking-wider text-gray-800"
                    style={{
                      textShadow: '2px 2px 0 #c381b5'
                    }}
                  >
                    Settings & Account
                  </h2>
                </div>
                
                <div className="grid md:grid-cols-2 gap-8">
                  <div className="space-y-6">
                    <h3 className="font-minecraft font-black text-base uppercase tracking-wider flex items-center gap-2 text-gray-800">
                      <span className="text-2xl"></span> Profile
                    </h3>
                    
                    <Card
                      bg="#fef8e4"
                      borderColor="black"
                      shadowColor="#e0e0e0"
                      className="p-5 space-y-4"
                    >
                      <div>
                        <label className="font-geo block text-sm font-semibold mb-2 uppercase tracking-wider text-gray-700">Email</label>
                        <Input 
                          type="email" 
                          defaultValue="user@example.com" 
                          bg="#ffffff"
                          borderColor="black"
                          disabled
                          readOnly
                          className="font-geo font-medium"
                        />
                      </div>
                      
                      <div>
                        <label className="font-geo block text-sm font-semibold mb-2 uppercase tracking-wider text-gray-700">Username</label>
                        <Input 
                          defaultValue="PommaiParent123" 
                          bg="#ffffff"
                          borderColor="black"
                          className="font-geo font-medium"
                          onChange={(e: ChangeEvent<HTMLInputElement>) => console.log('Username changed:', e.target.value)}
                        />
                      </div>
                    </Card>
                    
                    <Card
                      bg="#c381b5"
                      borderColor="black"
                      shadowColor="#8b5fa3"
                      className="p-5 text-white"
                    >
                      <div className="flex items-start justify-between">
                        <div>
                          <h4 className="font-minecraft font-black text-base uppercase tracking-wider mb-2">Free Plan</h4>
                          <p className="font-geo text-sm opacity-90">1 AI Toy  Basic Features</p>
                        </div>
                        <span className="text-3xl"></span>
                      </div>
                      <Button 
                        bg="#92cd41" 
                        textColor="white" 
                        shadow="#76a83a"
                        borderColor="black"
                        className="mt-4 w-full font-minecraft font-black uppercase tracking-wider"
                      >
                        <span className="flex items-center justify-center gap-2">
                          <span></span> Upgrade to Pro
                        </span>
                      </Button>
                    </Card>
                  </div>
                  
                  <div className="space-y-6">
                    <h3 className="font-minecraft font-black text-base uppercase tracking-wider flex items-center gap-2 text-gray-800">
                      <span className="text-2xl"></span> Preferences
                    </h3>
                    
                    <Card
                      bg="#fef8e4"
                      borderColor="black"
                      shadowColor="#e0e0e0"
                      className="p-5"
                    >
                      <h4 className="font-minecraft font-black mb-4 uppercase tracking-wider flex items-center gap-2 text-gray-800">
                        <span></span> Notifications
                      </h4>
                      <div className="space-y-3">
                        {[
                          { label: 'Toy activity alerts', icon: '', checked: true },
                          { label: 'Weekly usage reports', icon: '', checked: false },
                          { label: 'Security notifications', icon: '', checked: true },
                          { label: 'New feature updates', icon: '', checked: true }
                        ].map(({ label, icon, checked }) => (
                          <label key={label} className="flex items-center cursor-pointer p-2 hover:bg-white rounded transition-colors">
                            <Checkbox className="mr-3" defaultChecked={checked} />
                            <span className="font-geo flex-1 font-medium">{label}</span>
                            <span className="text-xl">{icon}</span>
                          </label>
                        ))}
                      </div>
                    </Card>
                    
                    <Card
                      bg="#ffe4e1"
                      borderColor="black"
                      shadowColor="#ff6b6b"
                      className="p-5"
                    >
                      <h4 className="font-minecraft font-black mb-4 uppercase tracking-wider flex items-center gap-2 text-gray-800">
                        <span></span> Default Toy Settings
                      </h4>
                      <div className="space-y-3">
                        {[
                          { label: 'Auto-enable Guardian Mode', icon: '', checked: false },
                          { label: 'Require device confirmation', icon: '', checked: true },
                          { label: 'Daily conversation limits', icon: '', checked: false },
                          { label: 'Educational mode by default', icon: '', checked: true }
                        ].map(({ label, icon, checked }) => (
                          <label key={label} className="flex items-center cursor-pointer p-2 hover:bg-white rounded transition-colors">
                            <Checkbox className="mr-3" defaultChecked={checked} />
                            <span className="font-geo flex-1 font-medium">{label}</span>
                            <span className="text-xl">{icon}</span>
                          </label>
                        ))}
                      </div>
                    </Card>
                  </div>
                </div>
                
                <div className="mt-10 pt-8 border-t-[5px] border-black flex justify-center gap-6">
                  <Button 
                    bg="#92cd41" 
                    textColor="white" 
                    shadow="#76a83a"
                    borderColor="black"
                    className="px-8 py-3 font-minecraft font-black uppercase tracking-wider hover-lift transition-transform"
                  >
                    <span className="flex items-center gap-2">
                      <span></span> Save Changes
                    </span>
                  </Button>
                  <Button 
                    bg="#f0f0f0" 
                    textColor="black" 
                    shadow="#d0d0d0"
                    borderColor="black"
                    className="px-8 py-3 font-minecraft font-black uppercase tracking-wider hover-lift"
                  >
                    Cancel
                  </Button>
                </div>
              </Card>
            </div>
          </TabsContent>
        </Tabs>
      </div>
    </div>
  );
}
</file>

<file path="src/app/dashboard/toys/edit/[toyId]/page.tsx">
'use client';

import { useParams, useRouter } from 'next/navigation';
import { useQuery } from 'convex/react';
import { api } from '../../../../../../convex/_generated/api';
import { type Id } from '../../../../../../convex/_generated/dataModel';
import { EditToyForm } from '@/components/dashboard/EditToyForm';
import { Button, Card } from '@pommai/ui';
import { ArrowLeft, Loader2 } from 'lucide-react';
import Link from 'next/link';
import Image from 'next/image';

export default function EditToyPage() {
  const params = useParams();
  const router = useRouter();
  const toyId = params.toyId as Id<'toys'>;

  const toy = useQuery(api.toys.getToy, toyId ? { toyId } : 'skip');

  const renderContent = () => {
    if (toy === undefined) {
      return (
        <div className="flex justify-center items-center h-64">
          <Loader2 className="w-12 h-12 animate-spin text-[#c381b5]" />
          <p className="ml-4 font-minecraft text-lg">Loading Toy...</p>
        </div>
      );
    }

    if (toy === null) {
      return (
        <Card bg="#ffe4e1" borderColor="red" shadowColor="#ff6b6b" className="p-8 text-center">
          <h2 className="font-minecraft text-xl text-red-700 mb-4 uppercase tracking-wider">Toy Not Found</h2>
          <p className="font-geo text-gray-700 mb-6">
            We couldn't find the toy you're looking for. It might have been deleted.
          </p>
          <Button 
            onClick={() => router.push('/dashboard')}
            bg="#c381b5"
            textColor="white"
            borderColor="black"
            shadow="#8b5fa3"
            className="font-minecraft font-black uppercase tracking-wider hover-lift"
          >
            Back to Dashboard
          </Button>
        </Card>
      );
    }

    return <EditToyForm toy={toy} />;
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-[#fefcd0] to-[#f4e5d3] dashboard-page">
      <header className="border-b-[5px] border-black bg-white shadow-[0_4px_0_0_#c381b5]">
        <div className="container mx-auto px-[var(--spacing-md)] py-[var(--spacing-md)]">
          <div className="flex justify-between items-center">
            <Link href="/" className="flex items-center gap-3 hover-lift transition-transform">
              <Image src="/pommaiicon.png" alt="Pommai Logo" width={40} height={40} className="h-8 w-8 sm:h-10 sm:w-10 pixelated" />
              <Image src="/pommaitext.png" alt="Pommai" width={140} height={32} className="h-6 sm:h-8 pixelated hidden sm:block" />
            </Link>
            <Button
              onClick={() => router.push('/dashboard')}
              bg="#fefcd0"
              textColor="black"
              borderColor="black"
              shadow="#c381b5"
              className="py-2 px-3 sm:px-4 font-minecraft font-black uppercase tracking-wider hover-lift text-xs sm:text-sm"
            >
              <ArrowLeft className="w-4 h-4 mr-2" />
              <span className="hidden sm:inline">Back to </span>Dashboard
            </Button>
          </div>
        </div>
      </header>

      <main className="container mx-auto px-[var(--spacing-md)] max-w-4xl py-[var(--spacing-md)] sm:py-[var(--spacing-lg)]">
        <div className="mb-[var(--spacing-lg)]">
          <h1 className="font-minecraft text-lg sm:text-xl lg:text-2xl mb-2 sm:mb-4 uppercase tracking-wider text-gray-800"
            style={{
              textShadow: '2px 2px 0 #c381b5, 4px 4px 0 #92cd41'
            }}
          >
            Edit Toy
          </h1>
          <p className="font-geo text-gray-600 text-sm sm:text-base font-medium tracking-wide">
            Update your AI companion's personality and settings
          </p>
        </div>
        {renderContent()}
      </main>
    </div>
  );
}
</file>

<file path="src/app/demo/page.tsx">
'use client';

import React, { useState } from 'react';
import {
  Button,
  Card,
  Input,
  TextArea,
  ProgressBar,
  Popup,
  Bubble,
  Accordion,
  AccordionItem,
  AccordionTrigger,
  AccordionContent
} from '@/components';
import {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuLabel,
  DropdownMenuItem,
  DropdownMenuSeparator,
} from '@/components/ui/dropdown-menu';

/**
 * RetroUI Demo Page
 * - Pixel headings for demo sections; spacing tokens for page padding.
 */
export default function DemoPage() {
  const [popupOpen, setPopupOpen] = useState(false);
  const [progress, setProgress] = useState(50);
  const [inputValue, setInputValue] = useState('');

  return (
<div className="p-[var(--spacing-xl)] space-y-8 bg-gray-100 min-h-screen">
<h1 className="font-minecraft text-base sm:text-lg lg:text-xl font-black mb-[var(--spacing-lg)]">RetroUI Components Demo</h1>

      {/* Button Component */}
      <section className="space-y-4">
<h2 className="font-minecraft text-base sm:text-lg lg:text-xl font-black">Button</h2>
        <div className="flex gap-4 flex-wrap">
          <Button 
            bg="#fefcd0"
            textColor="black"
            borderColor="black"
            shadow="#c381b5"
            onClick={() => alert('Default themed button clicked!')}
          >
            Default Button
          </Button>
          <Button
            bg="#c381b5"
            textColor="#fefcd0"
            borderColor="black"
            shadow="#fefcd0"
            onClick={() => alert('Purple button clicked!')}
          >
            Purple Button
          </Button>
          <Button
            bg="#92cd41"
            textColor="white"
            borderColor="black"
            shadow="#76a83a"
            onClick={() => alert('Green button clicked!')}
          >
            Green Button
          </Button>
        </div>
      </section>

      {/* Card Component */}
      <section className="space-y-4">
<h2 className="font-minecraft text-base sm:text-lg lg:text-xl font-black">Card</h2>
        <div className="flex gap-4 flex-wrap">
          <Card 
            bg="#fefcd0" 
            textColor="black" 
            borderColor="black" 
            shadowColor="#c381b5"
            className="max-w-xs"
          >
            <h3 className="font-bold mb-2">Default Card</h3>
            <p>This is a card with the default retro theme styling.</p>
          </Card>
          <Card 
            bg="#c381b5" 
            textColor="#fefcd0" 
            borderColor="black" 
            shadowColor="#fefcd0"
            className="max-w-xs"
          >
            <h3 className="font-bold mb-2">Purple Card</h3>
            <p>This card has inverted purple theme colors.</p>
          </Card>
        </div>
      </section>

      {/* Input Component */}
      <section className="space-y-4">
<h2 className="font-minecraft text-base sm:text-lg lg:text-xl font-black">Input</h2>
        <div className="flex gap-4 flex-wrap">
            <Input
              placeholder="Enter text..."
              value={inputValue}
              onChange={(e: React.ChangeEvent<HTMLInputElement>) => setInputValue(e.target.value)}
              bg="#fefcd0"
              textColor="black"
              borderColor="black"
            />
          <Input
            placeholder="Purple themed input..."
            bg="#c381b5"
            textColor="#fefcd0"
            borderColor="black"
          />
        </div>
      </section>

      {/* TextArea Component */}
      <section className="space-y-4">
<h2 className="font-minecraft text-base sm:text-lg lg:text-xl font-black">TextArea</h2>
        <TextArea
          placeholder="Enter your message here..."
          rows={4}
          className="max-w-md"
          bg="#fefcd0"
          textColor="black"
          borderColor="black"
        />
      </section>

      {/* ProgressBar Component */}
      <section className="space-y-4">
<h2 className="font-minecraft text-base sm:text-lg lg:text-xl font-black">ProgressBar</h2>
        <div className="space-y-2 max-w-md">
          <ProgressBar progress={progress} size="sm" color="#92cd41" borderColor="black" />
          <ProgressBar progress={progress} size="md" color="#c381b5" borderColor="black" />
          <ProgressBar progress={progress} size="lg" color="#fefcd0" borderColor="black" />
          <div className="flex gap-2 mt-4">
            <Button 
              bg="#fefcd0"
              textColor="black"
              borderColor="black"
              shadow="#c381b5"
              onClick={() => setProgress(Math.max(0, progress - 10))}
            >
              -10
            </Button>
            <Button 
              bg="#fefcd0"
              textColor="black"
              borderColor="black"
              shadow="#c381b5"
              onClick={() => setProgress(Math.min(100, progress + 10))}
            >
              +10
            </Button>
          </div>
        </div>
      </section>

      {/* Popup Component */}
      <section className="space-y-4">
<h2 className="font-minecraft text-base sm:text-lg lg:text-xl font-black">Popup</h2>
        <Button 
          bg="#fefcd0"
          textColor="black"
          borderColor="black"
          shadow="#c381b5"
          onClick={() => setPopupOpen(true)}
        >
          Open Popup
        </Button>
        <Popup
          isOpen={popupOpen}
          onClose={() => setPopupOpen(false)}
          title="Hello RetroUI!"
          bg="#fefcd0"
          textColor="black"
          borderColor="black"
        >
          <p>This is a pixel-perfect popup component!</p>
          <p className="mt-2">Click the X or outside to close.</p>
        </Popup>
      </section>

      {/* Dropdown Component */}
      <section className="space-y-4">
<h2 className="font-minecraft text-base sm:text-lg lg:text-xl font-black">Dropdown</h2>
        <DropdownMenu>
          <DropdownMenuTrigger asChild>
            <Button
              bg="#fefcd0"
              textColor="black"
              borderColor="black"
              shadow="#c381b5"
            >
              Open Menu
            </Button>
          </DropdownMenuTrigger>
          <DropdownMenuContent>
            <DropdownMenuLabel>Options</DropdownMenuLabel>
            <DropdownMenuItem>Profile</DropdownMenuItem>
            <DropdownMenuItem>Settings</DropdownMenuItem>
            <DropdownMenuSeparator />
            <DropdownMenuItem>Logout</DropdownMenuItem>
          </DropdownMenuContent>
        </DropdownMenu>
      </section>

      {/* Bubble Component */}
      <section className="space-y-4">
<h2 className="font-minecraft text-base sm:text-lg lg:text-xl font-black">Bubble</h2>
        <div className="flex gap-8 flex-wrap">
          <Bubble 
            direction="left" 
            bg="#fefcd0"
            textColor="black"
            borderColor="black"
            onClick={() => alert('Left bubble clicked!')}
          >
            Speech bubble from the left
          </Bubble>
          <Bubble
            direction="right"
            bg="#c381b5"
            textColor="#fefcd0"
            borderColor="black"
            onClick={() => alert('Right bubble clicked!')}
          >
            Speech bubble from the right
          </Bubble>
        </div>
      </section>

      {/* Accordion Component */}
      <section className="space-y-4">
<h2 className="font-minecraft text-base sm:text-lg lg:text-xl font-black">Accordion</h2>
        <div className="max-w-md">
          <Accordion 
            collapsible
            bg="#fefcd0"
            textColor="black"
            borderColor="black"
            shadowColor="#c381b5"
          >
            <AccordionItem value="item-1">
              <AccordionTrigger>First Section</AccordionTrigger>
              <AccordionContent>
                <p>This is the content for the first accordion item.</p>
                <p>You can put any React components here.</p>
              </AccordionContent>
            </AccordionItem>
            <AccordionItem value="item-2">
              <AccordionTrigger>Second Section</AccordionTrigger>
              <AccordionContent>
                <p>This is the content for the second accordion item.</p>
                <p>The accordion is collapsible by default.</p>
              </AccordionContent>
            </AccordionItem>
            <AccordionItem value="item-3">
              <AccordionTrigger>Third Section</AccordionTrigger>
              <AccordionContent>
                <p>This is the content for the third accordion item.</p>
                <p>You can customize colors using props.</p>
              </AccordionContent>
            </AccordionItem>
          </Accordion>
        </div>
      </section>
    </div>
  );
}
</file>

<file path="src/app/forgot-password/page.tsx">
'use client';

import { useState, type ChangeEvent } from 'react';
import { Card, Button, Input } from '@pommai/ui';
import { authClient } from '../../lib/auth-client';
import { useRouter } from 'next/navigation';
import Link from 'next/link';
import Image from 'next/image';

export default function ForgotPasswordPage() {
  const [email, setEmail] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState(false);
  const router = useRouter();

  const handleRequestReset = async (e: React.FormEvent) => {
    e.preventDefault();
    setError(null);
    setIsLoading(true);

    try {
      await authClient.forgetPassword({
        email,
        redirectTo: '/reset-password',
      });
      setSuccess(true);
    } catch (err: unknown) {
      const message = err instanceof Error ? err.message : 'Failed to send reset email';
      setError(message);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="min-h-screen flex flex-col bg-gradient-to-br from-[#fefcd0] to-[#f4e5d3]">
      {/* Header */}
      <header className="border-b-4 border-black bg-white shadow-[0_4px_0_0_#c381b5]">
        <div className="container mx-auto px-4 py-4 sm:py-6">
          <Link href="/" className="flex items-center justify-center gap-2 sm:gap-3 hover-lift">
            <Image src="/pommaiicon.png" alt="Pommai Logo" width={48} height={48} className="h-10 w-10 sm:h-12 sm:w-12 pixelated" />
            <Image src="/pommaitext.png" alt="Pommai" width={160} height={40} className="h-8 sm:h-10 pixelated" />
          </Link>
        </div>
      </header>

      {/* Main Content */}
      <main className="flex-1 flex items-center justify-center p-4 sm:p-6">
        <div className="w-full max-w-sm">
          <Card 
            bg="#ffffff" 
            borderColor="black" 
            shadowColor="#c381b5"
            className="overflow-hidden hover-lift"
          >
            {/* Header Section */}
            <div className="bg-white border-b-4 border-black p-4 sm:p-5 text-center">
              <div className="text-6xl mb-3"></div>
              <h1 className="text-xs font-minecraft font-black uppercase tracking-wider mb-1 text-[#c381b5]">
                Forgot Password?
              </h1>
              <p className="text-xs font-geo font-semibold uppercase tracking-wide text-gray-700">
                No worries! We&apos;ll help you reset it
              </p>
            </div>
            
            {/* Form Container */}
            <div className="p-4 sm:p-6">
              {!success ? (
                <form onSubmit={handleRequestReset} className="space-y-4">
                    <p className="text-xs font-geo font-medium uppercase tracking-wide text-gray-600 text-center">
                      Enter your email address and we&apos;ll send you a link to reset your password.
                    </p>
                  
                  <div className="space-y-1">
                    <label className="text-xs font-geo font-semibold uppercase tracking-wider text-black">
                      Email Address
                    </label>
                    <Input 
                      type="email" 
                      placeholder="parent@example.com" 
                      value={email}
                      onChange={(e: ChangeEvent<HTMLInputElement>) => setEmail(e.target.value)}
                      bg="#fefcd0"
                      borderColor="black"
                      fontSize="12px"
                      className="text-xs py-1 px-2 font-minecraft font-medium border-2 w-full"
                      required
                    />
                  </div>

                  {error && (
                    <Card bg="#ffdddd" borderColor="red" shadowColor="#ff6b6b" className="p-3">
                      <p className="text-red-700 text-xs font-geo font-bold uppercase tracking-wide">
                        {error}
                      </p>
                    </Card>
                  )}
                  
                  <div className="space-y-3">
                    <Button 
                      type="submit"
                      bg="#e74c3c" 
                      textColor="white" 
                      shadow="#c0392b"
                      borderColor="black"
                      className="w-full py-3 text-xs sm:text-sm font-minecraft font-black tracking-wider border-2 hover:translate-y-[-2px] transition-transform"
                      disabled={isLoading}
                    >
                      {isLoading ? 'SENDING...' : 'SEND RESET LINK'}
                    </Button>
                    
                    <div className="text-center">
                      <Link 
                        href="/auth"
                        className="text-xs font-geo font-bold uppercase tracking-wider hover:underline transition-colors"
                        style={{ color: '#c381b5' }}
                      >
                        Back to Login
                      </Link>
                    </div>
                  </div>
                </form>
              ) : (
                <div className="text-center space-y-4">
                  <div className="text-6xl mb-4"></div>
                  <h2 className="text-lg font-minecraft font-black uppercase tracking-wider text-[#92cd41]">
                    Check Your Email!
                  </h2>
                  <Card bg="#e8f6f3" borderColor="#27ae60" shadowColor="#27ae60" className="p-4">
                    <p className="text-green-700 text-xs font-geo font-semibold uppercase tracking-wide">
                      We&apos;ve sent a password reset link to:
                    </p>
                    <p className="text-sm font-minecraft font-bold text-black mt-2">
                      {email}
                    </p>
                  </Card>
                  <p className="text-xs font-geo font-medium uppercase tracking-wide text-gray-600">
                    The link will expire in 1 hour for security reasons.
                  </p>
                  <div className="pt-4">
                    <Button
                      onClick={() => router.push('/auth')}
                      bg="#c381b5"
                      textColor="white"
                      shadow="#8b5fa3"
                      borderColor="black"
                      className="text-xs font-minecraft font-black tracking-wider border-2 px-6 py-2 hover:translate-y-[-2px] transition-transform"
                    >
                      BACK TO LOGIN
                    </Button>
                  </div>
                </div>
              )}
            </div>
          </Card>
        </div>
      </main>
    </div>
  );
}
</file>

<file path="src/app/globals.css">
@import "tailwindcss";
@import '@pommai/ui/src/styles/retroui.css';

/* Fonts are loaded via next/font in layout.tsx; no extra @font-face needed */

/* Fallback for Minecraft-style font */
.font-minecraft {
  font-family: "Press Start 2P", "Minecraft", monospace, sans-serif;
  font-weight: normal;
  -webkit-font-smoothing: none;
  -moz-osx-font-smoothing: unset;
}

/* Work Sans font for subheadings */
.font-geo {
  font-family: var(--font-geo), "Work Sans", sans-serif;
  font-weight: 500;
  letter-spacing: 0.015em;
}

:root {
  --background: #ffffff;
  --foreground: #171717;
  
  /* ========================================
   * PRIMARY POMMAI COLOR PALETTE
   * ======================================== */
  --pommai-cream: #fefcd0;
  --pommai-purple: #c381b5;
  --pommai-green: #92cd41;
  --pommai-orange: #f7931e;
  --pommai-dark-purple: #8b5fa3;
  --pommai-dark-green: #76a83a;
  --pommai-black: #000000;
  --pommai-white: #ffffff;
  --pommai-gray: #6b7280;
  --pommai-light-gray: #f3f4f6;
  --pommai-red: #ef4444;
  
  /* ========================================
   * RETROUI COMPONENT THEME VARIABLES
   * ======================================== */
  
  /* Button Component Variables */
  --bg-button: var(--pommai-cream);
  --text-button: var(--pommai-black);
  --shadow-button: var(--pommai-purple);
  --border-button: var(--pommai-black);
  --button-custom-bg: var(--bg-button);
  --button-custom-text: var(--text-button);
  --button-custom-shadow: var(--shadow-button);
  --button-custom-border: var(--border-button);
  
  /* Card Component Variables */
  --bg-card: var(--pommai-white);
  --text-card: var(--pommai-black);
  --shadow-card: var(--pommai-purple);
  --border-card: var(--pommai-black);
  --card-custom-bg: var(--bg-card);
  --card-custom-text: var(--text-card);
  --card-custom-shadow: var(--shadow-card);
  --card-custom-border: var(--border-card);
  
  /* Input Component Variables */
  --bg-input: var(--pommai-cream);
  --text-input: var(--pommai-black);
  --border-input: var(--pommai-black);
  --input-custom-bg: var(--bg-input);
  --input-custom-text: var(--text-input);
  --input-custom-border: var(--border-input);
  
  /* TextArea Component Variables */
  --bg-textarea: var(--pommai-cream);
  --text-textarea: var(--pommai-black);
  --border-textarea: var(--pommai-black);
  --textarea-custom-bg: var(--bg-textarea);
  --textarea-custom-text: var(--text-textarea);
  --textarea-custom-border: var(--border-textarea);
  
  /* ProgressBar Component Variables */
  --color-progressbar: var(--pommai-purple);
  --border-progressbar: var(--pommai-black);
  --progressbar-custom-color: var(--color-progressbar);
  --progressbar-custom-border-color: var(--border-progressbar);
  
  /* Popup Component Variables */
  --bg-popup-base: var(--pommai-cream);
  --bg-popup: var(--pommai-white);
  --text-popup: var(--pommai-black);
  --popup-overlay-bg: rgba(0, 0, 0, 0.5);
  --popup-base-bg: var(--bg-popup-base);
  --popup-bg: var(--bg-popup);
  --popup-text: var(--text-popup);
  
  /* Dropdown Component Variables */
  --bg-dropdown: var(--pommai-cream);
  --text-dropdown: var(--pommai-black);
  --border-dropdown: var(--pommai-black);
  --shadow-dropdown: var(--pommai-purple);
  --bg-dropdown-hover: #e0e0e0;
  --dropdown-custom-bg: var(--bg-dropdown);
  --dropdown-custom-text: var(--text-dropdown);
  --dropdown-custom-border: var(--border-dropdown);
  --dropdown-custom-shadow: var(--shadow-dropdown);
  --dropdown-content-custom-bg: var(--bg-dropdown);
  --dropdown-content-custom-text: var(--text-dropdown);
  --dropdown-content-custom-border: var(--border-dropdown);
  --dropdown-content-custom-shadow: var(--shadow-dropdown);
  
  /* Accordion Component Variables */
  --bg-accordion: var(--pommai-cream);
  --text-accordion: var(--pommai-black);
  --shadow-accordion: var(--pommai-purple);
  --accordion-custom-bg: var(--bg-accordion);
  --accordion-custom-text: var(--text-accordion);
  --accordion-custom-shadow: var(--shadow-accordion);
  --accordion-item-custom-bg: var(--bg-accordion);
  --accordion-item-custom-text: var(--text-accordion);
  --accordion-item-custom-shadow: var(--shadow-accordion);
  
  /* Bubble/Speech Balloon Variables */
  --bubble-bg-color: var(--pommai-white);
  --bubble-text-color: var(--pommai-black);
  --bubble-border-color: var(--pommai-black);
  
  /* ========================================
   * DESIGN SYSTEM TOKENS
   * ======================================== */
  
  /* Spacing System */
  --spacing-xs: 0.25rem;  /* 4px */
  --spacing-sm: 0.5rem;   /* 8px */
  --spacing-md: 1rem;     /* 16px */
  --spacing-lg: 1.5rem;   /* 24px */
  --spacing-xl: 2rem;     /* 32px */
  --spacing-2xl: 3rem;    /* 48px */
  --spacing-3xl: 4rem;    /* 64px */
  
  /* Border Radius System */
  --radius-none: 0;
  --radius-sm: 2px;
  --radius-md: 4px;
  --radius-lg: 8px;
  
  /* Typography Scale */
  --text-xs: 0.75rem;     /* 12px */
  --text-sm: 0.875rem;    /* 14px */
  --text-base: 1rem;      /* 16px */
  --text-lg: 1.125rem;    /* 18px */
  --text-xl: 1.25rem;     /* 20px */
  --text-2xl: 1.5rem;     /* 24px */
  --text-3xl: 1.875rem;   /* 30px */
  --text-4xl: 2.25rem;    /* 36px */
  --text-5xl: 3rem;       /* 48px */
  --text-6xl: 3.75rem;    /* 60px */
  
  /* Z-Index Scale */
  --z-dropdown: 1000;
  --z-modal: 1040;
  --z-popover: 1050;
  --z-tooltip: 1060;
  --z-toast: 1070;
  
  /* Shadow System */
  --shadow-sm: 2px 2px 0 0;
  --shadow-md: 3px 3px 0 0;
  --shadow-lg: 4px 4px 0 0;
  --shadow-xl: 6px 6px 0 0;
  
  /* Border System */
  --border-thin: 2px;
  --border-medium: 3px;
  --border-thick: 4px;
  --border-extra-thick: 5px;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}

/* Dark mode disabled for consistent UI appearance
@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}
*/

body {
  background: var(--background);
  color: var(--foreground);
  font-family: var(--font-geo), "Work Sans", Arial, Helvetica, sans-serif;
  line-height: 1.6;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

/* Typography System */
/* Pixel headings: apply explicitly via classes to avoid global overrides */
.heading-pixel, .retro-heading, .main-title {
  font-family: var(--font-minecraft), "Press Start 2P", "Minecraft", Arial, Helvetica, sans-serif;
  font-weight: normal;
  letter-spacing: 0.05em;
  margin: 0;
  line-height: 1.3;
  -webkit-font-smoothing: none;
  -moz-osx-font-smoothing: unset;
}

/* Subheadings/body headings */
.heading-sub, .sub-heading {
  font-family: var(--font-geo), "Work Sans", sans-serif;
  font-weight: 600;
  letter-spacing: 0.02em;
  margin: 0;
  line-height: 1.4;
}

/* Optional: retro-styled h3 utility (uses Work Sans for readability) */
.retro-h3 {
  font-family: var(--font-geo), "Work Sans", sans-serif;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.06em;
  line-height: 1.35;
  text-shadow: 2px 2px 0 var(--pommai-purple);
}
/* Accent utilities for retro text shadows */
.retro-shadow-green { text-shadow: 2px 2px 0 var(--pommai-green); }
.retro-shadow-orange { text-shadow: 2px 2px 0 var(--pommai-orange); }

/* Optional text size utility classes (use Tailwind text-* utilities by default) */
.text-body { font-size: var(--text-base); }
.text-small { font-size: var(--text-sm); }
.text-tiny { font-size: var(--text-xs); }

/* Spacing Utilities */
.space-xs { margin: var(--spacing-xs); }
.space-sm { margin: var(--spacing-sm); }
.space-md { margin: var(--spacing-md); }
.space-lg { margin: var(--spacing-lg); }
.space-xl { margin: var(--spacing-xl); }
.space-2xl { margin: var(--spacing-2xl); }
.space-3xl { margin: var(--spacing-3xl); }

.gap-xs { gap: var(--spacing-xs); }
.gap-sm { gap: var(--spacing-sm); }
.gap-md { gap: var(--spacing-md); }
.gap-lg { gap: var(--spacing-lg); }
.gap-xl { gap: var(--spacing-xl); }
.gap-2xl { gap: var(--spacing-2xl); }
.gap-3xl { gap: var(--spacing-3xl); }

.p-xs { padding: var(--spacing-xs); }
.p-sm { padding: var(--spacing-sm); }
.p-md { padding: var(--spacing-md); }
.p-lg { padding: var(--spacing-lg); }
.p-xl { padding: var(--spacing-xl); }
.p-2xl { padding: var(--spacing-2xl); }
.p-3xl { padding: var(--spacing-3xl); }

.m-xs { margin: var(--spacing-xs); }
.m-sm { margin: var(--spacing-sm); }
.m-md { margin: var(--spacing-md); }
.m-lg { margin: var(--spacing-lg); }
.m-xl { margin: var(--spacing-xl); }
.m-2xl { margin: var(--spacing-2xl); }
.m-3xl { margin: var(--spacing-3xl); }

/* Pixel Select Styles */
.pixel-select-trigger {
  border-image-slice: 3;
  border-image-width: 3px;
  border-image-repeat: stretch;
  border-image-source: url('data:image/svg+xml;utf8,<svg width="6" height="6" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="2" width="2" height="2" fill="%23333"/></svg>');
  border-image-outset: 1;
}

.pixel-select-content {
  border-image-slice: 3;
  border-image-width: 3px;
  border-image-repeat: stretch;
  border-image-source: url('data:image/svg+xml;utf8,<svg width="6" height="6" xmlns="http://www.w3.org/2000/svg"><rect x="2" y="2" width="2" height="2" fill="%23333"/></svg>');
  border-image-outset: 1;
  box-shadow: 3px 3px 0 0 var(--shadow-dropdown);
}

/* Pixelated images */
.pixelated {
  image-rendering: pixelated;
  image-rendering: -moz-crisp-edges;
  image-rendering: crisp-edges;
}











/* Touch-friendly interactions */
@media (hover: none) {
  .hover-lift:hover {
    transform: none;
  }
  
  .hover-lift:active {
    transform: scale(0.98);
  }
  
  .pixel-button:hover {
    transform: none;
  }
  
  .pixel-button:active {
    transform: translateY(2px);
  }
}

/* Use Tailwind responsive utilities (sm:, md:, lg:) instead of custom responsive classes */


/* Enhanced Pixel Radio and Checkbox styles */
.pixel-checkbox,
.pixel-radio {
  appearance: none;
  width: 20px;
  height: 20px;
  border: 3px solid var(--pommai-black);
  background-color: var(--pommai-cream);
  position: relative;
  cursor: pointer;
  transition: all 0.1s ease;
  image-rendering: pixelated;
  image-rendering: -moz-crisp-edges;
  image-rendering: crisp-edges;
}

/* Removed page-specific overrides. Size and fonts are controlled via component classes */

.pixel-checkbox:checked,
.pixel-radio:checked {
  background-color: var(--pommai-purple);
}

.pixel-checkbox:checked::before,
.pixel-radio:checked::before {
  content: '';
  position: absolute;
  inset: 3px;
  background-color: var(--pommai-black);
  image-rendering: pixelated;
}

.pixel-checkbox:hover,
.pixel-radio:hover {
  transform: translateY(-1px);
  box-shadow: 0 2px 0 var(--pommai-black);
}

.pixel-checkbox:active,
.pixel-radio:active {
  transform: translateY(1px);
  box-shadow: none;
}

/* Form labels */
.form-label {
  font-size: var(--text-sm);
  font-weight: bold;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  color: var(--pommai-black);
  margin-bottom: var(--spacing-sm);
  display: block;
}

.form-help {
  font-size: var(--text-xs);
  color: var(--pommai-gray);
  margin-top: var(--spacing-xs);
}

/* Pixel border for cards and inputs */
.pixel-border {
  border: 5px solid black;
  position: relative;
}

.pixel-border::before {
  content: '';
  position: absolute;
  inset: -1px;
  background: 
    linear-gradient(to right, black 1px, transparent 1px),
    linear-gradient(to bottom, black 1px, transparent 1px);
  background-size: 4px 4px;
  pointer-events: none;
}

/* Enhanced animations */
@keyframes pixel-bounce {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-4px); }
}

@keyframes pixel-shake {
  0%, 100% { transform: translateX(0); }
  25% { transform: translateX(-2px); }
  75% { transform: translateX(2px); }
}

@keyframes pixel-glow {
  0%, 100% { box-shadow: 0 0 0 var(--pommai-purple); }
  50% { box-shadow: 0 0 8px var(--pommai-purple); }
}

.pixel-bounce {
  animation: pixel-bounce 0.5s ease-in-out;
}

.pixel-shake {
  animation: pixel-shake 0.3s ease-in-out;
}

.pixel-glow {
  animation: pixel-glow 2s ease-in-out infinite;
}

/* Hover effects */
.hover-lift:hover {
  transform: translateY(-2px);
  transition: transform 0.1s ease;
}

.hover-press:active {
  transform: translateY(2px);
  transition: transform 0.05s ease;
}

/* Loading states */
.loading-pulse {
  animation: pulse 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}

/* Tab improvements */
.tab-pixel {
  position: relative;
  overflow: hidden;
}

.tab-pixel::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  height: 4px;
  background-color: var(--shadow-button);
  transform: scaleX(0);
  transition: transform 0.3s ease;
}

.tab-pixel[data-state="active"]::after {
  transform: scaleX(1);
}
</file>

<file path="src/app/layout.tsx">
import type { Metadata } from "next";
import { Geist, Geist_Mono, Press_Start_2P, Work_Sans } from "next/font/google";
import "./globals.css";
import { ConvexClientProvider } from './providers/ConvexClientProvider';

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

const pressStart2P = Press_Start_2P({
  variable: "--font-minecraft",
  subsets: ["latin"],
  weight: "400",
});

// Using Work Sans as a geometric alternative to Geo - clean, modern, highly readable
const geo = Work_Sans({
  variable: "--font-geo",
  subsets: ["latin"],
  weight: ["400", "500", "600", "700"],
});

export const metadata: Metadata = {
  title: "Pommai - Safe AI Voice Companion for Children",
  description: "An innovative voice-first AI assistant designed specifically for children, featuring advanced safety controls and educational interactions.",
  icons: {
    icon: '/pommaifaviconnn.png',
    apple: '/pommaifaviconnn.png',
  },
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} ${pressStart2P.variable} ${geo.variable} antialiased font-geo`}
      >
        <ConvexClientProvider>
          {children}
        </ConvexClientProvider>
      </body>
    </html>
  );
}
</file>

<file path="src/app/lib/pixel-retroui-setup.js">
// This file was generated by pixel-retroui setup
  // Import both core styles and font styles
  import 'pixel-retroui/dist/index.css';
  import 'pixel-retroui/dist/fonts.css';
  
  // You can use the Minecraft font in your Tailwind classes:
  // className="font-minecraft"
</file>

<file path="src/app/page.tsx">
'use client';

import { Button, Card } from '@pommai/ui';
import Link from "next/link";
import Image from 'next/image';
import { useState } from 'react';

/**
 * Home Page
 * - Pixel headings for primary titles; Work Sans for supporting text.
 * - Spacing tokens applied to containers/cards.
 */
export default function Home() {
  const [hoveredCard, setHoveredCard] = useState<number | null>(null);

  return (
    <div className="min-h-screen" style={{ backgroundColor: '#fefcd0' }}>
      {/* Header Navigation */}
      <header className="border-b-4 border-black bg-white">
<div className="container mx-auto px-[var(--spacing-md)] py-[var(--spacing-md)] flex justify-between items-center">
          <Link href="/" className="flex items-center gap-3">
            <Image src="/pommaiicon.png" alt="Pommai Logo" width={40} height={40} className="h-10 w-10" />
            <Image src="/pommaitext.png" alt="Pommai" width={140} height={32} className="h-8" />
          </Link>
          <nav className="flex gap-4 items-center">
            <Link href="/pricing" className="text-black hover:text-gray-700 font-geo font-medium text-sm">
              Pricing
            </Link>
            <Link href="/auth">
              <Button 
                bg="#ffffff"
                textColor="black"
                borderColor="black"
                shadow="#e0e0e0"
                size="small"
              >
                Sign In
              </Button>
            </Link>
            <Link href="/auth">
              <Button 
                bg="#c381b5"
                textColor="white"
                borderColor="black"
                shadow="#8b5fa3"
                size="small"
              >
                Get Started
              </Button>
            </Link>
          </nav>
        </div>
      </header>

      <main>
        {/* Hero Section */}
        <section className="relative overflow-hidden">
<div className="container mx-auto px-[var(--spacing-md)] py-[var(--spacing-3xl)]">
            <div className="max-w-4xl mx-auto text-center">
<h1 className="font-minecraft text-lg sm:text-xl lg:text-2xl font-black mb-[var(--spacing-lg)] main-title text-black">
                Bring Your Toys to Life
              </h1>
              <div className="text-4xl mb-8"></div>
<p className="font-geo text-sm sm:text-base mb-[var(--spacing-2xl)] text-gray-800 max-w-2xl mx-auto leading-relaxed">
                Create unique AI personalities for your plushies and toys.
                Safe, magical, and completely under your control.
              </p>
              <div className="flex gap-4 justify-center flex-wrap">
                <Link href="/auth">
                  <Button 
                    bg="#c381b5"
                    textColor="white"
                    borderColor="black"
                    shadow="#8b5fa3"
                    className="px-8 py-4 text-lg font-geo font-bold"
                  >
                    Start Creating
                  </Button>
                </Link>
                <Link href="#how-it-works">
                  <Button 
                    bg="#ffffff"
                    textColor="black"
                    borderColor="black"
                    shadow="#d0d0d0"
                    className="px-8 py-4 text-lg font-geo font-bold"
                  >
                    Learn More
                  </Button>
                </Link>
              </div>
            </div>
          </div>

          {/* Toy Preview */}
<div className="container mx-auto px-[var(--spacing-md)] pb-[var(--spacing-3xl)]">
            <div className="max-w-3xl mx-auto">
              <Card 
                bg="#ffffff" 
                borderColor="black" 
                shadowColor="#000000"
className="p-[var(--spacing-xl)]"
              >
                <div className="text-center mb-6">
                  <span className="text-xs font-geo font-bold uppercase tracking-wider text-gray-600">Your toy is saying</span>
                </div>
                <div className="flex flex-col md:flex-row items-center gap-8">
                  <div className="text-8xl flex-shrink-0"></div>
                  <div className="flex-1">
                    <Card 
                      bg="#e8f4fd" 
                      borderColor="black" 
                      shadowColor="#92cd41"
                      className="p-4 mb-4"
                    >
                      <p className="text-base font-geo font-medium text-black">
                        &quot;Hello! I&apos;m Teddy! Want to hear a story about magical forests?&quot;
                      </p>
                    </Card>
                    <div className="flex gap-3 items-center justify-center md:justify-start">
                      <div className="w-4 h-4 rounded-full bg-green-500 animate-pulse"></div>
                      <span className="text-xs font-geo font-bold uppercase tracking-wider text-gray-600">Active</span>
                    </div>
                  </div>
                </div>
              </Card>
            </div>
          </div>
        </section>

        {/* How It Works */}
<section id="how-it-works" className="bg-white border-y-4 border-black py-[var(--spacing-3xl)]">
<div className="container mx-auto px-[var(--spacing-md)]">
<h2 className="font-minecraft text-base sm:text-lg lg:text-xl font-black text-center mb-[var(--spacing-2xl)] text-black">
              How It Works
            </h2>
            <div className="grid md:grid-cols-3 gap-8 max-w-5xl mx-auto">
              {[
                {
                  icon: "",
                  title: "Design Your Toy",
                  description: "Create a unique personality with our intuitive builder. Choose traits, voice, and knowledge.",
                  color: "#c381b5"
                },
                {
                  icon: "",
                  title: "Connect Hardware",
                  description: "Easy setup with Raspberry Pi or Arduino. We'll guide you through every step.",
                  color: "#92cd41"
                },
                {
                  icon: "",
                  title: "Start Talking",
                  description: "Your toy comes to life! Safe, monitored conversations that spark imagination.",
                  color: "#f7931e"
                }
              ].map((feature, index) => (
                <div
                  key={index}
                  onMouseEnter={() => setHoveredCard(index)}
                  onMouseLeave={() => setHoveredCard(null)}
                >
                  <Card 
                    bg={hoveredCard === index ? '#f0f0f0' : '#ffffff'}
                    borderColor="black" 
                    shadowColor={hoveredCard === index ? feature.color : '#000000'}
className="p-[var(--spacing-xl)] cursor-pointer transition-all hover:translate-y-[-4px] h-full"
                  >
                    <div className="text-4xl mb-6 text-center">{feature.icon}</div>
                    <h3 className="text-xl font-geo font-bold mb-3 text-black sub-heading text-center">{feature.title}</h3>
                    <p className="text-gray-700 text-center leading-relaxed font-geo text-sm">{feature.description}</p>
                  </Card>
                </div>
              ))}
            </div>
          </div>
        </section>

        {/* Safety Section */}
<section className="py-[var(--spacing-3xl)]" style={{ backgroundColor: '#ffe4e1' }}>
<div className="container mx-auto px-[var(--spacing-md)]">
            <div className="max-w-5xl mx-auto">
<h2 className="font-minecraft text-base sm:text-lg lg:text-xl font-black text-center mb-[var(--spacing-2xl)] text-black">
                Safety First, Always
              </h2>
              <div className="text-center text-4xl mb-12"></div>
              <div className="grid md:grid-cols-2 gap-8">
                <Card 
                  bg="#ffffff" 
                  borderColor="black" 
                  shadowColor="#000000"
className="p-[var(--spacing-xl)]"
                >
                  <h3 className="text-xl font-geo font-bold mb-6 text-black sub-heading">For Parents</h3>
                  <ul className="space-y-4 text-base">
                    <li className="flex items-start">
                      <span className="text-green-600 font-bold mr-3 text-lg"></span>
                      <span className="text-gray-700 font-geo text-sm">Real-time conversation monitoring</span>
                    </li>
                    <li className="flex items-start">
                      <span className="text-green-600 font-bold mr-3 text-lg"></span>
                      <span className="text-gray-700 font-geo text-sm">Content filtering & safety controls</span>
                    </li>
                    <li className="flex items-start">
                      <span className="text-green-600 font-bold mr-3 text-lg"></span>
                      <span className="text-gray-700 font-geo text-sm">Emergency stop button</span>
                    </li>
                    <li className="flex items-start">
                      <span className="text-green-600 font-bold mr-3 text-lg"></span>
                      <span className="text-gray-700 font-geo text-sm">Complete privacy - your data stays yours</span>
                    </li>
                  </ul>
                </Card>
                <Card 
                  bg="#ffffff" 
                  borderColor="black" 
                  shadowColor="#000000"
                  className="p-8"
                >
                  <h3 className="text-xl font-geo font-bold mb-6 text-black sub-heading">For Kids</h3>
                  <ul className="space-y-4 text-base">
                    <li className="flex items-start">
                      <span className="text-green-600 font-bold mr-3 text-lg"></span>
                      <span className="text-gray-700 font-geo text-sm">Age-appropriate responses only</span>
                    </li>
                    <li className="flex items-start">
                      <span className="text-green-600 font-bold mr-3 text-lg"></span>
                      <span className="text-gray-700 font-geo text-sm">No data collection from children</span>
                    </li>
                    <li className="flex items-start">
                      <span className="text-green-600 font-bold mr-3 text-lg"></span>
                      <span className="text-gray-700 font-geo text-sm">Push-to-talk (not always listening)</span>
                    </li>
                    <li className="flex items-start">
                      <span className="text-green-600 font-bold mr-3 text-lg"></span>
                      <span className="text-gray-700 font-geo text-sm">LED indicators show when active</span>
                    </li>
                  </ul>
                </Card>
              </div>
            </div>
          </div>
        </section>
        
        {/* CTA Section */}
<section className="border-t-4 border-black py-[var(--spacing-3xl)]">
          <div className="container mx-auto px-4 text-center">
<h2 className="font-minecraft text-base sm:text-lg lg:text-xl font-black mb-[var(--spacing-lg)] text-black">
              Ready to Create Magic?
            </h2>
            <p className="text-lg mb-10 text-gray-800 max-w-2xl mx-auto leading-relaxed font-geo">
              Join thousands of creators bringing joy to children through safe, intelligent toys.
            </p>
            <Link href="/auth">
              <Button 
                bg="#c381b5"
                textColor="white"
                borderColor="black"
                shadow="#8b5fa3"
                className="px-8 py-4 text-lg font-geo font-bold"
              >
                Start Creating Your First Toy
              </Button>
            </Link>
          </div>
        </section>
      </main>
      
      {/* Footer */}
      <footer className="bg-black text-white py-8">
        <div className="container mx-auto px-4">
          <div className="flex flex-col md:flex-row justify-between items-center">
            <div className="mb-4 md:mb-0">
              <div className="flex items-center gap-2 mb-2">
                <Image src="/pommaiicon.png" alt="Pommai Logo" width={24} height={24} className="h-6 w-6" />
                <h4 className="text-lg font-geo font-bold">Pommai.co</h4>
              </div>
              <p className="text-gray-400 font-geo text-sm">Bringing toys to life, safely.</p>
            </div>
            <nav className="flex gap-6 text-gray-400 font-geo text-sm">
              <Link href="/about" className="hover:text-white">About</Link>
              <Link href="/privacy" className="hover:text-white">Privacy</Link>
              <Link href="/docs" className="hover:text-white">Docs</Link>
              <Link href="/contact" className="hover:text-white">Contact</Link>
            </nav>
          </div>
          <div className="mt-8 pt-8 border-t border-gray-800 text-center text-gray-400">
            <p className="font-geo text-sm"> 2024 Pommai. Made with  for parents and kids.</p>
          </div>
        </div>
      </footer>
    </div>
  );
}
</file>

<file path="src/app/pricing/page.tsx">
'use client';

import { Button, Card } from '@pommai/ui';
import Link from "next/link";
import Image from 'next/image';

/**
 * Pricing Page
 * - Pixel headings for primary titles; supporting text uses font-geo.
 * - Spacing tokens applied to containers and cards.
 */
export default function PricingPage() {
  const plans = [
    {
      name: "Hobbyist",
      price: "Free",
      description: "Perfect for getting started",
      features: [
        "Create up to 2 AI Toys",
        "200 conversations/month",
        "Basic voices",
        "Web simulator access"
      ],
      cta: "Start Free",
      bg: "#ffffff",
      shadow: "#000000",
      textColor: "black",
      buttonBg: "#c381b5",
      buttonText: "white"
    },
    {
      name: "Pro",
      price: "$19/mo",
      description: "For serious creators",
      features: [
        "Unlimited AI Toys",
        "Unlimited conversations",
        "Premium voices",
        "Advanced personality tools",
        "Priority support"
      ],
      cta: "Go Pro",
      bg: "#c381b5",
      shadow: "#8b5fa3",
      textColor: "white",
      buttonBg: "#ffffff",
      buttonText: "black",
      popular: true
    },
    {
      name: "Guardian Family",
      price: "$29/mo",
      description: "Complete family protection",
      features: [
        "Everything in Pro",
        "Guardian Dashboard",
        "Monitor 5 kids' toys",
        "Extended analytics",
        "Family device management"
      ],
      cta: "Protect Your Family",
      bg: "#92cd41",
      shadow: "#76a83a",
      textColor: "white",
      buttonBg: "#ffffff",
      buttonText: "black"
    }
  ];

  return (
    <div className="min-h-screen" style={{ backgroundColor: '#fefcd0' }}>
      {/* Header Navigation */}
      <header className="border-b-4 border-black bg-white">
<div className="container mx-auto px-[var(--spacing-md)] py-[var(--spacing-md)] flex justify-between items-center">
          <Link href="/" className="flex items-center gap-3">
            <Image src="/pommaiicon.png" alt="Pommai Logo" width={40} height={40} className="h-10 w-10" />
            <Image src="/pommaitext.png" alt="Pommai" width={140} height={32} className="h-8" />
          </Link>
          <nav className="flex gap-4 items-center">
            <Link href="/" className="text-black hover:text-gray-700 font-medium">
              Home
            </Link>
            <Link href="/auth">
              <Button 
                bg="#ffffff"
                textColor="black"
                borderColor="black"
                shadow="#e0e0e0"
                size="small"
              >
                Sign In
              </Button>
            </Link>
            <Link href="/auth">
              <Button 
                bg="#c381b5"
                textColor="white"
                borderColor="black"
                shadow="#8b5fa3"
                size="small"
              >
                Get Started
              </Button>
            </Link>
          </nav>
        </div>
      </header>

<main className="container mx-auto px-[var(--spacing-md)] py-[var(--spacing-3xl)]">
        <div className="text-center mb-16">
<h1 className="font-minecraft text-lg sm:text-xl lg:text-2xl font-black mb-[var(--spacing-lg)] text-black">
            Simple, Transparent Pricing
          </h1>
<p className="font-geo text-sm sm:text-base text-gray-700 max-w-2xl mx-auto">
            Choose the perfect plan for your creative journey. Start free and upgrade as you grow.
          </p>
        </div>

        <div className="grid md:grid-cols-3 gap-8 max-w-6xl mx-auto mb-20">
          {plans.map((plan, index) => (
            <div key={index} className="relative">
              {plan.popular && (
                <div className="absolute -top-4 left-1/2 transform -translate-x-1/2 z-10">
                  <span className="bg-[#f7931e] text-white px-4 py-2 text-sm font-bold border-2 border-black retro-text">
                    MOST POPULAR
                  </span>
                </div>
              )}
              <Card 
                bg={plan.bg}
                borderColor="black" 
                shadowColor={plan.shadow}
className={`p-[var(--spacing-xl)] h-full ${plan.popular ? 'border-4' : ''} ${plan.popular ? 'transform scale-105' : ''}`}
                style={plan.popular ? { borderColor: '#f7931e' } : {}}
              >
                <div className="text-center">
                  <h3 className="text-3xl font-bold mb-2 retro-text" style={{ color: plan.textColor }}>
                    {plan.name}
                  </h3>
                  <p className="text-sm mb-4" style={{ color: plan.textColor, opacity: 0.8 }}>
                    {plan.description}
                  </p>
                  <p className="text-5xl font-bold mb-8" style={{ color: plan.textColor }}>
                    {plan.price}
                  </p>
                </div>
                <ul className="space-y-3 mb-8">
                  {plan.features.map((feature, i) => (
                    <li key={i} className="flex items-start">
                      <span className="font-bold mr-2 text-xl" style={{ color: plan.textColor }}></span>
                      <span style={{ color: plan.textColor }}>{feature}</span>
                    </li>
                  ))}
                </ul>
                <Link href="/auth" className="block">
                  <Button 
                    bg={plan.buttonBg}
                    textColor={plan.buttonText}
                    borderColor="black"
                    shadow={plan.shadow}
                    className="w-full py-3 text-lg font-bold"
                  >
                    {plan.cta}
                  </Button>
                </Link>
              </Card>
            </div>
          ))}
        </div>

        {/* FAQ Section */}
        <section className="max-w-4xl mx-auto">
          <h2 className="font-minecraft text-base sm:text-lg lg:text-xl font-black text-center mb-[var(--spacing-xl)] text-black">
            Frequently Asked Questions
          </h2>
          <div className="space-y-6">
            <Card bg="#ffffff" borderColor="black" shadowColor="#000000" className="p-6">
              <h4 className="text-xl font-bold mb-2">Can I change plans anytime?</h4>
              <p className="text-gray-700">Yes! You can upgrade or downgrade your plan at any time. Changes take effect immediately.</p>
            </Card>
            <Card bg="#ffffff" borderColor="black" shadowColor="#000000" className="p-6">
              <h4 className="text-xl font-bold mb-2">What happens to my toys if I downgrade?</h4>
              <p className="text-gray-700">Your existing toys remain safe. You just won&apos;t be able to create new ones beyond your plan limit.</p>
            </Card>
            <Card bg="#ffffff" borderColor="black" shadowColor="#000000" className="p-6">
              <h4 className="text-xl font-bold mb-2">Do I need technical skills?</h4>
              <p className="text-gray-700">Not at all! Our platform is designed for everyone. We provide step-by-step guides for hardware setup.</p>
            </Card>
            <Card bg="#ffffff" borderColor="black" shadowColor="#000000" className="p-6">
              <h4 className="text-xl font-bold mb-2">Is there a student discount?</h4>
              <p className="text-gray-700">Yes! Students get 50% off Pro and Guardian plans. Contact us with your .edu email.</p>
            </Card>
          </div>
        </section>

        {/* CTA */}
        <section className="text-center mt-20">
          <Card bg="#e8f4fd" borderColor="black" shadowColor="#92cd41" className="p-[var(--spacing-2xl)] max-w-2xl mx-auto">
            <h3 className="text-3xl font-bold mb-4 retro-text">Ready to start?</h3>
            <p className="text-lg mb-6">Join thousands of creators bringing toys to life!</p>
            <Link href="/auth">
              <Button 
                bg="#c381b5"
                textColor="white"
                borderColor="black"
                shadow="#8b5fa3"
                className="px-8 py-4 text-lg font-bold"
              >
                Start Your Free Plan
              </Button>
            </Link>
          </Card>
        </section>
      </main>

      {/* Footer */}
      <footer className="bg-black text-white py-8 mt-20">
        <div className="container mx-auto px-4">
          <div className="flex flex-col md:flex-row justify-between items-center">
            <div className="mb-4 md:mb-0">
              <div className="flex items-center gap-2 mb-2">
                <Image src="/pommaiicon.png" alt="Pommai Logo" width={24} height={24} className="h-6 w-6" />
                <h4 className="text-xl font-bold">Pommai.co</h4>
              </div>
              <p className="text-gray-400">Bringing toys to life, safely.</p>
            </div>
            <nav className="flex gap-6 text-gray-400">
              <Link href="/about" className="hover:text-white">About</Link>
              <Link href="/privacy" className="hover:text-white">Privacy</Link>
              <Link href="/docs" className="hover:text-white">Docs</Link>
              <Link href="/contact" className="hover:text-white">Contact</Link>
            </nav>
          </div>
          <div className="mt-8 pt-8 border-t border-gray-800 text-center text-gray-400">
            <p> 2024 Pommai. Made with  for parents and kids.</p>
          </div>
        </div>
      </footer>
    </div>
  );
}
</file>

<file path="src/app/providers/ConvexClientProvider.tsx">
'use client';

import { ReactNode } from 'react';
import { ConvexReactClient } from 'convex/react';
import { authClient } from '../../lib/auth-client';
import { ConvexBetterAuthProvider } from '@convex-dev/better-auth/react';

const convex = new ConvexReactClient(process.env.NEXT_PUBLIC_CONVEX_URL!);

export function ConvexClientProvider({ children }: { children: ReactNode }) {
  return (
    <ConvexBetterAuthProvider client={convex} authClient={authClient}>
      {children}
    </ConvexBetterAuthProvider>
  );
}
</file>

<file path="src/components/chat/ChatInterface.tsx">
'use client';

import { useState, useEffect, useRef, type ChangeEvent, type KeyboardEvent } from 'react';
import { useQuery, useMutation, useAction } from 'convex/react';
import { api } from '../../../convex/_generated/api';
import { Id } from '../../../convex/_generated/dataModel';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Card } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Avatar, AvatarFallback } from '@/components/ui/avatar';
import { 
  Send, 
  Mic, 
  MicOff, 
  Volume2, 
  VolumeX,
  AlertCircle,
  Loader2,
  User
} from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';
import { format } from 'date-fns';

interface ChatInterfaceProps {
  toyId: Id<"toys">;
  toy: { name?: string; type?: string; isForKids?: boolean };
  isGuardianMode?: boolean;
  onFlagMessage?: (messageId: string, reason: string) => void;
}

export function ChatInterface({ toyId, toy, isGuardianMode: _isGuardianMode = false, onFlagMessage: _onFlagMessage }: ChatInterfaceProps) {
  const [message, setMessage] = useState('');
  const [isRecording, setIsRecording] = useState(false);
  const [isMuted, setIsMuted] = useState(false);
  const [isTyping, setIsTyping] = useState(false);
  const scrollAreaRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLInputElement>(null);

  // Get or create active conversation
  const activeConversation = useQuery(api.conversations.getActiveConversation, { toyId });
  const createConversation = useMutation(api.conversations.createConversation);
  const sendMessage = useMutation(api.messages.sendMessage);
  const generateResponse = useAction(api.messages.generateAIResponse);

  // Get messages for active conversation
  const messages = useQuery(
    api.messages.getMessages,
    activeConversation ? { conversationId: activeConversation._id } : "skip"
  );

  // Auto-scroll to bottom when new messages arrive
  useEffect(() => {
    if (scrollAreaRef.current) {
      scrollAreaRef.current.scrollTop = scrollAreaRef.current.scrollHeight;
    }
  }, [messages]);

  // Initialize conversation if needed
  useEffect(() => {
    const initConversation = async () => {
      if (!activeConversation && toyId) {
        await createConversation({
          toyId,
          sessionId: `web-${Date.now()}`,
          location: 'web',
          deviceId: 'web-simulator',
        });
      }
    };
    initConversation();
  }, [toyId, activeConversation, createConversation]);

  const handleSendMessage = async () => {
    if (!message.trim() || !activeConversation) return;

    const userMessage = message.trim();
    setMessage('');
    setIsTyping(true);

    try {
      // Send user message
      await sendMessage({
        conversationId: activeConversation._id,
        content: userMessage,
        role: 'user',
      });

      // Generate AI response
      await generateResponse({
        conversationId: activeConversation._id,
        userMessage,
      });
    } catch (error) {
      console.error('Error sending message:', error);
    } finally {
      setIsTyping(false);
    }
  };

  const handleVoiceInput = () => {
    // TODO: Implement voice recording
    setIsRecording(!isRecording);
  };

  const toggleMute = () => {
    setIsMuted(!isMuted);
  };

  const getToyAvatar = () => {
    const avatarMap: Record<string, string> = {
      teddy: '',
      bunny: '',
      cat: '',
      dog: '',
      bird: '',
      fish: '',
      robot: '',
      magical: '',
    };
    return toy && toy.type ? (avatarMap[toy.type] || '') : '';
  };

  return (
    <Card className="h-[600px] flex flex-col">
      {/* Chat Header */}
      <div className="border-b p-4 flex items-center justify-between">
        <div className="flex items-center gap-3">
          <Avatar>
            <AvatarFallback className="text-2xl bg-purple-100">
              {getToyAvatar()}
            </AvatarFallback>
          </Avatar>
          <div>
            <h3 className="retro-h3 text-base sm:text-lg text-gray-900">{toy?.name || 'AI Toy'}</h3>
            <div className="flex items-center gap-2">
              <div className="flex items-center gap-1">
                <div className="w-2 h-2 bg-green-500 rounded-full animate-pulse" />
                <span className="text-xs text-gray-500">Active</span>
              </div>
              {toy?.isForKids && (
                <Badge variant="secondary" className="text-xs">
                  Kids Mode
                </Badge>
              )}
            </div>
          </div>
        </div>
        
        <Button
          variant="ghost"
          size="sm"
          onClick={toggleMute}
          className="text-gray-500"
        >
          {isMuted ? <VolumeX className="w-5 h-5" /> : <Volume2 className="w-5 h-5" />}
        </Button>
      </div>

      {/* Messages Area */}
      <ScrollArea className="flex-1 p-4" ref={scrollAreaRef}>
        <div className="space-y-4">
          {messages?.map((msg) => (
            <AnimatePresence key={msg._id}>
              <motion.div
                initial={{ opacity: 0, y: 10 }}
                animate={{ opacity: 1, y: 0 }}
                exit={{ opacity: 0, y: -10 }}
                className={`flex ${msg.role === 'user' ? 'justify-end' : 'justify-start'}`}
              >
                <div className={`flex gap-2 max-w-[80%] ${msg.role === 'user' ? 'flex-row-reverse' : ''}`}>
                  <Avatar className="w-8 h-8">
                    <AvatarFallback className={`text-sm ${msg.role === 'user' ? 'bg-blue-100' : 'bg-purple-100'}`}>
                      {msg.role === 'user' ? <User className="w-4 h-4" /> : getToyAvatar()}
                    </AvatarFallback>
                  </Avatar>
                  
                  <div className="space-y-1">
                    <div
                      className={`rounded-lg px-4 py-2 ${
                        msg.role === 'user'
                          ? 'bg-blue-500 text-white'
                          : 'bg-gray-100 text-gray-900'
                      }`}
                    >
                      <p className="text-sm">{msg.content}</p>
                    </div>
                    
                    <div className="flex items-center gap-2 text-xs text-gray-500">
                      <span>
                        {msg.timestamp && !isNaN(new Date(msg.timestamp).getTime()) 
                          ? format(new Date(msg.timestamp), 'HH:mm')
                          : msg._creationTime 
                            ? format(new Date(msg._creationTime), 'HH:mm')
                            : 'now'
                        }
                      </span>
                      {msg.metadata?.flagged && (
                        <Badge variant="destructive" className="text-xs">
                          <AlertCircle className="w-3 h-3 mr-1" />
                          Flagged
                        </Badge>
                      )}
                    </div>
                  </div>
                </div>
              </motion.div>
            </AnimatePresence>
          ))}
          
          {isTyping && (
            <motion.div
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              className="flex items-center gap-2 text-gray-500"
            >
              <Avatar className="w-8 h-8">
                <AvatarFallback className="bg-purple-100 text-sm">
                  {getToyAvatar()}
                </AvatarFallback>
              </Avatar>
              <div className="bg-gray-100 rounded-lg px-4 py-2">
                <div className="flex items-center gap-1">
                  <span className="text-sm">{toy?.name} is typing</span>
                  <Loader2 className="w-3 h-3 animate-spin" />
                </div>
              </div>
            </motion.div>
          )}
        </div>
      </ScrollArea>

      {/* Input Area */}
      <div className="border-t p-4">
        <div className="flex gap-2">
          <Button
            variant={isRecording ? "destructive" : "outline"}
            size="icon"
            onClick={handleVoiceInput}
            disabled={isTyping}
          >
            {isRecording ? <MicOff className="w-4 h-4" /> : <Mic className="w-4 h-4" />}
          </Button>
          
          <Input
            ref={inputRef}
            value={message}
            onChange={(e: ChangeEvent<HTMLInputElement>) => setMessage(e.target.value)}
            onKeyPress={(e: KeyboardEvent<HTMLInputElement>) => e.key === 'Enter' && handleSendMessage()}
            placeholder="Type a message..."
            disabled={isTyping || isRecording}
            className="flex-1"
          />
          
          <Button
            onClick={handleSendMessage}
            disabled={!message.trim() || isTyping}
            size="icon"
          >
            {isTyping ? (
              <Loader2 className="w-4 h-4 animate-spin" />
            ) : (
              <Send className="w-4 h-4" />
            )}
          </Button>
        </div>
        
        {toy?.isForKids && (
          <p className="text-xs text-gray-500 mt-2 text-center">
            Guardian Mode is active. All conversations are monitored for safety.
          </p>
        )}
      </div>
    </Card>
  );
}
</file>

<file path="src/components/dashboard/EditToyForm.tsx">
'use client';

import { useState, useEffect, type ChangeEvent } from 'react';
import { useRouter } from 'next/navigation';
import { useMutation } from 'convex/react';
import { api } from '../../../convex/_generated/api';
import { type Doc } from '../../../convex/_generated/dataModel';
import { Button, Card, Popup } from '@pommai/ui';
import { Save, Trash, Loader2, AlertCircle } from 'lucide-react';
import { useToyWizardStore } from '@/stores/toyWizardStore';

// Import step components to reuse their UI structure
import { ToyProfileStep } from './steps/ToyProfileStep';
import { ForKidsToggleStep } from './steps/ForKidsToggleStep';
import { PersonalityStep } from './steps/PersonalityStep';
import { VoiceStep } from './steps/VoiceStep';
import { KnowledgeStep } from './steps/KnowledgeStep';
import { SafetyStep } from './steps/SafetyStep';

type ToyDocument = Doc<'toys'>;

interface EditToyFormProps {
  toy: ToyDocument;
}

export function EditToyForm({ toy }: EditToyFormProps) {
  const router = useRouter();
  const { toyConfig, setToyConfig, resetWizard } = useToyWizardStore();

  const [isSaving, setIsSaving] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  
  const updateToyMutation = useMutation(api.toys.updateToy);
  const deleteToyMutation = useMutation(api.toys.deleteToy);

  // When the component mounts, populate the wizard's store with the toy's data
  useEffect(() => {
    // Convert the toy document to match the store's ToyConfig type
    setToyConfig({
      name: toy.name,
      type: toy.type,
      isForKids: toy.isForKids,
      ageGroup: toy.ageGroup as '3-5' | '6-8' | '9-12' | undefined,
      voiceId: toy.voiceId,
      voiceName: toy.voiceName,
      personalityPrompt: toy.personalityPrompt,
      personalityTraits: toy.personalityTraits || {
        traits: [],
        speakingStyle: {
          vocabulary: 'moderate',
          sentenceLength: 'medium',
          usesSoundEffects: false,
          catchPhrases: [],
        },
        interests: [],
        favoriteTopics: [],
        avoidTopics: [],
        behavior: {
          encouragesQuestions: true,
          tellsStories: true,
          playsGames: true,
          educationalFocus: 5,
          imaginationLevel: 5,
        },
      },
      safetySettings: toy.safetyLevel ? {
        safetyLevel: toy.safetyLevel,
        contentFilters: toy.contentFilters || {
          enabledCategories: [],
          customBlockedTopics: [],
        },
      } : undefined,
      knowledgeBase: (toy as any).knowledgeBase,
      isPublic: toy.isPublic,
      tags: toy.tags || [],
    });

    // Clean up the store when the component unmounts
    return () => {
      resetWizard();
    };
  }, [toy, setToyConfig, resetWizard]);

  const handleSave = async () => {
    setIsSaving(true);
    setError(null);
    
    // Debug log to see what we're saving
    console.log('Saving toy with config:', {
      toyId: toy._id,
      name: toyConfig.name,
      type: toyConfig.type,
      personalityPrompt: toyConfig.personalityPrompt,
      tags: toyConfig.tags,
    });
    
    try {
      await updateToyMutation({
        toyId: toy._id,
        name: toyConfig.name,
        type: toyConfig.type,
        personalityPrompt: toyConfig.personalityPrompt,
        personalityTraits: toyConfig.personalityTraits,
        voiceId: toyConfig.voiceId,
        safetyLevel: toyConfig.safetySettings?.safetyLevel,
        contentFilters: toyConfig.safetySettings?.contentFilters,
        tags: toyConfig.tags,
      });
      console.log('Toy updated successfully!');
      router.push('/dashboard');
    } catch (e) {
      console.error("Failed to update toy:", e);
      setError(e instanceof Error ? e.message : 'An unknown error occurred.');
    } finally {
      setIsSaving(false);
    }
  };

  const handleDelete = async () => {
    setIsSaving(true);
    setError(null);
    try {
      await deleteToyMutation({ toyId: toy._id });
      setShowDeleteDialog(false);
      router.push('/dashboard');
    } catch (e) {
      console.error("Failed to delete toy:", e);
      setError(e instanceof Error ? e.message : 'An unknown error occurred.');
      setShowDeleteDialog(false);
    } finally {
      setIsSaving(false);
    }
  };

  return (
    <div className="space-y-6 sm:space-y-8">
      {/* Toy Profile */}
      <Card bg="#ffffff" borderColor="black" shadowColor="#c381b5" className="p-6 sm:p-8">
        <h2 className="font-minecraft text-lg mb-4 uppercase tracking-wider flex items-center gap-2">
          <span className="text-2xl"></span>
          Toy Profile
        </h2>
        <ToyProfileStep />
      </Card>
      
      {/* For Kids Toggle */}
      <Card bg="#ffffff" borderColor="black" shadowColor="#92cd41" className="p-6 sm:p-8">
        <h2 className="font-minecraft text-lg mb-4 uppercase tracking-wider flex items-center gap-2">
          <span className="text-2xl"></span>
          Age Settings
        </h2>
        <ForKidsToggleStep />
      </Card>
      
      {/* Personality */}
      <Card bg="#ffffff" borderColor="black" shadowColor="#f7931e" className="p-6 sm:p-8">
        <h2 className="font-minecraft text-lg mb-4 uppercase tracking-wider flex items-center gap-2">
          <span className="text-2xl"></span>
          Personality
        </h2>
        <PersonalityStep />
      </Card>

      {/* Voice */}
      <Card bg="#ffffff" borderColor="black" shadowColor="#c381b5" className="p-6 sm:p-8">
        <h2 className="font-minecraft text-lg mb-4 uppercase tracking-wider flex items-center gap-2">
          <span className="text-2xl"></span>
          Voice Settings
        </h2>
        <VoiceStep />
      </Card>

      {/* Knowledge Base */}
      <Card bg="#ffffff" borderColor="black" shadowColor="#92cd41" className="p-6 sm:p-8">
        <h2 className="font-minecraft text-lg mb-4 uppercase tracking-wider flex items-center gap-2">
          <span className="text-2xl"></span>
          Knowledge Base
        </h2>
        <KnowledgeStep />
      </Card>

      {/* Safety Settings (only for Kids mode) */}
      {toyConfig.isForKids && (
        <Card bg="#ffffff" borderColor="black" shadowColor="#ff6b6b" className="p-6 sm:p-8">
          <h2 className="font-minecraft text-lg mb-4 uppercase tracking-wider flex items-center gap-2">
            <span className="text-2xl"></span>
            Safety Settings
          </h2>
          <SafetyStep />
        </Card>
      )}

      {/* Error Display */}
      {error && (
        <Card bg="#ffe4e1" borderColor="red" shadowColor="#ff6b6b" className="p-4 flex items-center gap-3">
          <AlertCircle className="w-5 h-5 text-red-600 flex-shrink-0" />
          <p className="font-geo font-semibold text-red-700">{error}</p>
        </Card>
      )}

      {/* Action Buttons */}
      <div className="flex flex-col sm:flex-row justify-between items-center gap-4 pt-6 border-t-4 border-black">
        <Button
          onClick={() => setShowDeleteDialog(true)}
          bg="#ff6b6b"
          textColor="white"
          borderColor="black"
          shadow="#e84545"
          className="w-full sm:w-auto py-3 px-6 font-minecraft font-black uppercase tracking-wider hover-lift"
          disabled={isSaving}
        >
          <Trash className="w-4 h-4 mr-2" />
          Delete Toy
        </Button>
        
        <div className="flex gap-3 w-full sm:w-auto">
          <Button
            onClick={() => router.push('/dashboard')}
            bg="#f0f0f0"
            textColor="black"
            borderColor="black"
            shadow="#d0d0d0"
            className="flex-1 sm:flex-none py-3 px-6 font-minecraft font-black uppercase tracking-wider hover-lift"
            disabled={isSaving}
          >
            Cancel
          </Button>
          <Button
            onClick={handleSave}
            bg="#92cd41"
            textColor="white"
            borderColor="black"
            shadow="#76a83a"
            className="flex-1 sm:flex-none py-3 px-6 font-minecraft font-black uppercase tracking-wider hover-lift"
            disabled={isSaving}
          >
            {isSaving ? (
              <>
                <Loader2 className="w-5 h-5 animate-spin mr-2" />
                Saving...
              </>
            ) : (
              <>
                <Save className="w-4 h-4 mr-2" />
                Save Changes
              </>
            )}
          </Button>
        </div>
      </div>

      {/* Delete Confirmation Dialog */}
      {showDeleteDialog && (
        <Popup
          isOpen={showDeleteDialog}
          onClose={() => setShowDeleteDialog(false)}
          title=" Delete Toy?"
          bg="#ffffff"
          borderColor="black"
        >
          <div className="space-y-4">
            <p className="font-geo text-gray-700">
              Are you sure you want to permanently delete <strong>"{toy.name}"</strong>? 
            </p>
            <div className="bg-[#ffe4e1] border-2 border-red-500 rounded-lg p-3">
              <p className="font-geo text-red-700 text-sm">
                 This action cannot be undone. All conversations and data associated with this toy will be lost.
              </p>
            </div>
            <div className="flex justify-end gap-3 pt-4">
              <Button
                onClick={() => setShowDeleteDialog(false)}
                bg="#f0f0f0"
                textColor="black"
                borderColor="black"
                shadow="#d0d0d0"
                className="font-minecraft font-black uppercase tracking-wider hover-lift"
                disabled={isSaving}
              >
                Cancel
              </Button>
              <Button
                onClick={handleDelete}
                bg="#ff6b6b"
                textColor="white"
                borderColor="black"
                shadow="#e84545"
                className="font-minecraft font-black uppercase tracking-wider hover-lift"
                disabled={isSaving}
              >
                {isSaving ? (
                  <>
                    <Loader2 className="w-5 h-5 animate-spin mr-2" />
                    Deleting...
                  </>
                ) : (
                  <>
                    <Trash className="w-4 h-4 mr-2" />
                    Delete Forever
                  </>
                )}
              </Button>
            </div>
          </div>
        </Popup>
      )}
    </div>
  );
}
</file>

<file path="src/components/dashboard/MyToysGrid.tsx">
'use client';

import { useState } from 'react';
import { useQuery, useMutation } from 'convex/react';
import { api } from '../../../convex/_generated/api';
import { Card } from '@pommai/ui';
import { AnimatePresence } from 'framer-motion';
import { useRouter } from 'next/navigation';
import { Id } from '../../../convex/_generated/dataModel';
import { ToyEmptyState } from './ToyEmptyState';
import { ToyControlsHeader } from './ToyControlsHeader';
import { ToyGridItem } from './ToyGridItem';
import { ToyListItem } from './ToyListItem';
import { ToyDialogs } from './ToyDialogs';

interface MyToysGridProps {
  onCreateToy?: () => void;
}

export function MyToysGrid({ onCreateToy }: MyToysGridProps) {
  const router = useRouter();
  const [viewMode, setViewMode] = useState<'grid' | 'list'>('grid');
  const [searchQuery, setSearchQuery] = useState('');
  const [filterStatus, setFilterStatus] = useState<'all' | 'active' | 'paused' | 'archived'>('all');
  const [selectedToy, setSelectedToy] = useState<string | null>(null);
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const [showDuplicateDialog, setShowDuplicateDialog] = useState(false);
  const [duplicateName, setDuplicateName] = useState('');

  // Fetch toys
  const toys = useQuery(api.toys.getMyToys);
  const updateToyStatus = useMutation(api.toys.updateToyStatus);
  const duplicateToy = useMutation(api.toys.duplicateToy);
  const deleteToy = useMutation(api.toys.deleteToy);

  interface Toy { _id: string; name: string; type: string; status: 'active' | 'paused' | 'archived'; }
  // Filter toys
  const filteredToys = toys?.filter((toy: Toy) => {
    const matchesSearch = toy.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
                         toy.type.toLowerCase().includes(searchQuery.toLowerCase());
    const matchesStatus = filterStatus === 'all' || toy.status === filterStatus;
    return matchesSearch && matchesStatus;
  });

  const handleStatusToggle = async (toyId: Id<"toys">, currentStatus: string) => {
    const newStatus = currentStatus === 'active' ? 'paused' : 'active';
    await updateToyStatus({ toyId, status: newStatus });
  };

  const handleDuplicate = async () => {
    if (selectedToy && duplicateName.trim()) {
      await duplicateToy({ 
        toyId: selectedToy as Id<"toys">, 
        newName: duplicateName.trim() 
      });
      setShowDuplicateDialog(false);
      setDuplicateName('');
      setSelectedToy(null);
    }
  };

  const handleDelete = async () => {
    if (selectedToy) {
      await deleteToy({ toyId: selectedToy as Id<"toys"> });
      setShowDeleteDialog(false);
      setSelectedToy(null);
    }
  };

  const handleChat = (toyId: string) => {
    router.push(`/dashboard/chat?toyId=${toyId}`);
  };

  const handleEdit = (toyId: string) => {
    router.push(`/dashboard/toys/edit/${toyId}`);
  };

  const handleDuplicateStart = (toyId: string, name: string) => {
    setSelectedToy(toyId);
    setDuplicateName(name);
    setShowDuplicateDialog(true);
  };

  const handleDeleteStart = (toyId: string) => {
    setSelectedToy(toyId);
    setShowDeleteDialog(true);
  };

  if (!toys) {
    return (
      <div className="space-y-4">
        <div className="flex justify-between items-center mb-6">
          <div className="h-10 w-64 bg-gray-200 animate-pulse rounded" />
          <div className="h-10 w-32 bg-gray-200 animate-pulse rounded" />
        </div>
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
          {[1, 2, 3].map(i => (
            <Card 
              key={i} 
              bg="#f0f0f0" 
              borderColor="black" 
              shadowColor="#e0e0e0"
              className="h-64 w-full animate-pulse"
            >
              <div className="p-6 space-y-4">
                <div className="flex items-center gap-3">
                  <div className="w-12 h-12 bg-gray-300 rounded" />
                  <div className="space-y-2 flex-1">
                    <div className="h-4 bg-gray-300 rounded w-3/4" />
                    <div className="h-3 bg-gray-300 rounded w-1/2" />
                  </div>
                </div>
                <div className="space-y-2">
                  <div className="h-3 bg-gray-300 rounded" />
                  <div className="h-3 bg-gray-300 rounded w-2/3" />
                </div>
              </div>
            </Card>
          ))}
        </div>
      </div>
    );
  }

  if (toys.length === 0) {
    return <ToyEmptyState onCreateToy={onCreateToy} />;
  }

  return (
    <div className="space-y-4">
      <ToyControlsHeader 
        searchQuery={searchQuery}
        onSearchChange={setSearchQuery}
        filterStatus={filterStatus}
        onFilterChange={setFilterStatus}
        viewMode={viewMode}
        onViewModeChange={setViewMode}
        onCreateToy={onCreateToy}
      />

      <AnimatePresence mode="popLayout">
        {viewMode === 'grid' ? (
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 sm:gap-6">
            {filteredToys?.map((toy) => (
              <ToyGridItem
                key={toy._id}
                toy={toy}
                onChat={handleChat}
                onEdit={handleEdit}
                onStatusToggle={handleStatusToggle}
                onDuplicate={handleDuplicateStart}
                onDelete={handleDeleteStart}
              />
            ))}
          </div>
        ) : (
          <div className="space-y-3">
            {filteredToys?.map((toy) => (
              <ToyListItem
                key={toy._id}
                toy={toy}
                onChat={handleChat}
                onEdit={handleEdit}
                onStatusToggle={handleStatusToggle}
                onDuplicate={handleDuplicateStart}
                onDelete={handleDeleteStart}
              />
            ))}
          </div>
        )}
      </AnimatePresence>

      <ToyDialogs
        showDeleteDialog={showDeleteDialog}
        onDeleteConfirm={handleDelete}
        onDeleteCancel={() => {
          setShowDeleteDialog(false);
          setSelectedToy(null);
        }}
        showDuplicateDialog={showDuplicateDialog}
        duplicateName={duplicateName}
        onDuplicateNameChange={setDuplicateName}
        onDuplicateConfirm={handleDuplicate}
        onDuplicateCancel={() => {
          setShowDuplicateDialog(false);
          setSelectedToy(null);
        }}
      />
    </div>
  );
}
</file>

<file path="src/components/dashboard/steps/CompletionStep.tsx">
'use client';

import { useRouter } from 'next/navigation';
import { useEffect } from 'react';
import { useToyWizardStore } from '@/stores/toyWizardStore';
import { useToysStore, ToyType } from '@/stores/useToysStore';
import { Button, Card } from '@pommai/ui';
import { 
  CheckCircle2, 
  MessageSquare, 
  Settings, 
  Share2,
  Sparkles,
  ArrowRight
} from 'lucide-react';
import { motion } from 'framer-motion';
import confetti from 'canvas-confetti';

/**
 * CompletionStep
 *
 * Displays the final success screen after creating a toy.
 * Typography rules:
 * - Primary title uses font-minecraft (pixel) with compact responsive sizes.
 * - All supporting text uses font-geo for readability.
 */
export function CompletionStep() {
  const router = useRouter();
  const { toyConfig, resetWizard } = useToyWizardStore();
  const { addToy } = useToysStore();

  // eslint-disable-next-line react-hooks/exhaustive-deps
  useEffect(() => {
    // Add the newly created toy to the toys store
      const newToy = {
      _id: `toy_${Date.now()}`, // Generate a temporary ID
      name: toyConfig.name,
      type: toyConfig.type as unknown as ToyType,
      status: 'active' as const,
      isForKids: toyConfig.isForKids,
      voiceId: toyConfig.voiceId,
      voiceName: toyConfig.voiceName,
      personalityPrompt: toyConfig.personalityPrompt,
      isPublic: toyConfig.isPublic,
      tags: toyConfig.tags,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      conversationCount: 0,
      messageCount: 0,
      lastActiveAt: undefined,
      deviceId: undefined,
    };
    
    addToy(newToy);
    
    // Trigger confetti animation
    const duration = 3 * 1000;
    const animationEnd = Date.now() + duration;
    const defaults = { startVelocity: 30, spread: 360, ticks: 60, zIndex: 0 };

    function randomInRange(min: number, max: number) {
      return Math.random() * (max - min) + min;
    }

    const interval: ReturnType<typeof setInterval> = setInterval(function() {
      const timeLeft = animationEnd - Date.now();

      if (timeLeft <= 0) {
        return clearInterval(interval);
      }

      const particleCount = 50 * (timeLeft / duration);
      confetti({
        ...defaults,
        particleCount,
        origin: { x: randomInRange(0.1, 0.3), y: Math.random() - 0.2 }
      });
      confetti({
        ...defaults,
        particleCount,
        origin: { x: randomInRange(0.7, 0.9), y: Math.random() - 0.2 }
      });
    }, 250);

    return () => clearInterval(interval);
  }, []);

  const handleStartChatting = () => {
    // In real app, would navigate to the chat interface with the new toy
    resetWizard();
    router.push(`/dashboard/chat?toy=${toyConfig.name}`);
  };

  const handleGoToDashboard = () => {
    resetWizard();
    router.push('/dashboard');
  };

  const getToyTypeIcon = () => {
    const icons: Record<string, string> = {
      teddy: '',
      bunny: '',
      cat: '',
      dog: '',
      bird: '',
      fish: '',
      robot: '',
      magical: '',
    };
    return icons[toyConfig.type] || '';
  };

  return (
    <div className="space-y-6 text-center">
      <motion.div
        initial={{ scale: 0 }}
        animate={{ scale: 1 }}
        transition={{ type: 'spring', duration: 0.5 }}
      >
        <div className="w-24 h-24 border-4 border-black bg-[#92cd41] mx-auto mb-6 flex items-center justify-center">
          <CheckCircle2 className="w-12 h-12 text-white" />
        </div>
      </motion.div>

      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ delay: 0.2 }}
        className="space-y-4"
      >
        <h2 className="font-minecraft text-base sm:text-lg lg:text-xl font-black uppercase tracking-wider text-gray-800"
          style={{
            textShadow: '2px 2px 0 #c381b5'
          }}
        >
          {toyConfig.name} is Ready!
        </h2>
        <div className="text-5xl mb-4">{getToyTypeIcon()}</div>
        <p className="font-geo text-sm sm:text-base font-medium text-gray-700 max-w-md mx-auto">
          Your AI companion has been successfully created and is excited to meet you!
        </p>
      </motion.div>

      <motion.div
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        transition={{ delay: 0.4 }}
      >
        <Card
          bg="#fefcd0"
          borderColor="black"
          shadowColor="#c381b5"
          className="p-[var(--spacing-xl)] max-w-md mx-auto"
        >
          <h3 className="retro-h3 text-base sm:text-lg text-black mb-3">What&apos;s Next?</h3>
          <div className="space-y-3 text-left">
            <div className="flex items-start gap-3">
              <MessageSquare className="w-5 h-5 text-[#c381b5] mt-0.5" />
              <div>
                <p className="font-black text-black uppercase tracking-wide">Start Chatting</p>
                <p className="font-geo text-sm font-medium text-gray-700">
                  Jump right into a conversation with {toyConfig.name}
                </p>
              </div>
            </div>
            <div className="flex items-start gap-3">
              <Settings className="w-5 h-5 text-[#f7931e] mt-0.5" />
              <div>
                <p className="font-black text-black uppercase tracking-wide">Customize Further</p>
                <p className="font-geo text-sm font-medium text-gray-700">
                  Fine-tune settings anytime from the dashboard
                </p>
              </div>
            </div>
            <div className="flex items-start gap-3">
              <Share2 className="w-5 h-5 text-[#92cd41] mt-0.5" />
              <div>
                <p className="font-black text-black uppercase tracking-wide">Share with Family</p>
                <p className="font-geo text-sm font-medium text-gray-700">
                  Invite family members to interact with {toyConfig.name}
                </p>
              </div>
            </div>
          </div>
        </Card>
      </motion.div>

      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ delay: 0.6 }}
        className="flex flex-col sm:flex-row gap-3 justify-center"
      >
        <Button
          bg="#c381b5"
          textColor="white"
          borderColor="black"
          shadow="#8b5fa3"
          onClick={handleStartChatting}
          className="group py-3 px-6 font-black uppercase tracking-wider hover-lift"
        >
          <MessageSquare className="w-4 h-4 mr-2" />
          Start Chatting
          <ArrowRight className="w-4 h-4 ml-2 group-hover:translate-x-1 transition-transform" />
        </Button>
        <Button
          bg="#ffffff"
          textColor="black"
          borderColor="black"
          shadow="#e0e0e0"
          onClick={handleGoToDashboard}
          className="py-3 px-6 font-black uppercase tracking-wider hover-lift"
        >
          Go to Dashboard
        </Button>
      </motion.div>

      <motion.div
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        transition={{ delay: 0.8 }}
        className="mt-8"
      >
        <Card
          bg="#f7931e"
          borderColor="black"
          shadowColor="#d67c1a"
          className="p-[var(--spacing-lg)] max-w-md mx-auto"
        >
          <div className="inline-flex items-center gap-2 text-sm font-bold text-white uppercase tracking-wide">
            <Sparkles className="w-4 h-4" />
            <span>Tip: Say &quot;Hello&quot; to {toyConfig.name} to start your first conversation!</span>
          </div>
        </Card>
      </motion.div>
    </div>
  );
}
</file>

<file path="src/components/dashboard/steps/DeviceStep.tsx">
'use client';

import { useState, useEffect, type ChangeEvent } from 'react';
import { Wifi, Terminal, Download, Info, CheckCircle2, ExternalLink } from 'lucide-react';
import { Button, Input, Card } from '@pommai/ui';
import { motion } from 'framer-motion';
import { useDeviceStore, type ConnectionType } from '@/stores/useDeviceStore';

export function DeviceStep() {
  const [deviceName, setDeviceName] = useState('');
  const [activeTab, setActiveTab] = useState<'wifi' | 'manual'>('wifi');
  
  const {
    isPairing,
    pairingStep,
    selectedDevice,
    error,
    startPairing,
    stopPairing,
    connectedDevices
  } = useDeviceStore();

  const isPaired = selectedDevice?.status === 'connected';
  const isScanning = isPairing && pairingStep === 'scanning';

  const handleStartPairing = async () => {
    try {
      await startPairing('wifi');
    } catch (error) {
      console.error('Failed to start pairing:', error);
    }
  };

  const handleSaveDeviceName = () => {
    if (deviceName.trim()) {
      // Save device name for later pairing
      console.log('Device name saved:', deviceName);
    }
  };

  // Clean up pairing session when component unmounts
  useEffect(() => {
    return () => {
      if (isPairing) {
        stopPairing();
      }
    };
  }, [isPairing, stopPairing]);

  return (
    <div className="space-y-6">
      <div className="text-center sm:text-left">
        <h2 className="font-minecraft text-base sm:text-lg lg:text-xl font-black mb-2 uppercase tracking-wider text-gray-800"
          style={{
            textShadow: '2px 2px 0 #c381b5'
          }}
        >
           Connect Your Raspberry Pi
        </h2>
        <p className="font-geo font-medium text-gray-700 tracking-wide">
          Set up your Raspberry Pi Zero 2W with the Pommai OS. You can skip this and set up later.
        </p>
      </div>

      <Card
        bg="#f7931e"
        borderColor="black"
        shadowColor="#d67c1a"
        className="p-4"
      >
        <p className="text-sm font-bold text-white flex items-start gap-2 uppercase tracking-wide">
          <Info className="w-4 h-4 mt-0.5 flex-shrink-0" />
          <span>
             Device pairing is optional. You can complete the toy creation now and pair your physical device later from the dashboard.
          </span>
        </p>
      </Card>

      {/* Display error if any */}
      {error && (
        <Card
          bg="#ffdddd"
          borderColor="red"
          shadowColor="#ff6b6b"
          className="p-4"
        >
          <p className="text-red-700 text-sm font-bold uppercase tracking-wide">
            ERROR: {error}
          </p>
        </Card>
      )}

      {/* Show connected devices */}
      {connectedDevices().length > 0 && !isPaired && (
        <Card
          bg="#e6f7ff"
          borderColor="blue"
          shadowColor="#91d5ff"
          className="p-4"
        >
          <p className="text-blue-700 text-sm font-bold uppercase tracking-wide">
             Found {connectedDevices().length} connected device(s). Select one to assign to your toy.
          </p>
        </Card>
      )}

      {isPaired ? (
        <motion.div
          initial={{ opacity: 0, scale: 0.9 }}
          animate={{ opacity: 1, scale: 1 }}
          className="text-center py-12"
        >
          <div className="w-20 h-20 border-4 border-black bg-[#92cd41] mx-auto mb-4 flex items-center justify-center">
            <CheckCircle2 className="w-10 h-10 text-white" />
          </div>
          <h3 className="retro-h3 text-xl text-black mb-2">
             Device Paired Successfully!
          </h3>
          <p className="font-bold text-gray-700 uppercase tracking-wide mb-4">
            {selectedDevice?.name || 'Your device'} is now connected and ready to interact.
          </p>
          {selectedDevice && (
            <Card
              bg="#fefcd0"
              borderColor="black"
              shadowColor="#c381b5"
              className="p-4 max-w-sm mx-auto"
            >
              <div className="space-y-2 text-left">
                <p className="text-sm font-bold text-black">
                  <strong className="uppercase tracking-wider"> Device:</strong> {selectedDevice.name}
                </p>
                <p className="text-sm font-bold text-black">
                  <strong className="uppercase tracking-wider"> Battery:</strong> {selectedDevice.batteryLevel || 'N/A'}%
                </p>
                <p className="text-sm font-bold text-black">
                  <strong className="uppercase tracking-wider"> Signal:</strong> {selectedDevice.signalStrength || 'N/A'} dBm
                </p>
              </div>
            </Card>
          )}
        </motion.div>
      ) : (
        <Card
          bg="#ffffff"
          borderColor="black"
          shadowColor="#c381b5"
          className="p-4 sm:p-6"
        >
          {/* Tab Headers */}
          <div className="flex gap-2 mb-6">
            <Button
              bg={activeTab === 'wifi' ? "#c381b5" : "#ffffff"}
              textColor={activeTab === 'wifi' ? "white" : "black"}
              borderColor="black"
              shadow={activeTab === 'wifi' ? "#8b5fa3" : "#e0e0e0"}
              onClick={() => setActiveTab('wifi')}
              className="flex-1 py-2 px-4 font-bold uppercase tracking-wider hover-lift text-sm"
            >
              <Wifi className="w-4 h-4 mr-2" />
              WiFi Setup
            </Button>
            <Button
              bg={activeTab === 'manual' ? "#c381b5" : "#ffffff"}
              textColor={activeTab === 'manual' ? "white" : "black"}
              borderColor="black"
              shadow={activeTab === 'manual' ? "#8b5fa3" : "#e0e0e0"}
              onClick={() => setActiveTab('manual')}
              className="flex-1 py-2 px-4 font-bold uppercase tracking-wider hover-lift text-sm"
            >
              <Terminal className="w-4 h-4 mr-2" />
              Manual Setup
            </Button>
          </div>

          {/* Tab Content */}
          {activeTab === 'wifi' && (
            <div className="space-y-4">
              <div className="text-center mb-6">
                <div className="w-20 h-20 border-4 border-black bg-[#f7931e] mx-auto mb-4 flex items-center justify-center">
                  <Wifi className="w-10 h-10 text-white" />
                </div>
                <h3 className="font-minecraft text-lg text-black mb-2 uppercase tracking-wider">
                   WiFi Access Point Setup
                </h3>
                <p className="text-sm font-bold text-gray-700 uppercase tracking-wide">
                  Connect your Raspberry Pi to your home WiFi
                </p>
              </div>

              <div className="space-y-4">
                {/* Step-by-step instructions */}
                <Card
                  bg="#92cd41"
                  borderColor="black"
                  shadowColor="#76a83a"
                  className="p-4"
                >
                  <p className="text-sm font-black text-white mb-3 uppercase tracking-wider"> Quick Setup Steps:</p>
                  <ol className="text-sm font-bold text-white space-y-2 list-decimal list-inside">
                    <li>Download the Pommai OS image for Raspberry Pi</li>
                    <li>Flash it to your SD card using Raspberry Pi Imager</li>
                    <li>Insert SD card and power on your Pi</li>
                    <li>The Pi will create a WiFi network: "Pommai-Toy-Setup"</li>
                    <li>Connect to this network from your phone/computer</li>
                    <li>A setup page will open automatically</li>
                    <li>Select your home WiFi and enter password</li>
                    <li>Your toy will connect and be ready!</li>
                  </ol>
                </Card>

                <div className="space-y-3">
                  <Button
                    bg="#c381b5"
                    textColor="white"
                    borderColor="black"
                    shadow="#8b5fa3"
                    onClick={() => window.open('/downloads/pommai-os.img', '_blank')}
                    className="w-full py-3 px-6 font-minecraft font-black uppercase tracking-wider hover-lift flex items-center justify-center gap-2"
                  >
                    <Download className="w-5 h-5" />
                    Download Pommai OS
                  </Button>
                  
                  <Button
                    bg="#ffffff"
                    textColor="black"
                    borderColor="black"
                    shadow="#e0e0e0"
                    onClick={() => window.open('https://www.raspberrypi.com/software/', '_blank')}
                    className="w-full py-3 px-6 font-minecraft font-black uppercase tracking-wider hover-lift flex items-center justify-center gap-2"
                  >
                    <ExternalLink className="w-4 h-4" />
                    Get Raspberry Pi Imager
                  </Button>
                </div>

                <Card
                  bg="#fefcd0"
                  borderColor="black"
                  shadowColor="#c381b5"
                  className="p-4"
                >
                  <p className="text-xs font-geo text-gray-700">
                    <strong> Note:</strong> After setup, your Pi will automatically connect to the Pommai cloud and FastRTC server for real-time voice interactions.
                  </p>
                </Card>

                <div className="space-y-2">
                  <label className="block text-sm font-black uppercase tracking-wider text-black">Device Name (Optional)</label>
                  <Input
                    type="text"
                    placeholder="Living Room Toy"
                    value={deviceName}
                    onChange={(e: ChangeEvent<HTMLInputElement>) => setDeviceName(e.target.value)}
                    bg="#ffffff"
                    borderColor="black"
                    className="font-geo font-medium"
                  />
                  <p className="text-xs font-geo text-gray-600">Give your device a friendly name to identify it later</p>
                </div>
              </div>
            </div>
          )}

          {activeTab === 'manual' && (
            <div className="space-y-4">
              <div className="text-center mb-6">
                <div className="w-20 h-20 border-4 border-black bg-[#92cd41] mx-auto mb-4 flex items-center justify-center">
                  <Terminal className="w-10 h-10 text-white" />
                </div>
                <h3 className="font-minecraft text-lg text-black mb-2 uppercase tracking-wider">
                   Manual Setup
                </h3>
                <p className="text-sm font-bold text-gray-700 uppercase tracking-wide">
                  For advanced users who want to configure manually
                </p>
              </div>

              <Card
                bg="#ffffff"
                borderColor="black"
                shadowColor="#c381b5"
                className="p-4"
              >
                <p className="text-sm font-black text-black mb-3 uppercase tracking-wider"> SSH Setup:</p>
                <div className="bg-black text-green-400 p-3 rounded font-mono text-xs overflow-x-auto">
                  <p># 1. SSH into your Raspberry Pi</p>
                  <p>$ ssh pi@raspberrypi.local</p>
                  <p className="text-gray-500"># Default password: raspberry</p>
                  <p className="mt-2"># 2. Clone the Pommai repository</p>
                  <p>$ git clone https://github.com/yourusername/pommai-pi.git</p>
                  <p className="mt-2"># 3. Run the setup script</p>
                  <p>$ cd pommai-pi && ./setup.sh</p>
                  <p className="mt-2"># 4. Configure WiFi</p>
                  <p>$ sudo raspi-config</p>
                </div>
              </Card>

              <Card
                bg="#ffe4e1"
                borderColor="red"
                shadowColor="#ff6b6b"
                className="p-4"
              >
                <p className="text-xs font-geo text-red-700">
                  <strong> Warning:</strong> Manual setup requires Linux command line knowledge. We recommend using the WiFi Setup method for easier configuration.
                </p>
              </Card>

              <Card
                bg="#fefcd0"
                borderColor="black"
                shadowColor="#c381b5"
                className="p-4"
              >
                <p className="text-sm font-black text-black mb-2 uppercase tracking-wider"> Required Hardware:</p>
                <ul className="text-sm font-geo text-gray-700 space-y-1 list-disc list-inside">
                  <li>Raspberry Pi Zero 2W</li>
                  <li>ReSpeaker 2-Mics Pi HAT</li>
                  <li>MicroSD card (8GB minimum)</li>
                  <li>5V power supply</li>
                  <li>Optional: Speaker for audio output</li>
                </ul>
              </Card>

              <Button
                bg="#ffffff"
                textColor="black"
                borderColor="black"
                shadow="#e0e0e0"
                onClick={() => window.open('https://github.com/yourusername/pommai-pi/blob/main/README.md', '_blank')}
                className="w-full py-3 px-6 font-minecraft font-black uppercase tracking-wider hover-lift flex items-center justify-center gap-2"
              >
                <ExternalLink className="w-4 h-4" />
                View Full Documentation
              </Button>
            </div>
          )}
        </Card>
      )}

      <div className="flex items-center justify-center">
        <Button
          bg="#ffffff"
          textColor="black"
          borderColor="black"
          shadow="#e0e0e0"
          className="py-2 px-4 font-bold uppercase tracking-wider hover-lift"
        >
           Skip for Now
        </Button>
      </div>
    </div>
  );
}
</file>

<file path="src/components/dashboard/steps/ForKidsToggleStep.tsx">
'use client';

import { useToyWizardStore } from '@/stores/toyWizardStore';
import { Card } from '@pommai/ui';
import { Shield, Users, Baby, Zap } from 'lucide-react';
import { motion } from 'framer-motion';

const AGE_GROUPS = [
  { 
    id: '3-5', 
    name: 'Ages 3-5', 
    description: 'Simple vocabulary, basic concepts',
    icon: Baby,
  },
  { 
    id: '6-8', 
    name: 'Ages 6-8', 
    description: 'Educational focus, storytelling',
    icon: Users,
  },
  { 
    id: '9-12', 
    name: 'Ages 9-12', 
    description: 'Advanced topics, creative play',
    icon: Zap,
  },
];

export function ForKidsToggleStep() {
  const { toyConfig, updateToyConfig, updateSafetySettings } = useToyWizardStore();

  const handleModeChange = (isForKids: boolean) => {
    updateToyConfig('isForKids', isForKids);
    
    if (isForKids && !toyConfig.safetySettings) {
      // Initialize default safety settings for kids mode
      updateSafetySettings({
        safetyLevel: 'moderate',
        contentFilters: {
          enabledCategories: ['language', 'topics', 'personal-info'],
          customBlockedTopics: [],
        },
      });
    }
  };

  const handleAgeGroupChange = (ageGroup: '3-5' | '6-8' | '9-12') => {
    updateToyConfig('ageGroup', ageGroup);
    
    // Adjust safety level based on age group
    const safetyLevel = ageGroup === '3-5' ? 'strict' : 
                       ageGroup === '6-8' ? 'moderate' : 
                       'relaxed';
    
    updateSafetySettings({ safetyLevel });
  };

  return (
    <div className="space-y-6 step-component">
      <div className="text-center sm:text-left">
        <h2 className="font-minecraft text-base sm:text-lg font-black mb-3 uppercase tracking-wider text-gray-800"
          style={{
            textShadow: '2px 2px 0 #c381b5'
          }}
        >
           Who is this toy for?
        </h2>
        <p className="font-geo text-sm font-medium text-gray-600 tracking-wide leading-relaxed">
          Choose whether to enable Guardian Mode with enhanced safety features for children.
        </p>
      </div>

      {/* Mode Selection */}
      <div className="space-y-4">
        <label className="font-geo block text-sm font-semibold uppercase tracking-wider text-black mb-2">Select Mode</label>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          {/* Kids Mode */}
          <motion.label
            whileHover={{ scale: 1.02 }}
            whileTap={{ scale: 0.98 }}
            className={`
              relative flex flex-col p-6 border-[5px] cursor-pointer transition-all hover-lift
              ${ toyConfig.isForKids 
                ? 'border-black bg-[#c381b5] text-white' 
                : 'border-black bg-white text-black hover:bg-[#fefcd0]'
              }
            `}
            style={{
              borderImageSlice: 3,
              borderImageWidth: 2,
              borderImageRepeat: 'stretch',
              borderImageOutset: 2,
              boxShadow: toyConfig.isForKids
                ? '2px 2px 0 2px #8b5fa3, -2px -2px 0 2px #c381b5'
                : '2px 2px 0 2px #e0e0e0, -2px -2px 0 2px #ffffff',
            }}
          >
            <input
              type="radio"
              name="mode"
              checked={toyConfig.isForKids}
              onChange={() => handleModeChange(true)}
              className="sr-only"
            />
            <div className="flex items-start gap-4">
              <div className={`w-12 h-12 border-2 border-black flex items-center justify-center ${
                toyConfig.isForKids ? 'bg-white text-[#c381b5]' : 'bg-[#fefcd0] text-black'
              }`}>
                <Shield className="w-6 h-6" />
              </div>
              <div className="flex-1">
                <h3 className="font-minecraft font-black text-base uppercase tracking-wider mb-3">
                  Guardian Mode (For Kids)
                </h3>
                <p className="font-geo text-sm font-medium opacity-90 leading-relaxed mb-4">
                  Enhanced safety features, content filtering, and age-appropriate interactions
                </p>
                <ul className="space-y-2 text-sm font-geo font-medium">
                  <li className="flex items-center gap-2">
                    <span className="text-[#92cd41] font-bold"></span>
                    <span>Strict content moderation</span>
                  </li>
                  <li className="flex items-center gap-2">
                    <span className="text-[#92cd41] font-bold"></span>
                    <span>No personal information collection</span>
                  </li>
                  <li className="flex items-center gap-2">
                    <span className="text-[#92cd41] font-bold"></span>
                    <span>Educational focus</span>
                  </li>
                </ul>
              </div>
            </div>
          </motion.label>

          {/* General Mode */}
          <motion.label
            whileHover={{ scale: 1.02 }}
            whileTap={{ scale: 0.98 }}
            className={`
              relative flex flex-col p-6 border-[5px] cursor-pointer transition-all hover-lift
              ${ !toyConfig.isForKids 
                ? 'border-black bg-[#c381b5] text-white' 
                : 'border-black bg-white text-black hover:bg-[#fefcd0]'
              }
            `}
            style={{
              borderImageSlice: 3,
              borderImageWidth: 2,
              borderImageRepeat: 'stretch',
              borderImageOutset: 2,
              boxShadow: !toyConfig.isForKids
                ? '2px 2px 0 2px #8b5fa3, -2px -2px 0 2px #c381b5'
                : '2px 2px 0 2px #e0e0e0, -2px -2px 0 2px #ffffff',
            }}
          >
            <input
              type="radio"
              name="mode"
              checked={!toyConfig.isForKids}
              onChange={() => handleModeChange(false)}
              className="sr-only"
            />
            <div className="flex items-start gap-4">
              <div className={`w-12 h-12 border-2 border-black flex items-center justify-center ${
                !toyConfig.isForKids ? 'bg-white text-[#c381b5]' : 'bg-[#fefcd0] text-black'
              }`}>
                <Users className="w-6 h-6" />
              </div>
              <div className="flex-1">
                <h3 className="font-minecraft font-black text-base uppercase tracking-wider mb-3">
                  General Mode
                </h3>
                <p className="font-geo text-sm font-medium opacity-90 leading-relaxed mb-4">
                  Full features for teens and adults with standard safety measures
                </p>
                <ul className="space-y-2 text-sm font-geo font-medium">
                  <li className="flex items-center gap-2">
                    <span className="text-[#f7931e] font-bold"></span>
                    <span>More conversational freedom</span>
                  </li>
                  <li className="flex items-center gap-2">
                    <span className="text-[#f7931e] font-bold"></span>
                    <span>Advanced personality options</span>
                  </li>
                  <li className="flex items-center gap-2">
                    <span className="text-[#f7931e] font-bold"></span>
                    <span>Complex interactions</span>
                  </li>
                </ul>
              </div>
            </div>
          </motion.label>
        </div>
      </div>

      {/* Age Group Selection (only for Kids Mode) */}
      {toyConfig.isForKids && (
        <motion.div
          initial={{ opacity: 0, height: 0 }}
          animate={{ opacity: 1, height: 'auto' }}
          exit={{ opacity: 0, height: 0 }}
          className="space-y-4"
        >
          <label className="font-geo block text-sm font-semibold uppercase tracking-wider text-black mb-3">Select Age Group</label>
          <div className="grid grid-cols-1 md:grid-cols-3 gap-3">
            {AGE_GROUPS.map((group) => (
              <label
                key={group.id}
                htmlFor={`age-${group.id}`}
                className={`
                  relative flex items-center p-4 border-[5px] cursor-pointer transition-all hover-lift
                  ${ toyConfig.ageGroup === group.id 
                    ? 'border-black bg-[#c381b5] text-white' 
                    : 'border-black bg-white text-black hover:bg-[#fefcd0]'
                  }
                `}
                style={{
                  borderImageSlice: 3,
                  borderImageWidth: 2,
                  borderImageRepeat: 'stretch',
                  borderImageOutset: 2,
                  boxShadow: toyConfig.ageGroup === group.id
                    ? '2px 2px 0 2px #8b5fa3, -2px -2px 0 2px #c381b5'
                    : '2px 2px 0 2px #e0e0e0, -2px -2px 0 2px #ffffff',
                }}
              >
                <input
                  id={`age-${group.id}`}
                  type="radio"
                  name="ageGroup"
                  value={group.id}
                  checked={toyConfig.ageGroup === group.id}
                  onChange={(e) => handleAgeGroupChange(e.target.value as '3-5' | '6-8' | '9-12')}
                  className="sr-only"
                />
                <div className="flex items-center gap-3 w-full">
                  <group.icon className={`w-8 h-8 ${
                    toyConfig.ageGroup === group.id ? 'text-white' : 'text-[#c381b5]'
                  }`} />
                  <div>
                    <span className="font-minecraft font-black text-sm uppercase tracking-wider">{group.name}</span>
                    <p className="font-geo text-xs font-medium opacity-80 leading-relaxed">{group.description}</p>
                  </div>
                </div>
              </label>
            ))}
          </div>
        </motion.div>
      )}

      {/* Information Box */}
      <Card
        bg={toyConfig.isForKids ? "#92cd41" : "#c381b5"}
        borderColor="black"
        shadowColor={toyConfig.isForKids ? "#76a83a" : "#8b5fa3"}
        className="p-4"
      >
        <p className="font-geo text-sm font-medium text-white leading-relaxed">
          <strong className="font-minecraft uppercase tracking-wider"> Note:</strong> {
            toyConfig.isForKids 
              ? 'Guardian Mode includes automatic content filtering, safe conversation boundaries, and parental controls. Safety settings can be customized in the next steps.'
              : 'General Mode is designed for mature users who want full creative freedom with their AI companion. Basic safety measures are still in place.'
          }
        </p>
      </Card>
    </div>
  );
}
</file>

<file path="src/components/dashboard/steps/KnowledgeStep.tsx">
'use client';

import { useState, type ChangeEvent, type KeyboardEvent } from 'react';
import { useToyWizardStore } from '@/stores/toyWizardStore';
import { Input, TextArea, Button, Card } from '@pommai/ui';
import { 
  Plus, 
  X, 
  Book, 
  Info,
  Sparkles
} from 'lucide-react';

export function KnowledgeStep() {
  const { toyConfig, updateKnowledgeBase } = useToyWizardStore();
  const [newAbility, setNewAbility] = useState('');
  const [newFavoriteThing, setNewFavoriteThing] = useState('');
  const [newCustomFact, setNewCustomFact] = useState<{ category: string; fact: string; importance: 'low' | 'medium' | 'high' }>({ category: '', fact: '', importance: 'medium' });

  const initializeKnowledgeBase = () => {
    if (!toyConfig.knowledgeBase) {
      updateKnowledgeBase({
        toyBackstory: {
          origin: '',
          personality: '',
          specialAbilities: [],
          favoriteThings: [],
        },
        customFacts: [],
      });
    }
  };

  const addSpecialAbility = () => {
    if (newAbility.trim()) {
      initializeKnowledgeBase();
      const abilities = [...(toyConfig.knowledgeBase?.toyBackstory.specialAbilities || []), newAbility.trim()];
      updateKnowledgeBase({
        toyBackstory: {
          ...toyConfig.knowledgeBase!.toyBackstory,
          specialAbilities: abilities,
        },
      });
      setNewAbility('');
    }
  };

  const removeSpecialAbility = (index: number) => {
    if (!toyConfig.knowledgeBase) return;
    const abilities = [...(toyConfig.knowledgeBase.toyBackstory.specialAbilities || [])];
    abilities.splice(index, 1);
    updateKnowledgeBase({
      toyBackstory: {
        ...toyConfig.knowledgeBase.toyBackstory,
        specialAbilities: abilities,
      },
    });
  };

  const addFavoriteThing = () => {
    if (newFavoriteThing.trim()) {
      initializeKnowledgeBase();
      const things = [...(toyConfig.knowledgeBase?.toyBackstory.favoriteThings || []), newFavoriteThing.trim()];
      updateKnowledgeBase({
        toyBackstory: {
          ...toyConfig.knowledgeBase!.toyBackstory,
          favoriteThings: things,
        },
      });
      setNewFavoriteThing('');
    }
  };

  const removeFavoriteThing = (index: number) => {
    if (!toyConfig.knowledgeBase) return;
    const things = [...(toyConfig.knowledgeBase.toyBackstory.favoriteThings || [])];
    things.splice(index, 1);
    updateKnowledgeBase({
      toyBackstory: {
        ...toyConfig.knowledgeBase.toyBackstory,
        favoriteThings: things,
      },
    });
  };

  const addCustomFact = () => {
    if (newCustomFact.category && newCustomFact.fact) {
      initializeKnowledgeBase();
      const facts = [...(toyConfig.knowledgeBase?.customFacts || [])];
      facts.push({
        category: newCustomFact.category,
        fact: newCustomFact.fact,
        importance: newCustomFact.importance,
      });
      updateKnowledgeBase({ customFacts: facts });
      setNewCustomFact({ category: '', fact: '', importance: 'medium' });
    }
  };

  return (
    <div className="space-y-6">
      <div className="text-center sm:text-left">
        <h2 className="font-minecraft text-base sm:text-lg lg:text-xl font-black mb-2 uppercase tracking-wider text-gray-800"
          style={{
            textShadow: '2px 2px 0 #c381b5'
          }}
        >
           Build {toyConfig.name}&apos;s Knowledge Base
        </h2>
        <p className="font-geo font-medium text-gray-700 tracking-wide">
          Add information about {toyConfig.name}&apos;s backstory, family details, and special knowledge. This helps create more personalized interactions.
        </p>
      </div>

      <Card
        bg="#f7931e"
        borderColor="black"
        shadowColor="#d67c1a"
        className="p-4"
      >
        <p className="text-sm font-bold text-white flex items-start gap-2 uppercase tracking-wide">
          <Info className="w-4 h-4 mt-0.5 flex-shrink-0" />
          <span> This step is optional but highly recommended for a more engaging experience. You can always update this information later.</span>
        </p>
      </Card>

      {/* Knowledge Sections */}
      <div className="space-y-4">
        {/* Toy Backstory */}
        <Card
          bg="#ffffff"
          borderColor="black"
          shadowColor="#c381b5"
          className="p-4 sm:p-6"
        >
          <h3 className="retro-h3 text-lg text-black mb-4 flex items-center gap-2">
            <Book className="w-5 h-5" />
             {toyConfig.name}&apos;s Backstory
          </h3>
          
          <div className="space-y-4">
            <div className="space-y-2">
              <label className="block text-sm font-black uppercase tracking-wider text-black">Origin Story</label>
              <TextArea
                value={toyConfig.knowledgeBase?.toyBackstory?.origin || ''}
                onChange={(e: ChangeEvent<HTMLTextAreaElement>) => {
                  initializeKnowledgeBase();
                  if (!toyConfig.knowledgeBase) return;
                  updateKnowledgeBase({
                    toyBackstory: {
                      ...toyConfig.knowledgeBase.toyBackstory,
                      origin: e.target.value,
                    },
                  });
                }}
                placeholder={`Where did ${toyConfig.name} come from? What&apos;s their magical origin?`}
                rows={3}
                bg="#ffffff"
                borderColor="black"
                className="font-bold resize-none"
              />
            </div>

            <div className="space-y-2">
              <label className="block text-sm font-black uppercase tracking-wider text-black">Personality Background</label>
              <TextArea
                value={toyConfig.knowledgeBase?.toyBackstory?.personality || ''}
                onChange={(e: ChangeEvent<HTMLTextAreaElement>) => {
                  initializeKnowledgeBase();
                  if (!toyConfig.knowledgeBase) return;
                  updateKnowledgeBase({
                    toyBackstory: {
                      ...toyConfig.knowledgeBase.toyBackstory,
                      personality: e.target.value,
                    },
                  });
                }}
                placeholder={`What shaped ${toyConfig.name}&apos;s personality? Any special experiences?`}
                rows={3}
                bg="#ffffff"
                borderColor="black"
                className="font-bold resize-none"
              />
            </div>

            {/* Special Abilities */}
            <div className="space-y-3">
              <label className="block text-sm font-black uppercase tracking-wider text-black">Special Abilities</label>
              <div className="flex gap-2">
                <Input
                  value={newAbility}
                  onChange={(e: ChangeEvent<HTMLInputElement>) => setNewAbility(e.target.value)}
                  placeholder={`What special powers does ${toyConfig.name} have?`}
                  onKeyPress={(e: KeyboardEvent<HTMLInputElement>) => e.key === 'Enter' && addSpecialAbility()}
                  bg="#ffffff"
                  borderColor="black"
                  className="font-bold flex-1"
                />
                <Button
                  bg={newAbility.trim() ? "#92cd41" : "#f0f0f0"}
                  textColor={newAbility.trim() ? "white" : "#999"}
                  borderColor="black"
                  shadow={newAbility.trim() ? "#76a83a" : "#d0d0d0"}
                  onClick={addSpecialAbility}
                  disabled={!newAbility.trim()}
                  className={`py-2 px-3 font-bold ${newAbility.trim() ? 'hover-lift' : 'cursor-not-allowed'}`}
                >
                  <Plus className="w-4 h-4" />
                </Button>
              </div>
              <div className="flex flex-wrap gap-2">
                {toyConfig.knowledgeBase?.toyBackstory?.specialAbilities?.map((ability, index) => (
                  <span 
                    key={index} 
                    className="px-2 py-1 text-xs font-black uppercase tracking-wider border-2 border-black bg-[#c381b5] text-white flex items-center gap-2"
                  >
                    {ability}
                    <button
                      onClick={() => removeSpecialAbility(index)}
                      className="hover:text-red-200 transition-colors"
                    >
                      <X className="w-3 h-3" />
                    </button>
                  </span>
                ))}
              </div>
            </div>

            {/* Favorite Things */}
            <div className="space-y-3">
              <label className="block text-sm font-black uppercase tracking-wider text-black">Favorite Things</label>
              <div className="flex gap-2">
                <Input
                  value={newFavoriteThing}
                  onChange={(e: ChangeEvent<HTMLInputElement>) => setNewFavoriteThing(e.target.value)}
                  placeholder={`What does ${toyConfig.name} love most?`}
                  onKeyPress={(e: KeyboardEvent<HTMLInputElement>) => e.key === 'Enter' && addFavoriteThing()}
                  bg="#ffffff"
                  borderColor="black"
                  className="font-bold flex-1"
                />
                <Button
                  bg={newFavoriteThing.trim() ? "#92cd41" : "#f0f0f0"}
                  textColor={newFavoriteThing.trim() ? "white" : "#999"}
                  borderColor="black"
                  shadow={newFavoriteThing.trim() ? "#76a83a" : "#d0d0d0"}
                  onClick={addFavoriteThing}
                  disabled={!newFavoriteThing.trim()}
                  className={`py-2 px-3 font-bold ${newFavoriteThing.trim() ? 'hover-lift' : 'cursor-not-allowed'}`}
                >
                  <Plus className="w-4 h-4" />
                </Button>
              </div>
              <div className="flex flex-wrap gap-2">
                {toyConfig.knowledgeBase?.toyBackstory?.favoriteThings?.map((thing, index) => (
                  <span 
                    key={index} 
                    className="px-2 py-1 text-xs font-black uppercase tracking-wider border-2 border-black bg-[#f7931e] text-white flex items-center gap-2"
                  >
                    {thing}
                    <button
                      onClick={() => removeFavoriteThing(index)}
                      className="hover:text-red-200 transition-colors"
                    >
                      <X className="w-3 h-3" />
                    </button>
                  </span>
                ))}
              </div>
            </div>
          </div>
        </Card>

        {/* Custom Facts */}
        <Card
          bg="#fefcd0"
          borderColor="black"
          shadowColor="#92cd41"
          className="p-4 sm:p-6"
        >
          <h3 className="font-black text-lg uppercase tracking-wider text-black mb-4 flex items-center gap-2">
            <Sparkles className="w-5 h-5" />
             Custom Knowledge
          </h3>
          
          <div className="space-y-4">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div className="space-y-2">
                <label className="block text-sm font-black uppercase tracking-wider text-black">Category</label>
                <Input
                  value={newCustomFact.category}
                  onChange={(e: ChangeEvent<HTMLInputElement>) => setNewCustomFact({ ...newCustomFact, category: e.target.value })}
                  placeholder="e.g., Hobbies, Skills, Memories"
                  bg="#ffffff"
                  borderColor="black"
                  className="font-bold"
                />
              </div>
              <div className="space-y-2">
                <label className="block text-sm font-black uppercase tracking-wider text-black">Importance</label>
                <select
                  value={newCustomFact.importance}
                  onChange={(e: ChangeEvent<HTMLSelectElement>) => setNewCustomFact({ ...newCustomFact, importance: e.target.value as 'low' | 'medium' | 'high' })}
                  className="w-full p-2 border-2 border-black font-bold uppercase tracking-wider text-sm"
                >
                  <option value="low">Low</option>
                  <option value="medium">Medium</option>
                  <option value="high">High</option>
                </select>
              </div>
            </div>
            
            <div className="space-y-2">
              <label className="block text-sm font-black uppercase tracking-wider text-black">Fact</label>
              <TextArea
                value={newCustomFact.fact}
                onChange={(e: ChangeEvent<HTMLTextAreaElement>) => setNewCustomFact({ ...newCustomFact, fact: e.target.value })}
                placeholder="What should your toy know or remember?"
                rows={2}
                bg="#ffffff"
                borderColor="black"
                className="font-bold resize-none"
              />
            </div>
            
            <Button
              bg={newCustomFact.category && newCustomFact.fact ? "#92cd41" : "#f0f0f0"}
              textColor={newCustomFact.category && newCustomFact.fact ? "white" : "#999"}
              borderColor="black"
              shadow={newCustomFact.category && newCustomFact.fact ? "#76a83a" : "#d0d0d0"}
              onClick={addCustomFact}
              disabled={!newCustomFact.category || !newCustomFact.fact}
              className={`w-full py-2 px-4 font-bold uppercase tracking-wider ${newCustomFact.category && newCustomFact.fact ? 'hover-lift' : 'cursor-not-allowed'}`}
            >
              <Plus className="w-4 h-4 mr-2" />
              Add Custom Fact
            </Button>
            
            {/* Display existing custom facts */}
            {toyConfig.knowledgeBase?.customFacts && toyConfig.knowledgeBase.customFacts.length > 0 && (
              <div className="space-y-2">
                <h4 className="font-black text-sm uppercase tracking-wider text-black">Added Facts:</h4>
                <div className="space-y-2">
                  {toyConfig.knowledgeBase.customFacts.map((fact, index) => (
                    <div key={index} className="p-3 border-2 border-black bg-white">
                      <div className="flex justify-between items-start">
                        <div className="flex-1">
                          <span className="px-2 py-1 text-xs font-black uppercase tracking-wider border border-black bg-[#92cd41] text-white mr-2">
                            {fact.category}
                          </span>
                          <span className={`px-1 py-0.5 text-xs font-bold uppercase ${
                            fact.importance === 'high' ? 'text-red-600' :
                            fact.importance === 'medium' ? 'text-orange-600' : 'text-gray-600'
                          }`}>
                            {fact.importance}
                          </span>
                          <p className="mt-2 text-sm font-bold text-black">{fact.fact}</p>
                        </div>
                        <button
                          onClick={() => {
                            const facts = [...toyConfig.knowledgeBase!.customFacts];
                            facts.splice(index, 1);
                            updateKnowledgeBase({ customFacts: facts });
                          }}
                          className="ml-3 text-red-600 hover:text-red-800 transition-colors"
                        >
                          <X className="w-4 h-4" />
                        </button>
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>
        </Card>
      </div>
    </div>
  );
}
</file>

<file path="src/components/dashboard/steps/PersonalityStep.tsx">
'use client';

import { useState, type ChangeEvent, type KeyboardEvent } from 'react';
import { useToyWizardStore } from '@/stores/toyWizardStore';
import { TextArea, Button, Input, Card } from '@pommai/ui';
import { 
  Plus, 
  X, 
  Sparkles, 
  BookOpen, 
  Gamepad2, 
  MessageSquare,
  Brain,
  Heart,
  Zap,
  Star
} from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';

const PERSONALITY_TRAITS = [
  { id: 'friendly', name: 'Friendly', icon: Heart },
  { id: 'curious', name: 'Curious', icon: Brain },
  { id: 'playful', name: 'Playful', icon: Gamepad2 },
  { id: 'helpful', name: 'Helpful', icon: Star },
  { id: 'creative', name: 'Creative', icon: Sparkles },
  { id: 'adventurous', name: 'Adventurous', icon: Zap },
  { id: 'patient', name: 'Patient', icon: Heart },
  { id: 'funny', name: 'Funny', icon: MessageSquare },
  { id: 'wise', name: 'Wise', icon: BookOpen },
];

export function PersonalityStep() {
  const { toyConfig, updateToyConfig, updatePersonalityTraits, setError, clearError } = useToyWizardStore();
  const [newCatchPhrase, setNewCatchPhrase] = useState('');
  const [newInterest, setNewInterest] = useState('');
  const [newFavoriteTopic, setNewFavoriteTopic] = useState('');
  const [newAvoidTopic, setNewAvoidTopic] = useState('');

  const handlePersonalityPromptChange = (value: string) => {
    updateToyConfig('personalityPrompt', value);
    if (value.trim()) {
      clearError('personalityPrompt');
    } else {
      setError('personalityPrompt', 'Please describe your toy\'s personality');
    }
  };

  const toggleTrait = (traitId: string) => {
    const currentTraits = [...toyConfig.personalityTraits.traits];
    const index = currentTraits.indexOf(traitId);
    
    if (index > -1) {
      currentTraits.splice(index, 1);
    } else if (currentTraits.length < 3) {
      currentTraits.push(traitId);
    }
    
    updatePersonalityTraits({ traits: currentTraits });
  };

  const addCatchPhrase = () => {
    if (newCatchPhrase.trim()) {
      updatePersonalityTraits({
        speakingStyle: {
          ...toyConfig.personalityTraits.speakingStyle,
          catchPhrases: [...toyConfig.personalityTraits.speakingStyle.catchPhrases, newCatchPhrase.trim()],
        },
      });
      setNewCatchPhrase('');
    }
  };

  const removeCatchPhrase = (index: number) => {
    const phrases = [...toyConfig.personalityTraits.speakingStyle.catchPhrases];
    phrases.splice(index, 1);
    updatePersonalityTraits({
      speakingStyle: {
        ...toyConfig.personalityTraits.speakingStyle,
        catchPhrases: phrases,
      },
    });
  };

  const addItem = (type: 'interests' | 'favoriteTopics' | 'avoidTopics', value: string) => {
    if (value.trim()) {
      updatePersonalityTraits({
        [type]: [...toyConfig.personalityTraits[type], value.trim()],
      });
    }
  };

  const removeItem = (type: 'interests' | 'favoriteTopics' | 'avoidTopics', index: number) => {
    const items = [...toyConfig.personalityTraits[type]];
    items.splice(index, 1);
    updatePersonalityTraits({ [type]: items });
  };

  return (
    <div className="space-y-6 step-component">
      <div className="text-center sm:text-left">
        <h2 className="font-minecraft text-base sm:text-lg font-black mb-3 uppercase tracking-wider text-gray-800"
          style={{
            textShadow: '2px 2px 0 #c381b5'
          }}
        >
           Design {toyConfig.name}&apos;s Personality
        </h2>
        <p className="font-geo text-sm font-medium text-gray-600 tracking-wide leading-relaxed">
          Create a unique personality that will make {toyConfig.name} special and engaging.
        </p>
      </div>

      {/* Personality Description */}
      <div className="space-y-3">
        <label className="block text-sm font-geo font-semibold uppercase tracking-wider text-gray-700">
          Personality Description
          <span className="text-red-500 ml-1">*</span>
        </label>
        <TextArea
          value={toyConfig.personalityPrompt}
          onChange={(e: ChangeEvent<HTMLTextAreaElement>) => handlePersonalityPromptChange(e.target.value)}
          placeholder={`Describe ${toyConfig.name}'s personality in detail. For example: "${toyConfig.name} is a cheerful and curious companion who loves to tell stories about space adventures..."`}
          rows={4}
          bg="#ffffff"
          borderColor="black"
          className="font-geo font-medium resize-none"
        />
        <p className="font-geo text-sm font-medium text-gray-600 leading-relaxed">
          This description will guide how {toyConfig.name} interacts and responds
        </p>
      </div>

      {/* Personality Traits */}
      <div className="space-y-4">
        <div>
          <label className="font-geo block text-sm font-semibold uppercase tracking-wider text-black mb-2">
            Core Personality Traits (Select up to 3)
            <span className="text-red-500 ml-1">*</span>
          </label>
          <p className="font-geo text-sm font-medium text-gray-600 leading-relaxed">Choose traits that best define {toyConfig.name}</p>
        </div>
        <div className="grid grid-cols-3 gap-3">
          {PERSONALITY_TRAITS.map((trait) => {
            const isSelected = toyConfig.personalityTraits.traits.includes(trait.id);
            const isDisabled = !isSelected && toyConfig.personalityTraits.traits.length >= 3;
            
            return (
              <motion.button
                key={trait.id}
                whileHover={!isDisabled ? { scale: 1.05 } : {}}
                whileTap={!isDisabled ? { scale: 0.95 } : {}}
                onClick={() => !isDisabled && toggleTrait(trait.id)}
                disabled={isDisabled}
                className={`
                  p-3 border-[5px] transition-all flex flex-col items-center gap-2 font-minecraft font-black uppercase tracking-wider
                  ${isSelected 
                    ? 'border-black bg-[#c381b5] text-white' 
                    : isDisabled
                    ? 'border-black bg-[#f0f0f0] text-gray-400 cursor-not-allowed'
                    : 'border-black bg-white text-black hover:bg-[#fefcd0] hover-lift'
                  }
                `}
                style={{
                  borderImageSlice: 3,
                  borderImageWidth: 2,
                  borderImageRepeat: 'stretch',
                  borderImageOutset: 2,
                  boxShadow: isSelected
                    ? '2px 2px 0 2px #8b5fa3, -2px -2px 0 2px #c381b5'
                    : isDisabled
                    ? '2px 2px 0 2px #d0d0d0, -2px -2px 0 2px #f0f0f0'
                    : '2px 2px 0 2px #e0e0e0, -2px -2px 0 2px #ffffff',
                }}
              >
                <trait.icon className="w-6 h-6" />
                <span className="text-xs sm:text-sm">{trait.name}</span>
              </motion.button>
            );
          })}
        </div>
      </div>

      {/* Speaking Style */}
      <Card
        bg="#fefcd0"
        borderColor="black"
        shadowColor="#c381b5"
        className="p-4 sm:p-6"
      >
        <h3 className="font-minecraft font-black text-base uppercase tracking-wider text-gray-800 mb-4"> Speaking Style</h3>
        
        <div className="grid grid-cols-1 gap-4 sm:gap-6">
          <div>
            <label className="font-geo block text-sm font-semibold uppercase tracking-wider text-black mb-3">Vocabulary Level</label>
            <div className="space-y-2">
              {[
                { value: 'simple', label: 'Simple (Basic words)' },
                { value: 'moderate', label: 'Moderate (Everyday language)' },
                { value: 'advanced', label: 'Advanced (Rich vocabulary)' }
              ].map((option) => (
                <label 
                  key={option.value}
                  className="flex items-center gap-2 cursor-pointer p-2 hover:bg-white rounded transition-colors"
                >
                  <input
                    type="radio"
                    name="vocabulary"
                    value={option.value}
                    checked={toyConfig.personalityTraits.speakingStyle.vocabulary === option.value}
                    onChange={(e) => updatePersonalityTraits({
                      speakingStyle: {
                        ...toyConfig.personalityTraits.speakingStyle,
                        vocabulary: e.target.value as 'simple' | 'moderate' | 'advanced',
                      },
                    })}
                    className="pixel-checkbox"
                  />
                  <span className="font-geo text-sm font-medium">{option.label}</span>
                </label>
              ))}
            </div>
          </div>
        </div>

        {/* Catch Phrases */}
        <div className="space-y-3 mt-6">
          <label className="font-geo block text-sm font-semibold uppercase tracking-wider text-black mb-2">Catch Phrases</label>
          <div className="flex gap-2">
            <Input
              value={newCatchPhrase}
              onChange={(e: ChangeEvent<HTMLInputElement>) => setNewCatchPhrase(e.target.value)}
              placeholder="Add a catch phrase..."
              onKeyPress={(e: KeyboardEvent<HTMLInputElement>) => e.key === 'Enter' && addCatchPhrase()}
              bg="#ffffff"
              borderColor="black"
              className="font-geo font-medium flex-1"
            />
            <Button
              bg={newCatchPhrase.trim() ? "#92cd41" : "#f0f0f0"}
              textColor={newCatchPhrase.trim() ? "white" : "#999"}
              borderColor="black"
              shadow={newCatchPhrase.trim() ? "#76a83a" : "#d0d0d0"}
              onClick={addCatchPhrase}
              disabled={!newCatchPhrase.trim()}
              className={`py-2 px-3 font-minecraft font-black ${newCatchPhrase.trim() ? 'hover-lift' : 'cursor-not-allowed'}`}
            >
              <Plus className="w-4 h-4" />
            </Button>
          </div>
          <div className="flex flex-wrap gap-2">
            {toyConfig.personalityTraits.speakingStyle.catchPhrases.map((phrase, index) => (
              <span 
                key={index} 
                className="px-2 py-1 text-xs font-black uppercase tracking-wider border-2 border-black bg-[#f7931e] text-white flex items-center gap-2"
              >
                {phrase}
                <button
                  onClick={() => removeCatchPhrase(index)}
                  className="hover:text-red-200 transition-colors"
                >
                  <X className="w-3 h-3" />
                </button>
              </span>
            ))}
          </div>
        </div>
      </Card>

      {/* Behavior Settings */}
      <Card
        bg="#ffffff"
        borderColor="black"
        shadowColor="#92cd41"
        className="p-4 sm:p-6"
      >
        <h3 className="font-minecraft font-black text-base uppercase tracking-wider text-gray-800 mb-4"> Behavior Settings</h3>
        
        <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
          {[
            { key: 'encouragesQuestions', label: ' Encourages questions' },
            { key: 'tellsStories', label: ' Tells stories' },
            { key: 'playsGames', label: ' Plays interactive games' },
            { key: 'usesSoundEffects', label: ' Uses sound effects' }
          ].map((item) => (
            <label key={item.key} className="flex items-center justify-between p-3 bg-[#fefcd0] border-2 border-black cursor-pointer hover:bg-white transition-colors">
              <span className="font-geo text-sm font-medium text-black">{item.label}</span>
              <input
                type="checkbox"
                checked={false}
                onChange={(e: ChangeEvent<HTMLInputElement>) => {
                  // For now, just handle usesSoundEffects
                  if (item.key === 'usesSoundEffects') {
                    updatePersonalityTraits({
                      speakingStyle: {
                        ...toyConfig.personalityTraits.speakingStyle,
                        usesSoundEffects: e.target.checked,
                      },
                    });
                  }
                  // TODO: Add behavior object support
                }}
                className="pixel-checkbox"
              />
            </label>
          ))}
        </div>
      </Card>
    </div>
  );
}
</file>

<file path="src/components/dashboard/steps/ReviewStep.tsx">
'use client';

import { useToyWizardStore, type WizardStep } from '@/stores/toyWizardStore';
import { Button, Card } from '@pommai/ui';
import { 
  Check, 
  Edit2, 
  Shield, 
  Volume2, 
  Brain,
  Sparkles,
  AlertCircle
} from 'lucide-react';

export function ReviewStep() {
  const { toyConfig, setCurrentStep, isCreating } = useToyWizardStore();

  const editSection = (step: WizardStep) => {
    setCurrentStep(step);
  };

  const getToyTypeIcon = () => {
    const icons: Record<string, string> = {
      teddy: '',
      bunny: '',
      cat: '',
      dog: '',
      bird: '',
      fish: '',
      robot: '',
      magical: '',
    };
    return icons[toyConfig.type] || '';
  };

  return (
    <div className="space-y-6">
      <div className="text-center sm:text-left">
        <h2 className="font-minecraft text-base sm:text-lg lg:text-xl font-black mb-2 uppercase tracking-wider text-gray-800"
          style={{
            textShadow: '2px 2px 0 #c381b5'
          }}
        >
           Review Your AI Toy
        </h2>
        <p className="font-geo font-medium text-gray-700 tracking-wide">
          Take a moment to review {toyConfig.name}&apos;s configuration before creating your AI companion.
        </p>
      </div>

      {/* Quick Summary */}
      <Card
        bg="#fefcd0"
        borderColor="black"
        shadowColor="#c381b5"
        className="p-4 sm:p-6"
      >
        <div className="flex items-start gap-4">
          <div className="text-4xl">{getToyTypeIcon()}</div>
          <div className="flex-1">
            <h3 className="retro-h3 text-xl text-black mb-2">{toyConfig.name}</h3>
            <p className="font-bold text-gray-700 uppercase tracking-wide mb-3">
              {toyConfig.type.charAt(0).toUpperCase() + toyConfig.type.slice(1)}
            </p>
            <div className="flex flex-wrap gap-2">
              {toyConfig.isForKids && (
                <span className="px-2 py-1 text-xs font-black uppercase tracking-wider border-2 border-black bg-[#92cd41] text-white flex items-center gap-1">
                  <Shield className="w-3 h-3" />
                  Guardian Mode
                </span>
              )}
              {toyConfig.ageGroup && (
                <span className="px-2 py-1 text-xs font-black uppercase tracking-wider border-2 border-black bg-[#f7931e] text-white">
                  Ages {toyConfig.ageGroup}
                </span>
              )}
              {toyConfig.isPublic && (
                <span className="px-2 py-1 text-xs font-black uppercase tracking-wider border-2 border-black bg-[#c381b5] text-white">
                  Public
                </span>
              )}
              {toyConfig.tags.map((tag, index) => (
                <span key={index} className="px-2 py-1 text-xs font-black uppercase tracking-wider border border-black bg-white text-black">
                  {tag}
                </span>
              ))}
            </div>
          </div>
        </div>
      </Card>

      {/* Detailed Review Cards */}
      <div className="space-y-4">
        {/* Personality */}
        <Card
          bg="#ffffff"
          borderColor="black"
          shadowColor="#c381b5"
          className="p-4 sm:p-6"
        >
          <div className="flex justify-between items-start mb-4">
            <div className="flex items-center gap-2">
              <Brain className="w-5 h-5" />
              <h3 className="retro-h3 text-lg text-black">Personality Configuration</h3>
              <Check className="w-4 h-4 text-green-600" />
            </div>
            <Button
              bg="#f0f0f0"
              textColor="black"
              borderColor="black"
              shadow="#d0d0d0"
              onClick={() => editSection('personality')}
              className="py-1 px-3 font-bold uppercase tracking-wider hover-lift"
            >
              <Edit2 className="w-4 h-4" />
            </Button>
          </div>
          
          <div className="space-y-3">
            <div>
              <p className="text-sm font-black uppercase tracking-wider text-black">Personality Traits</p>
              <div className="flex gap-2 mt-1">
                {toyConfig.personalityTraits.traits.map((trait, index) => (
                  <span key={index} className="px-2 py-1 text-xs font-black uppercase tracking-wider border border-black bg-[#fefcd0] text-black">
                    {trait}
                  </span>
                ))}
              </div>
            </div>
            
            <div>
              <p className="text-sm font-black uppercase tracking-wider text-black">Description</p>
              <p className="text-sm font-bold text-gray-700 mt-1">{toyConfig.personalityPrompt}</p>
            </div>

            <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
              <div>
                <p className="text-sm font-black uppercase tracking-wider text-black">Speaking Style</p>
                <p className="text-sm font-bold text-gray-700">
                  {toyConfig.personalityTraits.speakingStyle.vocabulary} vocabulary, 
                  {' ' + toyConfig.personalityTraits.speakingStyle.sentenceLength} sentences
                </p>
              </div>
              <div>
                <p className="text-sm font-black uppercase tracking-wider text-black">Behavior</p>
                <p className="text-sm font-bold text-gray-700">
                  Educational: {toyConfig.personalityTraits.behavior.educationalFocus}/10,
                  Imagination: {toyConfig.personalityTraits.behavior.imaginationLevel}/10
                </p>
              </div>
            </div>
          </div>
        </Card>

        {/* Voice */}
        <Card
          bg="#ffffff"
          borderColor="black"
          shadowColor="#f7931e"
          className="p-4 sm:p-6"
        >
          <div className="flex justify-between items-center">
            <div className="flex items-center gap-2">
              <Volume2 className="w-5 h-5" />
              <h3 className="retro-h3 text-lg text-black">Voice Selection</h3>
              <Check className="w-4 h-4 text-green-600" />
            </div>
            <Button
              bg="#f0f0f0"
              textColor="black"
              borderColor="black"
              shadow="#d0d0d0"
              onClick={() => editSection('voice')}
              className="py-1 px-3 font-bold uppercase tracking-wider hover-lift"
            >
              <Edit2 className="w-4 h-4" />
            </Button>
          </div>
          <div className="mt-3">
            <p className="text-sm font-black uppercase tracking-wider text-black">Selected Voice</p>
            <p className="text-sm font-bold text-gray-700 mt-1">{toyConfig.voiceName || 'Custom Voice'}</p>
          </div>
        </Card>

        {/* Knowledge Base */}
        {toyConfig.knowledgeBase && (
          <Card
            bg="#ffffff"
            borderColor="black"
            shadowColor="#92cd41"
            className="p-4 sm:p-6"
          >
            <div className="flex justify-between items-start mb-4">
              <div className="flex items-center gap-2">
                <Sparkles className="w-5 h-5" />
                <h3 className="retro-h3 text-lg text-black">Knowledge Base</h3>
                <Check className="w-4 h-4 text-green-600" />
              </div>
              <Button
                bg="#f0f0f0"
                textColor="black"
                borderColor="black"
                shadow="#d0d0d0"
                onClick={() => editSection('knowledge')}
                className="py-1 px-3 font-bold uppercase tracking-wider hover-lift"
              >
                <Edit2 className="w-4 h-4" />
              </Button>
            </div>
            
            <div className="space-y-3">
              {toyConfig.knowledgeBase.toyBackstory.origin && (
                <div>
                  <p className="text-sm font-black uppercase tracking-wider text-black">Origin Story</p>
                  <p className="text-sm font-bold text-gray-700 mt-1">{toyConfig.knowledgeBase.toyBackstory.origin}</p>
                </div>
              )}
              
              {toyConfig.knowledgeBase.toyBackstory.specialAbilities.length > 0 && (
                <div>
                  <p className="text-sm font-black uppercase tracking-wider text-black">Special Abilities</p>
                  <div className="flex flex-wrap gap-2 mt-1">
                    {toyConfig.knowledgeBase.toyBackstory.specialAbilities.map((ability, index) => (
                      <span key={index} className="px-2 py-1 text-xs font-black uppercase tracking-wider border border-black bg-[#c381b5] text-white">
                        {ability}
                      </span>
                    ))}
                  </div>
                </div>
              )}

              {toyConfig.knowledgeBase.customFacts && toyConfig.knowledgeBase.customFacts.length > 0 && (
                <div>
                  <p className="text-sm font-black uppercase tracking-wider text-black">Custom Knowledge</p>
                  <p className="text-sm font-bold text-gray-700 mt-1">
                    {toyConfig.knowledgeBase.customFacts.length} custom fact(s) added
                  </p>
                </div>
              )}
            </div>
          </Card>
        )}
      </div>

      {/* Safety Notice */}
      {isCreating && (
        <Card
          bg="#f7931e"
          borderColor="black"
          shadowColor="#d67c1a"
          className="p-4"
        >
          <div className="flex items-center gap-2">
            <AlertCircle className="w-4 h-4 text-white" />
            <p className="text-sm font-bold text-white uppercase tracking-wide">
               Creating your AI companion... This may take a few moments.
            </p>
          </div>
        </Card>
      )}
    </div>
  );
}
</file>

<file path="src/components/dashboard/steps/SafetyStep.tsx">
'use client';

import { useState, type ChangeEvent, type KeyboardEvent } from 'react';
import { useToyWizardStore } from '@/stores/toyWizardStore';
import { Input, Button, Card } from '@pommai/ui';
import { 
  Shield, 
  Lock, 
  AlertTriangle,
  Info,
  Plus,
  X,
  Eye,
  MessageSquare,
  Users,
  Globe,
  Heart
} from 'lucide-react';
import { motion } from 'framer-motion';

const SAFETY_LEVELS = [
  {
    id: 'strict',
    name: 'Strict',
    description: 'Maximum protection for young children',
    icon: Shield,
    features: [
      'No personal information sharing',
      'Pre-approved topics only',
      'Educational content focus',
      'No external references',
    ],
  },
  {
    id: 'moderate',
    name: 'Moderate',
    description: 'Balanced safety for school-age children',
    icon: Lock,
    features: [
      'Limited personal info sharing',
      'Most topics allowed',
      'Age-appropriate content',
      'Some creative freedom',
    ],
  },
  {
    id: 'relaxed',
    name: 'Relaxed',
    description: 'Basic safety for older children',
    icon: Eye,
    features: [
      'More conversational freedom',
      'Wider topic range',
      'Creative expression',
      'Educational guidance',
    ],
  },
];

const CONTENT_FILTER_CATEGORIES = [
  { id: 'language', name: 'Language & Profanity', icon: MessageSquare },
  { id: 'topics', name: 'Sensitive Topics', icon: AlertTriangle },
  { id: 'personal-info', name: 'Personal Information', icon: Users },
  { id: 'external-content', name: 'External Content', icon: Globe },
  { id: 'emotional', name: 'Emotional Topics', icon: Heart },
];

export function SafetyStep() {
  const { toyConfig, updateSafetySettings } = useToyWizardStore();
  const [newBlockedTopic, setNewBlockedTopic] = useState('');

  // Skip this step if not in kids mode
  if (!toyConfig.isForKids) {
    return (
      <div className="space-y-6">
      <div className="text-center py-12">
          <div className="w-20 h-20 border-4 border-black bg-[#f0f0f0] mx-auto mb-4 flex items-center justify-center">
            <Shield className="w-10 h-10 text-gray-400" />
          </div>
          <h2 className="font-minecraft text-base sm:text-lg lg:text-xl font-black mb-2 uppercase tracking-wider text-gray-800"
            style={{
              textShadow: '2px 2px 0 #c381b5'
            }}
          >
             Safety Settings
          </h2>
          <p className="font-geo font-medium text-gray-700 max-w-md mx-auto">
            Guardian Mode safety settings are only available when creating toys for children. 
            {toyConfig.name} will have standard safety measures for general use.
          </p>
        </div>
      </div>
    );
  }

  const currentSettings = toyConfig.safetySettings || {
    safetyLevel: 'moderate',
    contentFilters: {
      enabledCategories: ['language', 'topics', 'personal-info'],
      customBlockedTopics: [],
    },
  };

  const handleSafetyLevelChange = (level: 'strict' | 'moderate' | 'relaxed') => {
    updateSafetySettings({ safetyLevel: level });
  };

  const toggleContentFilter = (categoryId: string) => {
    const enabled = [...currentSettings.contentFilters.enabledCategories];
    const index = enabled.indexOf(categoryId);
    
    if (index > -1) {
      enabled.splice(index, 1);
    } else {
      enabled.push(categoryId);
    }
    
    updateSafetySettings({
      contentFilters: {
        ...currentSettings.contentFilters,
        enabledCategories: enabled,
      },
    });
  };

  const addBlockedTopic = () => {
    if (newBlockedTopic.trim()) {
      const topics = [...currentSettings.contentFilters.customBlockedTopics, newBlockedTopic.trim()];
      updateSafetySettings({
        contentFilters: {
          ...currentSettings.contentFilters,
          customBlockedTopics: topics,
        },
      });
      setNewBlockedTopic('');
    }
  };

  const removeBlockedTopic = (index: number) => {
    const topics = [...currentSettings.contentFilters.customBlockedTopics];
    topics.splice(index, 1);
    updateSafetySettings({
      contentFilters: {
        ...currentSettings.contentFilters,
        customBlockedTopics: topics,
      },
    });
  };

  return (
    <div className="space-y-6">
      <div className="text-center sm:text-left">
        <h2 className="font-minecraft text-base sm:text-lg lg:text-xl font-black mb-2 uppercase tracking-wider text-gray-800"
          style={{
            textShadow: '2px 2px 0 #c381b5'
          }}
        >
           Configure Guardian Mode Safety
        </h2>
        <p className="font-geo font-medium text-gray-700">
          Set up safety features to ensure {toyConfig.name} provides a safe and age-appropriate experience.
        </p>
      </div>

      {/* Safety Level Selection */}
      <Card
        bg="#ffffff"
        borderColor="black"
        shadowColor="#c381b5"
        className="p-4 sm:p-6"
      >
        <h3 className="retro-h3 text-lg text-black mb-4"> Safety Level</h3>
        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
          {SAFETY_LEVELS.map((level) => (
            <motion.label
              key={level.id}
              whileHover={{ scale: 1.02 }}
              whileTap={{ scale: 0.98 }}
              htmlFor={`safety-${level.id}`}
              className={`
                relative p-4 border-[5px] cursor-pointer transition-all hover-lift
                ${ currentSettings.safetyLevel === level.id 
                  ? 'border-black bg-[#c381b5] text-white' 
                  : 'border-black bg-white text-black hover:bg-[#fefcd0]'
                }
              `}
              style={{
                borderImageSlice: 3,
                borderImageWidth: 2,
                borderImageRepeat: 'stretch',
                borderImageOutset: 2,
                boxShadow: currentSettings.safetyLevel === level.id
                  ? '2px 2px 0 2px #8b5fa3, -2px -2px 0 2px #c381b5'
                  : '2px 2px 0 2px #e0e0e0, -2px -2px 0 2px #ffffff',
              }}
            >
              <input
                id={`safety-${level.id}`}
                type="radio"
                name="safetyLevel"
                value={level.id}
                checked={currentSettings.safetyLevel === level.id}
                onChange={(e: ChangeEvent<HTMLInputElement>) => handleSafetyLevelChange(e.target.value as 'strict' | 'moderate' | 'relaxed')}
                className="sr-only"
              />
              <div className="space-y-3">
                <div className="flex items-center gap-3">
                  <div className={`w-10 h-10 border-2 border-black flex items-center justify-center ${
                    currentSettings.safetyLevel === level.id ? 'bg-white text-[#c381b5]' : 'bg-[#fefcd0]'
                  }`}>
                    <level.icon className="w-5 h-5" />
                  </div>
                  <div>
                    <h4 className="font-black text-base uppercase tracking-wider">{level.name}</h4>
                    <p className="text-xs font-bold opacity-80 uppercase tracking-wide">{level.description}</p>
                  </div>
                </div>
                <ul className="space-y-1 text-xs font-bold">
                  {level.features.map((feature, index) => (
                    <li key={index} className="flex items-center gap-2 uppercase tracking-wide">
                      <span className="text-[#92cd41]"></span>
                      {feature}
                    </li>
                  ))}
                </ul>
              </div>
            </motion.label>
          ))}
        </div>
      </Card>

      {/* Content Filters */}
      <Card
        bg="#fefcd0"
        borderColor="black"
        shadowColor="#92cd41"
        className="p-4 sm:p-6"
      >
        <h3 className="retro-h3 text-lg text-black mb-4"> Content Filters</h3>
        <p className="text-sm font-bold text-gray-700 mb-4 uppercase tracking-wide">Choose which types of content to filter</p>
        
        <div className="space-y-3">
          {CONTENT_FILTER_CATEGORIES.map((category) => (
            <label
              key={category.id}
              className="flex items-center justify-between p-3 border-2 border-black bg-white cursor-pointer hover:bg-[#fefcd0] transition-colors"
            >
              <div className="flex items-center gap-3">
                <category.icon className="w-5 h-5 text-[#c381b5]" />
                <span className="font-bold text-black uppercase tracking-wider text-sm">{category.name}</span>
              </div>
              <input
                type="checkbox"
                checked={currentSettings.contentFilters.enabledCategories.includes(category.id)}
                onChange={() => toggleContentFilter(category.id)}
                className="pixel-checkbox"
              />
            </label>
          ))}
        </div>
      </Card>

      {/* Custom Blocked Topics */}
      <Card
        bg="#ffffff"
        borderColor="black"
        shadowColor="#f7931e"
        className="p-4 sm:p-6"
      >
        <h3 className="font-black text-lg uppercase tracking-wider text-black mb-4"> Custom Blocked Topics</h3>
        <p className="text-sm font-bold text-gray-700 mb-4 uppercase tracking-wide">Add specific topics you want {toyConfig.name} to avoid</p>
        
        <div className="space-y-4">
          <div className="flex gap-2">
            <Input
              value={newBlockedTopic}
              onChange={(e: ChangeEvent<HTMLInputElement>) => setNewBlockedTopic(e.target.value)}
              placeholder="Add a topic to block..."
              onKeyPress={(e: KeyboardEvent<HTMLInputElement>) => e.key === 'Enter' && addBlockedTopic()}
              bg="#ffffff"
              borderColor="black"
              className="font-bold flex-1"
            />
            <Button
              bg={newBlockedTopic.trim() ? "#ff6b6b" : "#f0f0f0"}
              textColor={newBlockedTopic.trim() ? "white" : "#999"}
              borderColor="black"
              shadow={newBlockedTopic.trim() ? "#e84545" : "#d0d0d0"}
              onClick={addBlockedTopic}
              disabled={!newBlockedTopic.trim()}
              className={`py-2 px-3 font-bold ${newBlockedTopic.trim() ? 'hover-lift' : 'cursor-not-allowed'}`}
            >
              <Plus className="w-4 h-4" />
            </Button>
          </div>
          
          {currentSettings.contentFilters.customBlockedTopics.length > 0 && (
            <div className="flex flex-wrap gap-2">
              {currentSettings.contentFilters.customBlockedTopics.map((topic, index) => (
                <span 
                  key={index} 
                  className="px-2 py-1 text-xs font-black uppercase tracking-wider border-2 border-black bg-[#ff6b6b] text-white flex items-center gap-2"
                >
                  {topic}
                  <button
                    onClick={() => removeBlockedTopic(index)}
                    className="hover:text-red-200 transition-colors"
                  >
                    <X className="w-3 h-3" />
                  </button>
                </span>
              ))}
            </div>
          )}
        </div>
      </Card>

      {/* Information Box */}
      <Card
        bg="#92cd41"
        borderColor="black"
        shadowColor="#76a83a"
        className="p-4"
      >
        <div className="flex items-start gap-3">
          <Info className="w-5 h-5 text-white mt-0.5 flex-shrink-0" />
          <div className="text-sm font-bold text-white">
            <p className="font-black mb-1 uppercase tracking-wider"> Guardian Mode Active</p>
            <p className="uppercase tracking-wide">
              These safety settings will be enforced for all interactions with {toyConfig.name}. 
              Parents can adjust these settings anytime through the parental controls dashboard.
            </p>
          </div>
        </div>
      </Card>

      {/* Age-based Recommendation */}
      {toyConfig.ageGroup && (
        <Card
          bg="#f7931e"
          borderColor="black"
          shadowColor="#d67c1a"
          className="p-4"
        >
          <p className="text-sm font-bold text-white uppercase tracking-wide">
            <strong> Recommended for {toyConfig.ageGroup}:</strong> Based on the selected age group, 
            we&apos;ve pre-configured the safety level to &quot;{currentSettings.safetyLevel}&quot;. 
            You can adjust this if needed.
          </p>
        </Card>
      )}
    </div>
  );
}
</file>

<file path="src/components/dashboard/steps/ToyProfileStep.tsx">
'use client';

import { useState, useEffect, type ChangeEvent } from 'react';
import { useToyWizardStore } from '@/stores/toyWizardStore';
import { Input, TextArea, Card } from '@pommai/ui';
import { 
  Baby,
  Rabbit, 
  Cat, 
  Dog, 
  Bird, 
  Fish,
  Bot,
  Sparkles,
  HelpCircle
} from 'lucide-react';

const TOY_TYPES = [
  { id: 'teddy', name: 'Teddy Bear', icon: Baby, description: 'Classic cuddly companion' },
  { id: 'bunny', name: 'Bunny', icon: Rabbit, description: 'Hoppy and playful friend' },
  { id: 'cat', name: 'Cat', icon: Cat, description: 'Curious and independent' },
  { id: 'dog', name: 'Dog', icon: Dog, description: 'Loyal and energetic buddy' },
  { id: 'bird', name: 'Bird', icon: Bird, description: 'Chirpy and adventurous' },
  { id: 'fish', name: 'Fish', icon: Fish, description: 'Calm and mysterious' },
  { id: 'robot', name: 'Robot', icon: Bot, description: 'Futuristic tech companion' },
  { id: 'magical', name: 'Magical Creature', icon: Sparkles, description: 'Fantasy and imagination' },
];

export function ToyProfileStep() {
  const { toyConfig, updateToyConfig, setError, clearError, errors } = useToyWizardStore();
  const [tags, setTags] = useState<string>(toyConfig.tags.join(', '));

  const handleNameChange = (value: string) => {
    updateToyConfig('name', value);
    if (value.trim()) {
      clearError('name');
    } else {
      setError('name', 'Toy name is required');
    }
  };

  const handleTypeChange = (value: string) => {
    updateToyConfig('type', value);
    clearError('type');
  };

  const handleTagsChange = (value: string) => {
    setTags(value);
    const tagArray = value
      .split(',')
      .map(tag => tag.trim())
      .filter(tag => tag.length > 0);
    updateToyConfig('tags', tagArray);
  };

  useEffect(() => {
    // Validate on mount
    if (!toyConfig.name) {
      setError('name', 'Toy name is required');
    }
    if (!toyConfig.type) {
      setError('type', 'Please select a toy type');
    }
  }, []);

  return (
    <div className="space-y-6 step-component">
      <div className="text-center sm:text-left">
        <h2 className="font-minecraft text-base sm:text-lg lg:text-xl font-black mb-2 uppercase tracking-wider text-gray-800"
          style={{
            textShadow: '2px 2px 0 #c381b5'
          }}
        >
           Let&apos;s start with the basics
        </h2>
        <p className="font-geo font-medium text-gray-600 tracking-wide">
          Give your AI toy a name and choose what type of companion it will be.
        </p>
      </div>

      {/* Toy Name */}
      <div className="space-y-3">
        <label className="block text-sm font-geo font-semibold uppercase tracking-wider text-gray-700">
          Toy Name
          <span className="text-red-500 ml-1">*</span>
        </label>
        <Input
          value={toyConfig.name}
          onChange={(e: ChangeEvent<HTMLInputElement>) => handleNameChange(e.target.value)}
          placeholder="e.g., Buddy, Luna, Max"
          bg={errors.name ? "#ffe4e1" : "#ffffff"}
          borderColor={errors.name ? "red" : "black"}
          className={`font-geo font-medium ${errors.name ? 'animate-pulse' : ''}`}
        />
        {errors.name && (
          <p className="font-geo text-sm text-red-500 font-semibold uppercase tracking-wider">{errors.name}</p>
        )}
        <p className="font-geo text-sm font-medium text-gray-600 tracking-wide">
          Choose a friendly name that&apos;s easy to remember and pronounce
        </p>
      </div>

      {/* Toy Type */}
      <div className="space-y-3">
        <label className="font-geo block text-sm font-semibold uppercase tracking-wider text-black mb-2">
          Toy Type
          <span className="text-red-500 ml-1">*</span>
        </label>
        <div className="grid grid-cols-2 md:grid-cols-4 gap-3 sm:gap-4">
          {TOY_TYPES.map((type) => (
            <label
              key={type.id}
              className={`
                relative flex flex-col items-center p-3 sm:p-4 border-[5px] cursor-pointer
                transition-all hover-lift font-black uppercase tracking-wider text-center
                ${toyConfig.type === type.id 
                  ? 'border-black bg-[#c381b5] text-white' 
                  : 'border-black bg-white text-black hover:bg-[#fefcd0]'
                }
              `}
              style={{
                borderImageSlice: 3,
                borderImageWidth: 2,
                borderImageRepeat: 'stretch',
                borderImageOutset: 2,
                boxShadow: toyConfig.type === type.id
                  ? '2px 2px 0 2px #8b5fa3, -2px -2px 0 2px #c381b5'
                  : '2px 2px 0 2px #e0e0e0, -2px -2px 0 2px #ffffff',
              }}
            >
              <input
                type="radio"
                name="toyType"
                value={type.id}
                checked={toyConfig.type === type.id}
                onChange={(e: ChangeEvent<HTMLInputElement>) => handleTypeChange(e.target.value)}
                className="sr-only"
              />
              <type.icon className={`w-6 h-6 sm:w-8 sm:h-8 mb-2 ${
                toyConfig.type === type.id ? 'text-white animate-pulse' : 'text-[#c381b5]'
              }`} />
              <span className="font-minecraft text-xs sm:text-sm font-black mb-1">
                {type.name}
              </span>
              <span className="font-geo text-xs font-medium opacity-80">
                {type.description}
              </span>
            </label>
          ))}
        </div>
        {errors.type && (
          <p className="font-geo text-sm text-red-500 font-semibold uppercase tracking-wider">{errors.type}</p>
        )}
      </div>

      {/* Tags */}
      <div className="space-y-3">
        <div className="flex items-center gap-2">
          <label className="font-geo text-sm font-semibold uppercase tracking-wider text-black">Tags</label>
          <div className="group relative">
            <HelpCircle className="w-4 h-4 text-gray-400 cursor-help" />
            <div className="invisible group-hover:visible absolute bottom-6 left-0 bg-black text-white text-xs p-2 rounded whitespace-nowrap z-10">
              Add tags to help categorize your toy (separate with commas)
            </div>
          </div>
        </div>
        <Input
          value={tags}
          onChange={(e: ChangeEvent<HTMLInputElement>) => handleTagsChange(e.target.value)}
          placeholder="e.g., educational, storyteller, friend"
          bg="#ffffff"
          borderColor="black"
          className="font-geo font-medium"
        />
        {toyConfig.tags.length > 0 && (
          <div className="flex flex-wrap gap-2 mt-3">
            {toyConfig.tags.map((tag, index) => (
              <span 
                key={index} 
                className="font-minecraft px-2 py-1 text-xs font-black uppercase tracking-wider border-2 border-black bg-[#92cd41] text-white"
              >
                {tag}
              </span>
            ))}
          </div>
        )}
      </div>

      {/* Public/Private Toggle */}
      <Card
        bg="#fefcd0"
        borderColor="black"
        shadowColor="#c381b5"
        className="p-4 sm:p-6"
      >
        <div className="flex items-center justify-between">
          <div className="space-y-1">
            <label className="font-minecraft text-base font-black uppercase tracking-wider text-black cursor-pointer">
               Make this toy public
            </label>
            <p className="font-geo text-sm font-semibold text-gray-700 uppercase tracking-wide">
              Allow other users to discover and use your toy design
            </p>
          </div>
          <label className="cursor-pointer">
            <input
              type="checkbox"
              checked={toyConfig.isPublic}
              onChange={(e: ChangeEvent<HTMLInputElement>) => updateToyConfig('isPublic', e.target.checked)}
              className="pixel-checkbox"
            />
          </label>
        </div>
      </Card>
    </div>
  );
}
</file>

<file path="src/components/dashboard/steps/VoiceStep.tsx">
'use client';

import { useEffect, useState } from 'react';
import { useToyWizardStore } from '@/stores/toyWizardStore';
import { VoiceGallery } from '@/components/voice/VoiceGallery';
import { VoicePreview } from '@/components/voice/VoicePreview';
import { VoiceUploader } from '@/components/voice/VoiceUploader';
import { Button, Card, Popup } from '@pommai/ui';
import { Volume2, Upload } from 'lucide-react';
import { useAction } from 'convex/react';
import { api } from '../../../../convex/_generated/api';

/**
 * VoiceStep
 *
 * Lets users pick or upload a voice.
 * - Primary headings use font-minecraft (pixel) with compact sizes.
 * - Body and helper text use font-geo for readability.
 */
export function VoiceStep() {
  const { toyConfig, updateToyConfig } = useToyWizardStore();
  const [selectedVoice, setSelectedVoice] = useState<{ _id?: string; externalVoiceId?: string; name: string } | null>(null);
  const [showUploader, setShowUploader] = useState(false);
  const [activeTab, setActiveTab] = useState<'preset' | 'custom'>('preset');

  // Ensure default voices are available for selection
  const syncDefaultVoices = useAction(api.aiServices.syncDefaultVoices);
  const hasSeededRef = (typeof window !== 'undefined') 
    ? ((window as unknown as { __pommaiSeededVoicesRef?: { value: boolean } }).__pommaiSeededVoicesRef ??= { value: false }) 
    : { value: false };
  useEffect(() => {
    if (hasSeededRef.value) return;
    hasSeededRef.value = true;
    (async () => {
      try { 
        await syncDefaultVoices({}); 
      } catch (error) { 
        console.error('Failed to sync default voices:', error);
      }
    })();
  }, [syncDefaultVoices, hasSeededRef]);

  const handleSelectVoice = (voice: { externalVoiceId?: string; name: string; _id?: string }) => {
    setSelectedVoice(voice);
    if (voice.externalVoiceId) {
      updateToyConfig('voiceId', voice.externalVoiceId);
    }
    updateToyConfig('voiceName', voice.name);
  };

  const handleVoiceUploaded = (voiceId: string) => {
    // In a real app, you'd fetch the voice details here
    updateToyConfig('voiceId', voiceId);
    setShowUploader(false);
  };

  return (
    <div className="space-y-6 step-component">
      <div className="text-center sm:text-left">
        <h2 className="font-minecraft text-base sm:text-lg font-black mb-3 uppercase tracking-wider text-gray-800"
          style={{
            textShadow: '2px 2px 0 #c381b5'
          }}
>
           Choose {toyConfig.name}&apos;s Voice
        </h2>
        <p className="font-geo text-sm font-medium text-gray-600 tracking-wide leading-relaxed">
          Select a voice that matches {toyConfig.name}&apos;s personality, or create your own custom voice.
        </p>
      </div>

      {/* Voice Selection (no Tabs) */}
      <Card
        bg="#ffffff"
        borderColor="black"
        shadowColor="#c381b5"
        className="p-[var(--spacing-lg)] sm:p-[var(--spacing-xl)]"
      >
        <div className="space-y-4">
          {/* Segmented control + Upload */}
          <div className="flex items-center justify-between gap-3 flex-wrap">
            <div className="flex gap-2">
              <Button
                bg={activeTab === 'preset' ? '#c381b5' : '#f8f8f8'}
                textColor={activeTab === 'preset' ? 'white' : 'black'}
                borderColor="black"
                shadow={activeTab === 'preset' ? '#8b5fa3' : '#e0e0e0'}
                onClick={() => setActiveTab('preset')}
                className="py-2 px-3 font-minecraft font-black uppercase tracking-wider hover-lift text-xs sm:text-sm"
              >
                 Preset Voices
              </Button>
              <Button
                bg={activeTab === 'custom' ? '#c381b5' : '#f8f8f8'}
                textColor={activeTab === 'custom' ? 'white' : 'black'}
                borderColor="black"
                shadow={activeTab === 'custom' ? '#8b5fa3' : '#e0e0e0'}
                onClick={() => setActiveTab('custom')}
                className="py-2 px-3 font-minecraft font-black uppercase tracking-wider hover-lift text-xs sm:text-sm"
              >
                 Custom Voice
              </Button>
            </div>
            {activeTab === 'preset' && (
              <Button
                bg="#ffffff"
                textColor="black"
                borderColor="black"
                shadow="#e0e0e0"
                onClick={() => setShowUploader(true)}
                className="py-2 px-3 font-minecraft font-black uppercase tracking-wider hover-lift text-xs sm:text-sm"
              >
                <Upload className="w-3 h-3 mr-2" /> Upload Voice
              </Button>
            )}
          </div>

          {/* Content */}
          {activeTab === 'preset' && (
            <div className="space-y-4">
              {selectedVoice && (
                <Card
                  bg="#ffffff"
                  borderColor="black"
                  shadowColor="#c381b5"
                  className="p-[var(--spacing-lg)]"
                >
                  <h3 className="retro-h3 text-base text-gray-800 mb-3"> Selected Voice</h3>
                  <VoicePreview voice={selectedVoice} isForKids={toyConfig.isForKids} />
                </Card>
              )}

              <VoiceGallery
                selectedVoiceId={selectedVoice?._id}
                onSelectVoice={handleSelectVoice}
                isForKids={toyConfig.isForKids}
              />
            </div>
          )}

          {activeTab === 'custom' && (
            <div className="text-center py-[var(--spacing-xl)]">
              <div className="max-w-md mx-auto space-y-6">
                <div className="w-14 h-14 border-4 border-black bg-gradient-to-br from-[#c381b5] to-[#f7931e] mx-auto flex items-center justify-center">
                  <Volume2 className="w-7 h-7 text-white" />
                </div>
                
                <div>
                  <h3 className="retro-h3 text-base text-gray-800 mb-3">
                    Create a Custom Voice
                  </h3>
                  <p className="font-geo text-sm font-medium text-gray-600 leading-relaxed">
                    Record your own voice or upload an audio file to create a unique voice for {toyConfig.name}
                  </p>
                </div>

                <Button
                  bg="#92cd41"
                  textColor="white"
                  borderColor="black"
                  shadow="#76a83a"
                  onClick={() => setShowUploader(true)}
                  className="w-full py-3 px-6 font-minecraft font-black uppercase tracking-wider hover-lift"
                >
                  <Volume2 className="w-4 h-4 mr-2" />
                  Start Voice Creation
                </Button>

                <Card
                  bg="#f7931e"
                  borderColor="black"
                  shadowColor="#d67c1a"
                  className="p-4 text-left"
                >
                  <h4 className="font-minecraft font-black text-sm text-white mb-2 uppercase tracking-wider">
                     Voice Creation Tips:
                  </h4>
                  <ul className="font-geo text-xs font-medium text-white space-y-1 leading-relaxed">
                    <li> Record in a quiet environment</li>
                    <li> Speak clearly and at a moderate pace</li>
                    <li> Record 3-5 minutes of diverse content</li>
                    <li> Use the provided script for best results</li>
                  </ul>
                </Card>
              </div>
            </div>
          )}
        </div>
      </Card>

      {/* Voice Upload Popup */}
      {showUploader && (
        <Popup
          isOpen={showUploader}
          onClose={() => setShowUploader(false)}
          title=" Upload Custom Voice"
          bg="#ffffff"
          borderColor="black"
          className="max-w-4xl max-h-[90vh] overflow-y-auto"
        >
          <VoiceUploader
            onComplete={handleVoiceUploaded}
            onCancel={() => setShowUploader(false)}
          />
        </Popup>
      )}
    </div>
  );
}
</file>

<file path="src/components/dashboard/steps/WelcomeStep.tsx">
'use client';

import { motion } from 'framer-motion';
import { Sparkles, Heart, Shield, Brain } from 'lucide-react';
import { Card } from '@pommai/ui';

/**
 * WelcomeStep
 *
 * Introduces the wizard. Typography rules:
 * - Primary title uses font-minecraft (pixel) small and responsive.
 * - All supporting text uses font-geo.
 */
export function WelcomeStep() {
  const features = [
    {
      icon: Heart,
      title: 'Personalized Companion',
      description: 'Create a unique AI friend with custom personality traits',
    },
    {
      icon: Brain,
      title: 'Smart & Adaptive',
      description: 'Your toy learns and grows with every interaction',
    },
    {
      icon: Shield,
      title: 'Safe for Kids',
      description: 'Built-in safety features and content filtering',
    },
    {
      icon: Sparkles,
      title: 'Magical Experience',
      description: 'Bring toys to life with advanced AI technology',
    },
  ];

  return (
    <div className="space-y-6 step-component">
      <div className="text-center space-y-4">
        <motion.div
          initial={{ scale: 0 }}
          animate={{ scale: 1 }}
          transition={{ type: 'spring', duration: 0.5 }}
        >
          <div className="w-20 h-20 mx-auto flex items-center justify-center mb-4">
            <Sparkles className="w-16 h-16 text-[#c381b5] animate-pulse" />
          </div>
        </motion.div>
        
        <h2 className="font-minecraft text-base sm:text-lg font-black mb-4 uppercase tracking-wider text-gray-800"
          style={{
            textShadow: '2px 2px 0 #c381b5'
          }}
        >
           Welcome to AI Toy Creation!
        </h2>
        <p className="font-geo text-sm font-medium text-gray-600 max-w-2xl mx-auto leading-relaxed">
          Let&apos;s create a magical AI companion together! This wizard will guide you 
          through personalizing your toy&apos;s personality, voice, and capabilities.
        </p>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 gap-[var(--spacing-md)] sm:gap-[var(--spacing-lg)] mt-[var(--spacing-2xl)]">
        {features.map((feature, index) => (
          <motion.div
            key={index}
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: index * 0.1 }}
          >
            <Card
              bg="#ffffff"
              borderColor="black"
              shadowColor="#c381b5"
              className="p-[var(--spacing-lg)] sm:p-[var(--spacing-xl)] hover-lift transition-transform cursor-pointer group"
            >
              <div className="flex gap-4">
                <div className="flex-shrink-0">
                  <div className="w-12 h-12 bg-[#fefcd0] border-2 border-black flex items-center justify-center group-hover:animate-pulse">
                    <feature.icon className="w-6 h-6 text-[#c381b5]" />
                  </div>
                </div>
                <div>
                  <h3 className="retro-h3 text-base text-gray-800 mb-2">{feature.title}</h3>
                  <p className="font-geo text-sm font-medium text-gray-600 tracking-wide leading-relaxed">{feature.description}</p>
                </div>
              </div>
            </Card>
          </motion.div>
        ))}
      </div>

      <Card
        bg="#fefcd0"
        borderColor="black"
        shadowColor="#c381b5"
        className="p-[var(--spacing-lg)] sm:p-[var(--spacing-xl)] mt-[var(--spacing-xl)]"
      >
        <p className="font-geo text-sm font-medium text-gray-700">
          <strong className="font-minecraft uppercase tracking-wider"> Note:</strong> This process takes about 5-10 minutes. Your progress 
          is automatically saved, so you can return anytime to continue where you left off.
        </p>
      </Card>
    </div>
  );
}
</file>

<file path="src/components/dashboard/ToyControlsHeader.tsx">
'use client';

import type { ChangeEvent } from 'react';
import { Button, Input } from '@pommai/ui';
import { DropdownMenu, DropdownMenuTrigger, DropdownMenuContent } from '@/components/ui/dropdown-menu';
import { 
  Grid3X3,
  List,
  Plus,
  Filter
} from 'lucide-react';

interface ToyControlsHeaderProps {
  searchQuery: string;
  onSearchChange: (query: string) => void;
  filterStatus: 'all' | 'active' | 'paused' | 'archived';
  onFilterChange: (status: 'all' | 'active' | 'paused' | 'archived') => void;
  viewMode: 'grid' | 'list';
  onViewModeChange: (mode: 'grid' | 'list') => void;
  onCreateToy?: () => void;
}

export function ToyControlsHeader({ 
  searchQuery, 
  onSearchChange, 
  filterStatus, 
  onFilterChange,
  viewMode,
  onViewModeChange,
  onCreateToy 
}: ToyControlsHeaderProps) {
  return (
    <div className="flex flex-col sm:flex-row gap-4 justify-between items-start sm:items-center">
      <div className="flex-1 max-w-md">
        <Input
          placeholder=" Search toys..."
          value={searchQuery}
          onChange={(e: ChangeEvent<HTMLInputElement>) => onSearchChange(e.target.value)}
          bg="#ffffff"
          borderColor="black"
          className="font-geo font-medium"
        />
      </div>
      
      <div className="flex items-center gap-3">
        <DropdownMenu>
          <DropdownMenuTrigger asChild>
            <Button
              bg="#ffffff"
              textColor="black"
              borderColor="black"
              shadow="#e0e0e0"
              className="py-2 px-4 font-minecraft font-black uppercase tracking-wider hover-lift text-xs sm:text-sm"
            >
              <span className="flex items-center">
                <Filter className="w-4 h-4 mr-2" />
                {filterStatus === 'all' ? 'All' : filterStatus}
              </span>
            </Button>
          </DropdownMenuTrigger>
          <DropdownMenuContent>
            <button 
              onClick={() => onFilterChange('all')}
              className="w-full text-left px-3 py-2 hover:bg-gray-100 font-minecraft font-black uppercase tracking-wider text-xs"
            >
              All
            </button>
            <button 
              onClick={() => onFilterChange('active')}
              className="w-full text-left px-3 py-2 hover:bg-gray-100 font-minecraft font-black uppercase tracking-wider text-xs"
            >
              Active
            </button>
            <button 
              onClick={() => onFilterChange('paused')}
              className="w-full text-left px-3 py-2 hover:bg-gray-100 font-minecraft font-black uppercase tracking-wider text-xs"
            >
              Paused
            </button>
            <button 
              onClick={() => onFilterChange('archived')}
              className="w-full text-left px-3 py-2 hover:bg-gray-100 font-minecraft font-black uppercase tracking-wider text-xs"
            >
              Archived
            </button>
          </DropdownMenuContent>
        </DropdownMenu>

        <div className="flex gap-1">
          <Button
            bg={viewMode === 'grid' ? "#c381b5" : "#ffffff"}
            textColor={viewMode === 'grid' ? "white" : "black"}
            borderColor="black"
            shadow={viewMode === 'grid' ? "#8b5fa3" : "#e0e0e0"}
            onClick={() => onViewModeChange('grid')}
            className="py-2 px-3 font-minecraft font-black hover-lift text-xs"
          >
            <Grid3X3 className="w-4 h-4" />
          </Button>
          <Button
            bg={viewMode === 'list' ? "#c381b5" : "#ffffff"}
            textColor={viewMode === 'list' ? "white" : "black"}
            borderColor="black"
            shadow={viewMode === 'list' ? "#8b5fa3" : "#e0e0e0"}
            onClick={() => onViewModeChange('list')}
            className="py-2 px-3 font-minecraft font-black hover-lift text-xs"
          >
            <List className="w-4 h-4" />
          </Button>
        </div>

        <Button 
          bg="#92cd41"
          textColor="white"
          borderColor="black"
          shadow="#76a83a"
          onClick={onCreateToy} 
          className="py-2 px-4 font-minecraft font-black uppercase tracking-wider hover-lift text-xs sm:text-sm"
        >
          <span className="flex items-center gap-2">
            <Plus className="w-4 h-4" />
            <span className="hidden sm:inline">New Toy</span>
          </span>
        </Button>
      </div>
    </div>
  );
}
</file>

<file path="src/components/dashboard/ToyDialogs.tsx">
'use client';

import type { ChangeEvent } from 'react';
import { Button, Input, Popup } from '@pommai/ui';

interface ToyDialogsProps {
  // Delete dialog
  showDeleteDialog: boolean;
  onDeleteConfirm: () => void;
  onDeleteCancel: () => void;
  
  // Duplicate dialog
  showDuplicateDialog: boolean;
  duplicateName: string;
  onDuplicateNameChange: (name: string) => void;
  onDuplicateConfirm: () => void;
  onDuplicateCancel: () => void;
}

export function ToyDialogs({ 
  showDeleteDialog,
  onDeleteConfirm,
  onDeleteCancel,
  showDuplicateDialog,
  duplicateName,
  onDuplicateNameChange,
  onDuplicateConfirm,
  onDuplicateCancel
}: ToyDialogsProps) {
  return (
    <>
      {/* Delete Confirmation Popup */}
      {showDeleteDialog && (
        <Popup
          isOpen={showDeleteDialog}
          onClose={onDeleteCancel}
          title=" Delete Toy"
          bg="#ffffff"
          borderColor="black"
          className="max-w-md"
        >
          <div className="space-y-4">
            <p className="text-gray-700 font-bold">
              Are you sure you want to delete this toy? This action will archive the toy and it will no longer be accessible.
            </p>
            <div className="flex flex-col sm:flex-row gap-3 pt-4">
              <Button
                bg="#f0f0f0"
                textColor="black"
                borderColor="black"
                shadow="#d0d0d0"
                onClick={onDeleteCancel}
                className="flex-1 py-2 px-4 font-bold uppercase tracking-wider hover-lift"
              >
                Cancel
              </Button>
              <Button
                bg="#ff6b6b"
                textColor="white"
                borderColor="black"
                shadow="#e84545"
                onClick={onDeleteConfirm}
                className="flex-1 py-2 px-4 font-bold uppercase tracking-wider hover-lift"
              >
                Delete
              </Button>
            </div>
          </div>
        </Popup>
      )}

      {/* Duplicate Popup */}
      {showDuplicateDialog && (
        <Popup
          isOpen={showDuplicateDialog}
          onClose={onDuplicateCancel}
          title=" Duplicate Toy"
          bg="#ffffff"
          borderColor="black"
          className="max-w-md"
        >
          <div className="space-y-4">
            <p className="text-gray-700 font-bold mb-4">
              Create a copy of this toy with a new name.
            </p>
            <div className="space-y-2">
              <label className="block text-sm font-black uppercase tracking-wider text-black">
                New Toy Name
              </label>
              <Input
                value={duplicateName}
                onChange={(e: ChangeEvent<HTMLInputElement>) => onDuplicateNameChange(e.target.value)}
                placeholder="Enter toy name"
                bg="#ffffff"
                borderColor="black"
                className="font-bold"
              />
            </div>
            <div className="flex flex-col sm:flex-row gap-3 pt-4">
              <Button
                bg="#f0f0f0"
                textColor="black"
                borderColor="black"
                shadow="#d0d0d0"
                onClick={onDuplicateCancel}
                className="flex-1 py-2 px-4 font-bold uppercase tracking-wider hover-lift"
              >
                Cancel
              </Button>
              <Button
                bg={duplicateName.trim() ? "#92cd41" : "#f0f0f0"}
                textColor={duplicateName.trim() ? "white" : "#999"}
                borderColor="black"
                shadow={duplicateName.trim() ? "#76a83a" : "#d0d0d0"}
                onClick={onDuplicateConfirm}
                disabled={!duplicateName.trim()}
                className={`flex-1 py-2 px-4 font-bold uppercase tracking-wider ${
                  duplicateName.trim() ? 'hover-lift' : 'cursor-not-allowed'
                }`}
              >
                Create Copy
              </Button>
            </div>
          </div>
        </Popup>
      )}
    </>
  );
}
</file>

<file path="src/components/dashboard/ToyEmptyState.tsx">
'use client';

import { Button } from '@pommai/ui';
import { Plus } from 'lucide-react';

interface ToyEmptyStateProps {
  onCreateToy?: () => void;
}

export function ToyEmptyState({ onCreateToy }: ToyEmptyStateProps) {
  return (
    <div className="text-center py-12">
      <div className="inline-block relative mb-8">
        <span className="text-9xl animate-bounce inline-block"></span>
        <span className="absolute -top-2 -right-2 text-4xl animate-spin" style={{ animationDuration: '3s' }}></span>
      </div>
      <h3 className="text-3xl font-black mb-4 uppercase tracking-wider text-black"
        style={{
          textShadow: '2px 2px 0 #c381b5'
        }}
      >
        No Toys Yet!
      </h3>
      <p className="text-xl font-bold text-gray-700 mb-8 uppercase tracking-wide">Let&apos;s create your first AI companion</p>
      <Button 
        bg="#92cd41"
        textColor="white"
        borderColor="black"
        shadow="#76a83a"
        onClick={onCreateToy}
        className="py-3 px-6 font-black uppercase tracking-wider hover-lift text-lg"
      >
        <span className="flex items-center gap-2">
          <Plus className="w-5 h-5" />
          Create My First Toy
        </span>
      </Button>
    </div>
  );
}
</file>

<file path="src/components/dashboard/ToyGridItem.tsx">
'use client';

import { formatDistanceToNow } from 'date-fns';
import { Card, Button } from '@pommai/ui';
import { DropdownMenu, DropdownMenuTrigger, DropdownMenuContent } from '@/components/ui/dropdown-menu';
import { 
  MoreVertical, 
  Play, 
  Pause, 
  Edit, 
  Copy, 
  Trash, 
  MessageSquare,
  Wifi,
  WifiOff,
  Shield
} from 'lucide-react';
import { motion } from 'framer-motion';
import { Id } from '../../../convex/_generated/dataModel';

interface Toy {
  _id: string;
  name: string;
  type: string;
  status: 'active' | 'paused' | 'archived';
  isForKids: boolean;
  lastActiveAt?: string;
  assignedDevices?: unknown[];
}

interface ToyGridItemProps {
  toy: Toy;
  onChat: (toyId: string) => void;
  onEdit: (toyId: string) => void;
  onStatusToggle: (toyId: Id<"toys">, currentStatus: string) => void;
  onDuplicate: (toyId: string, name: string) => void;
  onDelete: (toyId: string) => void;
}

const getToyAvatar = (type: string) => {
  const avatarMap: Record<string, string> = {
    teddy: '',
    bunny: '',
    cat: '',
    dog: '',
    bird: '',
    fish: '',
    robot: '',
    magical: '',
  };
  return avatarMap[type] || '';
};

export function ToyGridItem({ 
  toy, 
  onChat, 
  onEdit, 
  onStatusToggle, 
  onDuplicate, 
  onDelete 
}: ToyGridItemProps) {
  return (
    <motion.div
      layout
      initial={{ opacity: 0, scale: 0.9 }}
      animate={{ opacity: 1, scale: 1 }}
      exit={{ opacity: 0, scale: 0.9 }}
      transition={{ duration: 0.2 }}
    >
      <Card 
        bg="#ffffff" 
        borderColor="black" 
        shadowColor="#c381b5"
        className="overflow-hidden hover-lift transition-transform cursor-pointer group"
      >
        <div className="p-4 sm:p-6">
          <div className="flex items-start justify-between mb-4">
            <div className="flex items-center gap-3">
              <div className="text-4xl sm:text-5xl group-hover:animate-pulse">
                {getToyAvatar(toy.type)}
              </div>
              <div>
                <h3 className="font-minecraft font-black text-base uppercase tracking-wider text-gray-800">
                  {toy.name}
                </h3>
                <div className="flex items-center gap-2 mt-1">
                  <span className={`px-2 py-1 text-xs font-minecraft font-black uppercase tracking-wider border-2 border-black ${
                    toy.status === 'active' 
                      ? 'bg-[#92cd41] text-white' 
                      : 'bg-[#f0f0f0] text-black'
                  }`}>
                    {toy.status}
                  </span>
                  {toy.isForKids && (
                    <span className="px-2 py-1 text-xs font-minecraft font-black uppercase tracking-wider border-2 border-black bg-[#f7931e] text-white flex items-center gap-1">
                      <Shield className="w-3 h-3" />
                      Kids
                    </span>
                  )}
                </div>
              </div>
            </div>
            
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button
                  bg="#ffffff"
                  textColor="black"
                  borderColor="black"
                  shadow="#e0e0e0"
                  className="py-1 px-2 hover-lift"
                >
                  <MoreVertical className="w-4 h-4" />
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent>
                <button 
                  onClick={() => onChat(toy._id)}
                  className="w-full text-left px-3 py-2 hover:bg-gray-100 font-minecraft font-black uppercase tracking-wider text-xs flex items-center gap-2"
                >
                  <MessageSquare className="w-4 h-4" />
                  Chat
                </button>
                <button 
                  onClick={() => onEdit(toy._id)}
                  className="w-full text-left px-3 py-2 hover:bg-gray-100 font-minecraft font-black uppercase tracking-wider text-xs flex items-center gap-2"
                >
                  <Edit className="w-4 h-4" />
                  Edit
                </button>
                <button 
                  onClick={() => onDuplicate(toy._id, `${toy.name} Copy`)}
                  className="w-full text-left px-3 py-2 hover:bg-gray-100 font-minecraft font-black uppercase tracking-wider text-xs flex items-center gap-2"
                >
                  <Copy className="w-4 h-4" />
                  Duplicate
                </button>
                <hr className="border-gray-300 my-1" />
                <button 
                  onClick={() => onDelete(toy._id)}
                  className="w-full text-left px-3 py-2 hover:bg-red-100 font-minecraft font-black uppercase tracking-wider text-xs flex items-center gap-2 text-red-600"
                >
                  <Trash className="w-4 h-4" />
                  Delete
                </button>
              </DropdownMenuContent>
            </DropdownMenu>
          </div>

          <div className="space-y-3 text-sm font-geo font-medium text-gray-600">
            <div className="flex items-center justify-between">
              <span className="flex items-center gap-1 font-geo tracking-wider">
                <MessageSquare className="w-4 h-4" />
                {0} chats
              </span>
              <span className="font-geo text-xs tracking-wider">
                {toy.lastActiveAt 
                  ? formatDistanceToNow(new Date(toy.lastActiveAt), { addSuffix: true })
                  : 'Never used'
                }
              </span>
            </div>
            
            <div className="flex items-center gap-2">
              {(toy.assignedDevices?.length || 0) > 0 ? (
                <span className="px-2 py-1 text-xs font-minecraft font-black uppercase tracking-wider border-2 border-black bg-[#92cd41] text-white flex items-center gap-1">
                  <Wifi className="w-3 h-3" />
                  {toy.assignedDevices?.length} device{(toy.assignedDevices?.length || 0) > 1 ? 's' : ''}
                </span>
              ) : (
                <span className="px-2 py-1 text-xs font-minecraft font-black uppercase tracking-wider border-2 border-black bg-[#f0f0f0] text-gray-400 flex items-center gap-1">
                  <WifiOff className="w-3 h-3" />
                  No devices
                </span>
              )}
            </div>
          </div>

          <div className="mt-4 flex gap-2">
            <Button
              bg={toy.status === 'active' ? "#ff6b6b" : "#92cd41"}
              textColor="white"
              borderColor="black"
              shadow={toy.status === 'active' ? "#e84545" : "#76a83a"}
              className="flex-1 py-2 text-xs font-minecraft font-black uppercase tracking-wider hover-lift"
              onClick={() => onStatusToggle(toy._id as Id<"toys">, toy.status)}
            >
              {toy.status === 'active' ? (
                <span className="flex items-center justify-center gap-1">
                  <Pause className="w-4 h-4" />
                  Pause
                </span>
              ) : (
                <span className="flex items-center justify-center gap-1">
                  <Play className="w-4 h-4" />
                  Activate
                </span>
              )}
            </Button>
            <Button
              bg="#c381b5"
              textColor="white"
              borderColor="black"
              shadow="#8b5fa3"
              className="flex-1 py-2 text-xs font-minecraft font-black uppercase tracking-wider hover-lift"
              onClick={() => onChat(toy._id)}
            >
              <span className="flex items-center justify-center gap-1">
                <MessageSquare className="w-4 h-4" />
                Chat
              </span>
            </Button>
          </div>
        </div>
      </Card>
    </motion.div>
  );
}
</file>

<file path="src/components/dashboard/ToyListItem.tsx">
'use client';

import { formatDistanceToNow } from 'date-fns';
import { Card, Button } from '@pommai/ui';
import { DropdownMenu, DropdownMenuTrigger, DropdownMenuContent } from '@/components/ui/dropdown-menu';
import { 
  MoreVertical, 
  Play, 
  Pause, 
  Edit, 
  Copy, 
  Trash, 
  MessageSquare,
  Shield
} from 'lucide-react';
import { motion } from 'framer-motion';
import { Id } from '../../../convex/_generated/dataModel';

interface Toy {
  _id: string;
  name: string;
  type: string;
  status: 'active' | 'paused' | 'archived';
  isForKids: boolean;
  lastActiveAt?: string;
}

interface ToyListItemProps {
  toy: Toy;
  onChat: (toyId: string) => void;
  onEdit: (toyId: string) => void;
  onStatusToggle: (toyId: Id<"toys">, currentStatus: string) => void;
  onDuplicate: (toyId: string, name: string) => void;
  onDelete: (toyId: string) => void;
}

const getToyAvatar = (type: string) => {
  const avatarMap: Record<string, string> = {
    teddy: '',
    bunny: '',
    cat: '',
    dog: '',
    bird: '',
    fish: '',
    robot: '',
    magical: '',
  };
  return avatarMap[type] || '';
};

export function ToyListItem({ 
  toy, 
  onChat, 
  onEdit, 
  onStatusToggle, 
  onDuplicate, 
  onDelete 
}: ToyListItemProps) {
  return (
    <motion.div
      layout
      initial={{ opacity: 0, x: -20 }}
      animate={{ opacity: 1, x: 0 }}
      exit={{ opacity: 0, x: -20 }}
    >
      <Card 
        bg="#ffffff" 
        borderColor="black" 
        shadowColor="#c381b5"
        className="hover-lift transition-transform"
      >
        <div className="p-4">
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-4 flex-1">
              <div className="text-3xl">{getToyAvatar(toy.type)}</div>
              <div className="flex-1">
                <div className="flex items-center gap-2">
                  <h3 className="font-minecraft font-black text-lg uppercase tracking-wider text-black">
                    {toy.name}
                  </h3>
                  <span className={`px-2 py-1 text-xs font-minecraft font-black uppercase tracking-wider border-2 border-black ${
                    toy.status === 'active' 
                      ? 'bg-[#92cd41] text-white' 
                      : 'bg-[#f0f0f0] text-black'
                  }`}>
                    {toy.status}
                  </span>
                  {toy.isForKids && (
                    <span className="px-2 py-1 text-xs font-minecraft font-black uppercase tracking-wider border-2 border-black bg-[#f7931e] text-white flex items-center gap-1">
                      <Shield className="w-3 h-3" />
                      Kids
                    </span>
                  )}
                </div>
                <div className="flex items-center gap-4 text-sm font-geo font-semibold text-gray-700 mt-1">
                  <span className="font-geo uppercase tracking-wider">{0} conversations</span>
                  <span></span>
                  <span className="font-geo uppercase tracking-wider">{0} messages</span>
                  <span></span>
                  <span className="font-geo uppercase tracking-wider">
                    Last active {toy.lastActiveAt 
                      ? formatDistanceToNow(new Date(toy.lastActiveAt), { addSuffix: true })
                      : 'never'
                    }
                  </span>
                </div>
              </div>
            </div>
            
            <div className="flex items-center gap-2">
              <Button
                bg={toy.status === 'active' ? "#ff6b6b" : "#92cd41"}
                textColor="white"
                borderColor="black"
                shadow={toy.status === 'active' ? "#e84545" : "#76a83a"}
                className="py-2 px-3 font-minecraft font-black hover-lift"
                onClick={() => onStatusToggle(toy._id as Id<"toys">, toy.status)}
              >
                {toy.status === 'active' ? (
                  <Pause className="w-4 h-4" />
                ) : (
                  <Play className="w-4 h-4" />
                )}
              </Button>
              <Button
                bg="#c381b5"
                textColor="white"
                borderColor="black"
                shadow="#8b5fa3"
                className="py-2 px-3 font-minecraft font-black hover-lift"
                onClick={() => onChat(toy._id)}
              >
                <MessageSquare className="w-4 h-4" />
              </Button>
              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button
                    bg="#ffffff"
                    textColor="black"
                    borderColor="black"
                    shadow="#e0e0e0"
                    className="py-2 px-3 font-minecraft font-black hover-lift"
                  >
                    <MoreVertical className="w-4 h-4" />
                  </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent>
                  <button 
                    onClick={() => onChat(toy._id)}
                    className="w-full text-left px-3 py-2 hover:bg-gray-100 font-minecraft font-black uppercase tracking-wider text-sm flex items-center gap-2"
                  >
                    <MessageSquare className="w-4 h-4" />
                    Chat
                  </button>
                  <button 
                    onClick={() => onEdit(toy._id)}
                    className="w-full text-left px-3 py-2 hover:bg-gray-100 font-minecraft font-black uppercase tracking-wider text-sm flex items-center gap-2"
                  >
                    <Edit className="w-4 h-4" />
                    Edit
                  </button>
                  <button 
                    onClick={() => onDuplicate(toy._id, `${toy.name} Copy`)}
                    className="w-full text-left px-3 py-2 hover:bg-gray-100 font-minecraft font-black uppercase tracking-wider text-sm flex items-center gap-2"
                  >
                    <Copy className="w-4 h-4" />
                    Duplicate
                  </button>
                  <hr className="border-gray-300 my-1" />
                  <button 
                    onClick={() => onDelete(toy._id)}
                    className="w-full text-left px-3 py-2 hover:bg-red-100 font-minecraft font-black uppercase tracking-wider text-sm flex items-center gap-2 text-red-600"
                  >
                    <Trash className="w-4 h-4" />
                    Delete
                  </button>
                </DropdownMenuContent>
              </DropdownMenu>
            </div>
          </div>
        </div>
      </Card>
    </motion.div>
  );
}
</file>

<file path="src/components/dashboard/ToyWizard.tsx">
'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';
import { motion, AnimatePresence } from 'framer-motion';
import { useToyWizardStore, type WizardStep } from '@/stores/toyWizardStore';
import { useToysStore } from '@/stores/useToysStore';
import { Button, ProgressBar, Card, Popup } from '@pommai/ui';
import { ArrowLeft, ArrowRight, X } from 'lucide-react';
import { useMutation } from 'convex/react';
import { api } from '../../../convex/_generated/api';

// Import step components (to be created)
import { WelcomeStep } from './steps/WelcomeStep';
import { ToyProfileStep } from './steps/ToyProfileStep';
import { ForKidsToggleStep } from './steps/ForKidsToggleStep';
import { PersonalityStep } from './steps/PersonalityStep';
import { VoiceStep } from './steps/VoiceStep';
import { KnowledgeStep } from './steps/KnowledgeStep';
import { SafetyStep } from './steps/SafetyStep';
import { DeviceStep } from './steps/DeviceStep';
import { ReviewStep } from './steps/ReviewStep';
import { CompletionStep } from './steps/CompletionStep';

const WIZARD_STEPS: WizardStep[] = [
  'welcome',
  'toyProfile',
  'forKidsToggle',
  'personality',
  'voice',
  'knowledge',
  'safety',
  'device',
  'review',
  'completion',
];

const STEP_TITLES: Record<WizardStep, string> = {
  welcome: 'Welcome',
  toyProfile: 'Toy Profile',
  forKidsToggle: 'Kids Mode',
  personality: 'Personality',
  voice: 'Voice Selection',
  knowledge: 'Knowledge Base',
  safety: 'Safety Settings',
  device: 'Device Pairing',
  review: 'Review & Create',
  completion: 'Success!',
};

const StepComponent: Record<WizardStep, React.ComponentType> = {
  welcome: WelcomeStep,
  toyProfile: ToyProfileStep,
  forKidsToggle: ForKidsToggleStep,
  personality: PersonalityStep,
  voice: VoiceStep,
  knowledge: KnowledgeStep,
  safety: SafetyStep,
  device: DeviceStep,
  review: ReviewStep,
  completion: CompletionStep,
};

export function ToyWizard() {
  const router = useRouter();
  const [showExitDialog, setShowExitDialog] = useState(false);
  
  const {
    currentStep,
    toyConfig,
    setCurrentStep,
    markStepCompleted,
    resetWizard,
    setIsCreating,
  } = useToyWizardStore();
  

  const createToy = useMutation(api.toys.createToy);
  const upsertKnowledgeBase = useMutation(api.knowledgeBase.upsertKnowledgeBase);

  const currentStepIndex = WIZARD_STEPS.indexOf(currentStep);
  const progressPercentage = ((currentStepIndex + 1) / WIZARD_STEPS.length) * 100;

  const handleNext = async () => {
    // Special handling for review step - actually create the toy
    if (currentStep === 'review') {
      try {
        setIsCreating(true);

        // Map safety settings to mutation args
        const safetyLevel = toyConfig.safetySettings?.safetyLevel;
        const contentFilters = toyConfig.safetySettings?.contentFilters;

        // Persist the toy in Convex
        const toyId = await createToy({
          name: toyConfig.name,
          type: toyConfig.type,
          isForKids: toyConfig.isForKids,
          ageGroup: toyConfig.ageGroup,
          voiceId: toyConfig.voiceId,
          personalityPrompt: toyConfig.personalityPrompt,
          personalityTraits: toyConfig.personalityTraits,
          safetyLevel,
          contentFilters,
          isPublic: toyConfig.isPublic,
          tags: toyConfig.tags,
        });

        // Optionally upsert knowledge base if provided by the wizard
        if (toyConfig.knowledgeBase) {
          const kb = toyConfig.knowledgeBase;
          const hasContent = (
            (kb.toyBackstory.origin?.trim()?.length ?? 0) > 0 ||
            (kb.toyBackstory.personality?.trim()?.length ?? 0) > 0 ||
            (kb.toyBackstory.specialAbilities?.length ?? 0) > 0 ||
            (kb.toyBackstory.favoriteThings?.length ?? 0) > 0 ||
            (kb.customFacts?.length ?? 0) > 0 ||
            (kb.familyInfo?.members?.length ?? 0) > 0 ||
            (kb.familyInfo?.pets?.length ?? 0) > 0 ||
            (kb.familyInfo?.importantDates?.length ?? 0) > 0
          );
          if (hasContent) {
            await upsertKnowledgeBase({
              toyId,
              toyBackstory: kb.toyBackstory,
              familyInfo: kb.familyInfo,
              customFacts: kb.customFacts ?? [],
            });
          }
        }
      } catch (err) {
        console.error('Failed to create toy:', err);
      } finally {
        setIsCreating(false);
      }
    }
    
    markStepCompleted(currentStep);
    const nextIndex = currentStepIndex + 1;
    if (nextIndex < WIZARD_STEPS.length) {
      setCurrentStep(WIZARD_STEPS[nextIndex]);
    }
  };

  const handleBack = () => {
    const prevIndex = currentStepIndex - 1;
    if (prevIndex >= 0) {
      setCurrentStep(WIZARD_STEPS[prevIndex]);
    }
  };

  const handleExit = () => {
    setShowExitDialog(true);
  };

  const confirmExit = () => {
    resetWizard();
    router.push('/dashboard');
  };

  const canGoNext = () => {
    // Step-specific validation logic
    switch (currentStep) {
      case 'welcome':
        return true;
      case 'toyProfile':
        return toyConfig.name.trim() !== '' && toyConfig.type !== '';
      case 'forKidsToggle':
        return true;
      case 'personality':
        return toyConfig.personalityPrompt.trim() !== '' && 
               toyConfig.personalityTraits.traits.length > 0;
      case 'voice':
        return toyConfig.voiceId !== '';
      case 'knowledge':
        return true; // Optional step
      case 'safety':
        return !toyConfig.isForKids || toyConfig.safetySettings !== undefined;
      case 'device':
        return true; // Can skip device pairing
      case 'review':
        return true;
      case 'completion':
        return false;
      default:
        return false;
    }
  };

  const CurrentStepComponent = StepComponent[currentStep];

  return (
    <div className="min-h-screen bg-gradient-to-br from-[#fefcd0] to-[#f4e5d3] py-[var(--spacing-lg)] sm:py-[var(--spacing-xl)] toy-wizard">
      <div className="max-w-4xl mx-auto px-[var(--spacing-md)]">
        {/* Header */}
        <div className="mb-[var(--spacing-xl)] sm:mb-[var(--spacing-2xl)]">
          <div className="flex items-center justify-between mb-[var(--spacing-lg)] sm:mb-[var(--spacing-xl)]">
            <div className="text-center sm:text-left">
              <h1 className="font-minecraft text-base sm:text-lg lg:text-xl font-black mb-3 uppercase tracking-wider text-gray-800"
                style={{
                  textShadow: '2px 2px 0 #c381b5, 4px 4px 0 #92cd41'
                }}
              >
                 Create Your AI Toy
              </h1>
              <p className="font-geo text-sm sm:text-base font-medium text-gray-600 leading-relaxed">Design the perfect companion!</p>
            </div>
            {currentStep !== 'completion' && (
              <Button
                bg="#ff6b6b"
                textColor="white"
                borderColor="black"
                shadow="#e84545"
                onClick={handleExit}
                className="py-2 px-3 text-sm font-minecraft font-black uppercase tracking-wider hover-lift"
              >
                <X className="w-4 h-4" />
              </Button>
            )}
          </div>
          
          {/* Progress bar */}
          {currentStep !== 'completion' && (
            <div className="space-y-4">
              <div className="flex justify-between text-sm font-geo font-medium text-gray-700">
                <span className="font-geo">{STEP_TITLES[currentStep]}</span>
                <span className="font-geo">Step {currentStepIndex + 1} of {WIZARD_STEPS.length - 1}</span>
              </div>
              <ProgressBar 
                progress={progressPercentage} 
                color="#c381b5"
                borderColor="black"
                className="shadow-[0_2px_0_2px_#8b5fa3]"
              />
            </div>
          )}
        </div>

        {/* Main content */}
          <Card 
          bg="#ffffff" 
          borderColor="black" 
          shadowColor="#c381b5"
          className="p-[var(--spacing-lg)] sm:p-[var(--spacing-xl)] lg:p-[var(--spacing-2xl)] hover-lift transition-transform"
        >
          <AnimatePresence mode="wait">
            <motion.div
              key={currentStep}
              initial={{ opacity: 0, x: 20 }}
              animate={{ opacity: 1, x: 0 }}
              exit={{ opacity: 0, x: -20 }}
              transition={{ duration: 0.3 }}
            >
              <CurrentStepComponent />
            </motion.div>
          </AnimatePresence>
        </Card>

        {/* Navigation buttons */}
        {currentStep !== 'completion' && (
          <div className="mt-[var(--spacing-xl)] sm:mt-[var(--spacing-2xl)] flex flex-col sm:flex-row justify-between gap-[var(--spacing-md)]">
            <Button
              bg={currentStepIndex === 0 ? "#f0f0f0" : "#ffffff"}
              textColor={currentStepIndex === 0 ? "#999" : "black"}
              borderColor="black"
              shadow={currentStepIndex === 0 ? "#d0d0d0" : "#e0e0e0"}
              onClick={handleBack}
              disabled={currentStepIndex === 0}
              className={`flex items-center gap-2 py-3 px-6 sm:px-8 font-minecraft font-black uppercase tracking-wider transition-all ${
                currentStepIndex === 0 ? 'cursor-not-allowed' : 'hover-lift'
              }`}
            >
              <ArrowLeft className="w-4 h-4" />
              <span className="hidden sm:inline">Back</span>
            </Button>
            
            <Button
              bg={canGoNext() ? "#92cd41" : "#f0f0f0"}
              textColor={canGoNext() ? "white" : "#999"}
              borderColor="black"
              shadow={canGoNext() ? "#76a83a" : "#d0d0d0"}
              onClick={handleNext}
              disabled={!canGoNext()}
              className={`flex items-center gap-2 py-3 px-6 sm:px-8 font-minecraft font-black uppercase tracking-wider transition-all ${
                canGoNext() ? 'hover-lift' : 'cursor-not-allowed'
              }`}
            >
              <span>{currentStep === 'review' ? ' Create Toy' : 'Next'}</span>
              <ArrowRight className="w-4 h-4" />
            </Button>
          </div>
        )}
      </div>

      {/* Exit confirmation popup */}
      {showExitDialog && (
        <Popup
          isOpen={showExitDialog}
          onClose={() => setShowExitDialog(false)}
          title=" Exit Toy Creation?"
          bg="#ffffff"
          borderColor="black"
          className="max-w-md"
        >
          <div className="space-y-4">
            <p className="font-geo text-gray-700 font-semibold">
              Your progress will be saved automatically. You can continue creating this toy later from where you left off.
            </p>
            <div className="flex flex-col sm:flex-row gap-3 pt-4">
              <Button
                bg="#f0f0f0"
                textColor="black"
                borderColor="black"
                shadow="#d0d0d0"
                onClick={() => setShowExitDialog(false)}
                className="flex-1 py-2 px-4 font-minecraft font-black uppercase tracking-wider hover-lift"
              >
                Continue Creating
              </Button>
              <Button
                bg="#ff6b6b"
                textColor="white"
                borderColor="black"
                shadow="#e84545"
                onClick={confirmExit}
                className="flex-1 py-2 px-4 font-minecraft font-black uppercase tracking-wider hover-lift"
              >
                Exit
              </Button>
            </div>
          </div>
        </Popup>
      )}
    </div>
  );
}
</file>

<file path="src/components/guardian/ActiveAlertsCard.tsx">
'use client';

import { Card } from '@pommai/ui';
import { AlertCircle } from 'lucide-react';

interface SafetyAlert {
  id: string;
  severity: "low" | "medium" | "high";
  type: "content" | "usage" | "behavior";
  message: string;
  timestamp: Date;
  resolved: boolean;
  childId: string;
  toyId: string;
}

interface ActiveAlertsCardProps {
  activeAlerts: SafetyAlert[];
}

export function ActiveAlertsCard({ activeAlerts }: ActiveAlertsCardProps) {
  if (activeAlerts.length === 0) {
    return null;
  }

  return (
    <Card
      bg="#ffe4e1"
      borderColor="red"
      shadowColor="#ff6b6b"
      className="p-4 sm:p-6 animate-pulse"
    >
      <div className="flex items-start gap-3">
        <AlertCircle className="w-6 h-6 text-red-600 flex-shrink-0 mt-1" />
        <div>
          <h3 className="retro-h3 text-base sm:text-lg text-red-600 mb-2 retro-shadow-orange">
             Active Safety Alerts
          </h3>
          <p className="font-bold text-red-700 uppercase tracking-wide">
            You have {activeAlerts.length} unresolved safety alerts that require your attention.
          </p>
        </div>
      </div>
    </Card>
  );
}
</file>

<file path="src/components/guardian/ChildProfilesCard.tsx">
'use client';

import { Card, ProgressBar } from '@pommai/ui';
import { Users } from 'lucide-react';

interface ChildProfile {
  id: string;
  name: string;
  age: number;
  assignedToys: string[];
  dailyLimit: number; // minutes
  currentUsage: number;
  avatar?: string;
}

interface ChildProfilesCardProps {
  profiles: ChildProfile[];
  selectedChildId: string | null;
  onChildSelect: (childId: string) => void;
}

export function ChildProfilesCard({ 
  profiles, 
  selectedChildId, 
  onChildSelect 
}: ChildProfilesCardProps) {
  const selectedChild = profiles.find(c => c.id === selectedChildId) || profiles[0];

  return (
    <Card 
      bg="#ffffff" 
      borderColor="black" 
      shadowColor="#c381b5"
      className="p-4 sm:p-6 hover-lift transition-transform"
    >
      <h2 className="text-xl font-black mb-4 uppercase tracking-wider text-black flex items-center gap-2">
        <Users className="w-5 h-5" />
         Your Children
      </h2>
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
        {profiles.map((child) => (
          <Card
            key={child.id}
            bg={selectedChild?.id === child.id ? "#c381b5" : "#ffffff"}
            borderColor="black"
            shadowColor={selectedChild?.id === child.id ? "#8b5fa3" : "#e0e0e0"}
            className={`p-4 cursor-pointer transition-all hover-lift ${
              selectedChild?.id === child.id ? 'text-white' : 'text-black'
            }`}
            onClick={() => onChildSelect(child.id)}
          >
            <div className="flex items-start justify-between mb-3">
              <div className="flex items-center gap-3">
                <div className="text-3xl">{child.avatar}</div>
                <div>
                  <h3 className="font-black uppercase tracking-wider">{child.name}</h3>
                  <p className={`text-sm font-bold uppercase tracking-wide ${
                    selectedChild?.id === child.id ? 'text-white opacity-90' : 'text-gray-600'
                  }`}>
                    {child.age} years old
                  </p>
                </div>
              </div>
              {selectedChild?.id === child.id && (
                <span className="px-2 py-1 text-xs font-black uppercase tracking-wider border-2 border-white bg-[#92cd41] text-white">
                  Selected
                </span>
              )}
            </div>
            
            <div className="space-y-3">
              <div>
                <div className="flex justify-between text-sm font-bold mb-2">
                  <span className="uppercase tracking-wider">Daily Usage</span>
                  <span className="uppercase tracking-wider">{child.currentUsage} / {child.dailyLimit} min</span>
                </div>
                <ProgressBar
                  progress={(child.currentUsage / child.dailyLimit) * 100}
                  color={selectedChild?.id === child.id ? "#92cd41" : "#c381b5"}
                  borderColor="black"
                  className="shadow-[0_2px_0_2px_rgba(0,0,0,0.3)]"
                />
              </div>
              
              <div className="flex items-center justify-between text-sm font-bold">
                <span className={`uppercase tracking-wider ${
                  selectedChild?.id === child.id ? 'text-white' : 'text-gray-700'
                }`}>
                   {child.assignedToys.length} toy{child.assignedToys.length !== 1 ? 's' : ''}
                </span>
                <span className={`text-xs uppercase tracking-wider ${
                  selectedChild?.id === child.id ? 'text-white opacity-90' : 'text-gray-500'
                }`}>
                  Active
                </span>
              </div>
            </div>
          </Card>
        ))}
      </div>
    </Card>
  );
}
</file>

<file path="src/components/guardian/GuardianDashboard.tsx">
"use client";

import { useState } from "react";
import { Card, Button } from "@pommai/ui";
import { SafetyControls } from "./SafetyControls";
import { LiveMonitoring } from "./LiveMonitoring";
import { SafetyAnalytics } from "./SafetyAnalytics";
import { GuardianHeader } from "./GuardianHeader";
import { ActiveAlertsCard } from "./ActiveAlertsCard";
import { ChildProfilesCard } from "./ChildProfilesCard";
import { OverviewTab } from "./OverviewTab";

interface ChildProfile {
  id: string;
  name: string;
  age: number;
  assignedToys: string[];
  dailyLimit: number; // minutes
  currentUsage: number;
  avatar?: string;
}

interface SafetyAlert {
  id: string;
  severity: "low" | "medium" | "high";
  type: "content" | "usage" | "behavior";
  message: string;
  timestamp: Date;
  resolved: boolean;
  childId: string;
  toyId: string;
}

export function GuardianDashboard() {
  const [selectedChildId, setSelectedChildId] = useState<string | null>(null);
  const [activeTab, setActiveTab] = useState("overview");

  // Mock data - in production, these would come from Convex queries
  const childrenProfiles: ChildProfile[] = [
    {
      id: "child-1",
      name: "Emma",
      age: 7,
      assignedToys: ["toy-1", "toy-2"],
      dailyLimit: 120,
      currentUsage: 45,
      avatar: "",
    },
    {
      id: "child-2",
      name: "Liam",
      age: 5,
      assignedToys: ["toy-3"],
      dailyLimit: 90,
      currentUsage: 30,
      avatar: "",
    },
  ];

  const safetyAlerts: SafetyAlert[] = [
    {
      id: "alert-1",
      severity: "low",
      type: "usage",
      message: "Emma has been chatting for 45 minutes today",
      timestamp: new Date(Date.now() - 1000 * 60 * 15), // 15 min ago
      resolved: false,
      childId: "child-1",
      toyId: "toy-1",
    },
    {
      id: "alert-2",
      severity: "medium",
      type: "content",
      message: "Blocked attempt to discuss inappropriate topic",
      timestamp: new Date(Date.now() - 1000 * 60 * 60), // 1 hour ago
      resolved: true,
      childId: "child-2",
      toyId: "toy-3",
    },
  ];

  // Mock mutations
  const emergencyStop = () => {
    console.log("Emergency stop activated");
    // In production, this would pause all toys
  };

  const resolveAlert = (alertId: string) => {
    console.log("Resolving alert:", alertId);
    // In production, this would mark the alert as resolved
  };

  const selectedChild = childrenProfiles.find(c => c.id === selectedChildId) || childrenProfiles[0];
  const activeAlerts = safetyAlerts.filter(a => !a.resolved);
  const childAlerts = safetyAlerts.filter(a => a.childId === selectedChild.id);

  return (
    <div className="min-h-screen bg-gradient-to-br from-[#fefcd0] to-[#f4e5d3]">
      <div className="max-w-7xl mx-auto p-4 sm:p-6 space-y-6">
        {/* Header */}
        <GuardianHeader onEmergencyStop={emergencyStop} />

        {/* Active Alerts */}
        <ActiveAlertsCard activeAlerts={activeAlerts} />

        {/* Child Profiles */}
          <ChildProfilesCard 
          profiles={childrenProfiles}
          selectedChildId={selectedChildId}
          onChildSelect={setSelectedChildId}
        />

        {/* Main Content Tabs */}
        <div className="space-y-4">
          {/* Tab Navigation */}
          <Card
            bg="#ffffff"
            borderColor="black"
            shadowColor="#c381b5"
            className="p-2"
          >
            <div className="grid grid-cols-4 gap-2">
              <Button
                bg={activeTab === "overview" ? "#c381b5" : "#f0f0f0"}
                textColor={activeTab === "overview" ? "white" : "black"}
                borderColor="black"
                shadow={activeTab === "overview" ? "#8b5fa3" : "#d0d0d0"}
                onClick={() => setActiveTab("overview")}
                className="py-2 px-4 font-minecraft font-black uppercase tracking-wider hover-lift text-xs sm:text-sm"
              >
                Overview
              </Button>
              <Button
                bg={activeTab === "monitoring" ? "#c381b5" : "#f0f0f0"}
                textColor={activeTab === "monitoring" ? "white" : "black"}
                borderColor="black"
                shadow={activeTab === "monitoring" ? "#8b5fa3" : "#d0d0d0"}
                onClick={() => setActiveTab("monitoring")}
                className="py-2 px-4 font-minecraft font-black uppercase tracking-wider hover-lift text-xs sm:text-sm"
              >
                Live Monitoring
              </Button>
              <Button
                bg={activeTab === "controls" ? "#c381b5" : "#f0f0f0"}
                textColor={activeTab === "controls" ? "white" : "black"}
                borderColor="black"
                shadow={activeTab === "controls" ? "#8b5fa3" : "#d0d0d0"}
                onClick={() => setActiveTab("controls")}
                className="py-2 px-4 font-minecraft font-black uppercase tracking-wider hover-lift text-xs sm:text-sm"
              >
                Safety Controls
              </Button>
              <Button
                bg={activeTab === "analytics" ? "#c381b5" : "#f0f0f0"}
                textColor={activeTab === "analytics" ? "white" : "black"}
                borderColor="black"
                shadow={activeTab === "analytics" ? "#8b5fa3" : "#d0d0d0"}
                onClick={() => setActiveTab("analytics")}
                className="py-2 px-4 font-minecraft font-black uppercase tracking-wider hover-lift text-xs sm:text-sm"
              >
                Analytics
              </Button>
            </div>
          </Card>

          {/* Tab Content */}
          {activeTab === "overview" && (
            <OverviewTab 
              selectedChild={selectedChild}
              childAlerts={childAlerts}
              onResolveAlert={resolveAlert}
            />
          )}

          {activeTab === "monitoring" && (
            <LiveMonitoring childId={selectedChild.id} />
          )}

          {activeTab === "controls" && (
            <SafetyControls childId={selectedChild.id} />
          )}

          {activeTab === "analytics" && (
            <SafetyAnalytics childId={selectedChild.id} />
          )}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/components/guardian/GuardianHeader.tsx">
'use client';

import { Button } from '@pommai/ui';
import { Shield, PauseCircle } from 'lucide-react';

interface GuardianHeaderProps {
  onEmergencyStop: () => void;
}

export function GuardianHeader({ onEmergencyStop }: GuardianHeaderProps) {
  return (
    <div className="flex flex-col sm:flex-row items-start sm:items-center justify-between gap-4">
      <div className="flex items-center gap-3">
        <Shield className="w-8 h-8 text-[#c381b5]" />
        <div>
          <h1 className="text-2xl sm:text-3xl font-black uppercase tracking-wider text-black"
            style={{
              textShadow: '2px 2px 0 #c381b5'
            }}
          >
             Guardian Dashboard
          </h1>
          <p className="font-bold text-gray-700 uppercase tracking-wide">
            Monitor and protect your children&apos;s AI interactions
          </p>
        </div>
      </div>
      <div className="flex gap-2">
        <Button
          bg="#ff6b6b"
          textColor="white"
          borderColor="black"
          shadow="#e84545"
          onClick={onEmergencyStop}
          className="py-3 px-4 sm:px-6 font-black uppercase tracking-wider hover-lift text-sm sm:text-base"
        >
          <span className="flex items-center gap-2">
            <PauseCircle className="w-5 h-5" />
            <span className="hidden sm:inline">Emergency Stop</span>
            <span className="sm:hidden">Stop</span>
          </span>
        </Button>
      </div>
    </div>
  );
}
</file>

<file path="src/components/guardian/LiveMonitoring.old.tsx">
"use client";

import { useState, useEffect, useRef } from "react";
import { Card, Button, Input } from "@pommai/ui";
import {
  Activity,
  MessageSquare,
  PauseCircle,
  PlayCircle,
  AlertTriangle,
  Shield,
  Eye,
  EyeOff,
  Volume2,
  VolumeX,
  RefreshCw,
  CheckCircle2,
  XCircle,
  AlertCircle,
} from "lucide-react";
import { formatDistanceToNow } from "date-fns";

interface LiveMonitoringProps {
  childId: string;
}

interface LiveMessage {
  id: string;
  role: "user" | "toy" | "system";
  content: string;
  timestamp: Date;
  flagged?: boolean;
  safetyScore?: number;
  topics?: string[];
}

interface ActiveConversation {
  id: string;
  toyId: string;
  toyName: string;
  startTime: Date;
  messages: LiveMessage[];
  isPaused: boolean;
  isMonitored: boolean;
}

export function LiveMonitoring({ childId }: LiveMonitoringProps) {
  const [activeConversations, setActiveConversations] = useState<ActiveConversation[]>([
    {
      id: "conv-1",
      toyId: "toy-1",
      toyName: "Buddy Bear",
      startTime: new Date(Date.now() - 1000 * 60 * 15), // 15 minutes ago
      isPaused: false,
      isMonitored: true,
      messages: [
        {
          id: "msg-1",
          role: "user",
          content: "Hi Buddy! Can we play a game?",
          timestamp: new Date(Date.now() - 1000 * 60 * 5),
          safetyScore: 100,
        },
        {
          id: "msg-2",
          role: "toy",
          content: "Of course! I love playing games with you. How about we play 'I Spy' or would you like to hear a story?",
          timestamp: new Date(Date.now() - 1000 * 60 * 4),
          safetyScore: 100,
          topics: ["games", "storytelling"],
        },
        {
          id: "msg-3",
          role: "user",
          content: "Let's play I Spy!",
          timestamp: new Date(Date.now() - 1000 * 60 * 3),
          safetyScore: 100,
        },
        {
          id: "msg-4",
          role: "toy",
          content: "Great choice! I'll start. I spy with my little eye, something that is... blue! Can you guess what it is?",
          timestamp: new Date(Date.now() - 1000 * 60 * 2),
          safetyScore: 100,
          topics: ["games", "colors"],
        },
      ],
    },
  ]);
  
  const [selectedConversationId, setSelectedConversationId] = useState<string | null>("conv-1");
  const [audioEnabled, setAudioEnabled] = useState(false);
  const [autoScroll, setAutoScroll] = useState(true);
  const messagesEndRef = useRef<HTMLDivElement>(null);

  const selectedConversation = activeConversations.find(c => c.id === selectedConversationId);

  useEffect(() => {
    // Simulate real-time message updates
    const interval = setInterval(() => {
      if (selectedConversation && !selectedConversation.isPaused) {
        // Add a new message every 30 seconds for demo
        const newMessage: LiveMessage = {
          id: `msg-${Date.now()}`,
          role: Math.random() > 0.5 ? "user" : "toy",
          content: getRandomMessage(),
          timestamp: new Date(),
          safetyScore: Math.random() * 20 + 80, // 80-100 safety score
          topics: ["conversation", "play"],
        };
        
        setActiveConversations(prev => 
          prev.map(conv => 
            conv.id === selectedConversationId
              ? { ...conv, messages: [...conv.messages, newMessage] }
              : conv
          )
        );
      }
    }, 30000);

    return () => clearInterval(interval);
  }, [selectedConversationId, selectedConversation?.isPaused]);

  useEffect(() => {
    if (autoScroll) {
      messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
    }
  }, [selectedConversation?.messages, autoScroll]);

  const getRandomMessage = () => {
    const messages = [
      "That's a wonderful idea!",
      "Can you tell me more about that?",
      "I love hearing your stories!",
      "What's your favorite color?",
      "Let's count to ten together!",
      "You're doing great!",
    ];
    return messages[Math.floor(Math.random() * messages.length)];
  };

  const handlePauseConversation = (conversationId: string) => {
    setActiveConversations(prev =>
      prev.map(conv =>
        conv.id === conversationId
          ? { ...conv, isPaused: !conv.isPaused }
          : conv
      )
    );
  };

  const handleToggleMonitoring = (conversationId: string) => {
    setActiveConversations(prev =>
      prev.map(conv =>
        conv.id === conversationId
          ? { ...conv, isMonitored: !conv.isMonitored }
          : conv
      )
    );
  };

  const getSafetyBadge = (score?: number) => {
    if (!score) return null;
    if (score >= 95) return <span className="px-2 py-1 text-xs font-black uppercase tracking-wider border border-green-600 bg-green-100 text-green-800">Safe</span>;
    if (score >= 80) return <span className="px-2 py-1 text-xs font-black uppercase tracking-wider border border-gray-600 bg-gray-100 text-gray-800">Normal</span>;
    return <span className="px-2 py-1 text-xs font-black uppercase tracking-wider border border-red-600 bg-red-100 text-red-800">Review</span>;
  };

  return (
    <div className="grid grid-cols-1 xl:grid-cols-3 gap-4 sm:gap-6">
      {/* Active Conversations List */}
      <Card 
        bg="#ffffff"
        borderColor="black"
        shadowColor="#c381b5"
        className="p-4 sm:p-6 xl:col-span-1 hover-lift"
      >
        <div className="flex items-center justify-between mb-4">
          <h3 className="retro-h3 text-base sm:text-lg text-black flex items-center gap-2">
            <Activity className="w-4 sm:w-5 h-4 sm:h-5" />
             Active Sessions
          </h3>
          <span className="px-2 py-1 text-xs font-black uppercase tracking-wider border-2 border-black bg-[#c381b5] text-white">
            {activeConversations.length}
          </span>
        </div>

        <div className="space-y-3 max-h-[400px] sm:max-h-[500px] overflow-y-auto">
          {activeConversations.map((conversation) => (
            <Card
              key={conversation.id}
              bg={selectedConversationId === conversation.id ? "#c381b5" : "#ffffff"}
              borderColor="black"
              shadowColor={selectedConversationId === conversation.id ? "#8b5fa3" : "#e0e0e0"}
              className={`p-3 cursor-pointer transition-all hover-lift ${
                selectedConversationId === conversation.id
                  ? "text-white"
                  : "text-black hover:shadow-[0_4px_0_2px_#c381b5]"
              }`}
              onClick={() => setSelectedConversationId(conversation.id)}
            >
              <div className="flex items-start justify-between gap-2">
                <div className="flex-1 min-w-0">
                  <p className="font-black uppercase tracking-wider text-sm sm:text-base truncate">
                    {conversation.toyName}
                  </p>
                  <p className={`text-xs sm:text-sm font-bold uppercase tracking-wide truncate ${
                    selectedConversationId === conversation.id ? "text-white opacity-90" : "text-gray-600"
                  }`}>
                    Started {formatDistanceToNow(conversation.startTime, { addSuffix: true })}
                  </p>
                </div>
                <div className="flex flex-col gap-1 items-end flex-shrink-0">
                  {conversation.isPaused && (
                    <span className="px-1 sm:px-2 py-1 text-xs font-black uppercase tracking-wider border border-orange-600 bg-orange-100 text-orange-800">
                      Paused
                    </span>
                  )}
                  {conversation.isMonitored && (
                    <span className="px-1 sm:px-2 py-1 text-xs font-black uppercase tracking-wider border border-blue-600 bg-blue-100 text-blue-800 flex items-center gap-1">
                      <Eye className="w-3 h-3" />
                      Live
                    </span>
                  )}
                </div>
              </div>
              <div className="mt-2 flex items-center gap-2">
                <MessageSquare className="w-3 sm:w-4 h-3 sm:h-4 text-gray-400" />
                <span className={`text-xs sm:text-sm font-bold uppercase tracking-wide ${
                  selectedConversationId === conversation.id ? "text-white opacity-90" : "text-gray-600"
                }`}>
                  {conversation.messages.length} messages
                </span>
              </div>
            </Card>
          ))}
        </div>

        {activeConversations.length === 0 && (
          <div className="text-center py-8 text-gray-500">
            <Activity className="w-8 sm:w-12 h-8 sm:h-12 mx-auto mb-3 opacity-50" />
            <p className="font-bold uppercase tracking-wide text-sm sm:text-base">No active conversations</p>
          </div>
        )}
      </Card>

      {/* Live Conversation View */}
      <Card 
        bg="#ffffff"
        borderColor="black"
        shadowColor="#f7931e"
        className="p-4 sm:p-6 xl:col-span-2 hover-lift"
      >
        {selectedConversation ? (
          <>
            {/* Header */}
            <div className="flex items-center justify-between mb-4 gap-4">
              <div className="flex items-center gap-2 sm:gap-3 min-w-0">
                <h3 className="retro-h3 text-base sm:text-lg text-black truncate">
                  {selectedConversation.toyName}
                </h3>
                {selectedConversation.isPaused && (
                  <span className="px-2 py-1 text-xs font-black uppercase tracking-wider border-2 border-red-600 bg-red-100 text-red-800 flex-shrink-0">
                    Paused
                  </span>
                )}
              </div>
              <div className="flex items-center gap-1 sm:gap-2 flex-wrap">
                <Button
                  bg={selectedConversation.isMonitored ? "#f0f0f0" : "#92cd41"}
                  textColor={selectedConversation.isMonitored ? "black" : "white"}
                  borderColor="black"
                  shadow={selectedConversation.isMonitored ? "#d0d0d0" : "#76a83a"}
                  onClick={() => handleToggleMonitoring(selectedConversation.id)}
                  className="py-1 sm:py-2 px-2 sm:px-3 text-xs sm:text-sm font-bold uppercase tracking-wider hover-lift"
                >
                  {selectedConversation.isMonitored ? (
                    <>
                      <EyeOff className="w-3 sm:w-4 h-3 sm:h-4 sm:mr-1" />
                      <span className="hidden sm:inline">Hide</span>
                    </>
                  ) : (
                    <>
                      <Eye className="w-3 sm:w-4 h-3 sm:h-4 sm:mr-1" />
                      <span className="hidden sm:inline">Monitor</span>
                    </>
                  )}
                </Button>
                <Button
                  bg={selectedConversation.isPaused ? "#92cd41" : "#ff6b6b"}
                  textColor="white"
                  borderColor="black"
                  shadow={selectedConversation.isPaused ? "#76a83a" : "#e84545"}
                  onClick={() => handlePauseConversation(selectedConversation.id)}
                  className="py-1 sm:py-2 px-2 sm:px-3 text-xs sm:text-sm font-bold uppercase tracking-wider hover-lift"
                >
                  {selectedConversation.isPaused ? (
                    <>
                      <PlayCircle className="w-3 sm:w-4 h-3 sm:h-4 sm:mr-1" />
                      <span className="hidden sm:inline">Resume</span>
                    </>
                  ) : (
                    <>
                      <PauseCircle className="w-3 sm:w-4 h-3 sm:h-4 sm:mr-1" />
                      <span className="hidden sm:inline">Pause</span>
                    </>
                  )}
                </Button>
                <Button
                  bg={audioEnabled ? "#c381b5" : "#f0f0f0"}
                  textColor={audioEnabled ? "white" : "black"}
                  borderColor="black"
                  shadow={audioEnabled ? "#8b5fa3" : "#d0d0d0"}
                  onClick={() => setAudioEnabled(!audioEnabled)}
                  className="py-1 sm:py-2 px-2 sm:px-3 text-xs sm:text-sm font-bold uppercase tracking-wider hover-lift"
                >
                  {audioEnabled ? (
                    <Volume2 className="w-3 sm:w-4 h-3 sm:h-4" />
                  ) : (
                    <VolumeX className="w-3 sm:w-4 h-3 sm:h-4" />
                  )}
                </Button>
              </div>
            </div>

            <div className="h-px bg-black mb-4"></div>

            {/* Messages */}
            <div className="h-[300px] sm:h-[400px] overflow-y-auto pr-2 sm:pr-4 border-2 border-black bg-[#fefcd0] p-3 sm:p-4">
              <div className="space-y-3 sm:space-y-4">
                {selectedConversation.messages.map((message) => (
                  <div
                    key={message.id}
                    className={`flex ${
                      message.role === "user" ? "justify-end" : "justify-start"
                    }`}
                  >
                    <div
                      className={`max-w-[85%] sm:max-w-[70%] border-2 border-black p-2 sm:p-3 ${
                        message.role === "user"
                          ? "bg-[#c381b5] text-white shadow-[2px_2px_0_0_#8b5fa3]"
                          : message.role === "toy"
                          ? "bg-white text-black shadow-[2px_2px_0_0_#e0e0e0]"
                          : "bg-[#f7931e] text-white shadow-[2px_2px_0_0_#d67c1a]"
                      }`}
                    >
                      <p className="text-xs sm:text-sm font-bold break-words">{message.content}</p>
                      <div className="flex flex-wrap items-center gap-1 sm:gap-2 mt-2">
                        <span className="text-xs font-bold uppercase tracking-wider opacity-70">
                          {message.timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
                        </span>
                        {message.safetyScore && getSafetyBadge(message.safetyScore)}
                        {message.flagged && (
                          <span className="px-1 sm:px-2 py-1 text-xs font-black uppercase tracking-wider border border-red-600 bg-red-100 text-red-800 flex items-center gap-1">
                            <AlertTriangle className="w-3 h-3" />
                            Flagged
                          </span>
                        )}
                      </div>
                      {message.topics && message.topics.length > 0 && (
                        <div className="flex flex-wrap gap-1 mt-2">
                          {message.topics.map((topic) => (
                            <span key={topic} className="px-1 sm:px-2 py-1 text-xs font-black uppercase tracking-wider border border-black bg-[#92cd41] text-white">
                              {topic}
                            </span>
                          ))}
                        </div>
                      )}
                    </div>
                  </div>
                ))}
                <div ref={messagesEndRef} />
              </div>
            </div>

            {/* Auto-scroll toggle */}
            <div className="mt-4 flex items-center justify-between gap-4">
              <Button
                bg={autoScroll ? "#92cd41" : "#f0f0f0"}
                textColor={autoScroll ? "white" : "black"}
                borderColor="black"
                shadow={autoScroll ? "#76a83a" : "#d0d0d0"}
                onClick={() => setAutoScroll(!autoScroll)}
                className="py-1 sm:py-2 px-2 sm:px-3 text-xs sm:text-sm font-bold uppercase tracking-wider hover-lift"
              >
                <RefreshCw className={`w-3 sm:w-4 h-3 sm:h-4 mr-1 ${autoScroll ? "animate-spin" : ""}`} />
                Auto-scroll {autoScroll ? "On" : "Off"}
              </Button>
              <p className="text-xs sm:text-sm font-bold uppercase tracking-wide text-gray-700 truncate">
                {selectedConversation.messages.length} messages in this session
              </p>
            </div>

            {/* Safety Alert */}
            {selectedConversation.messages.some(m => m.flagged) && (
              <Card
                bg="#ffe4e1"
                borderColor="red"
                shadowColor="#ff6b6b"
                className="mt-4 p-3 sm:p-4"
              >
                <div className="flex items-center gap-2">
                  <AlertTriangle className="h-4 w-4 text-red-600 flex-shrink-0" />
                  <p className="text-xs sm:text-sm font-bold text-red-700 uppercase tracking-wide">
                     This conversation contains flagged content. Review required.
                  </p>
                </div>
              </Card>
            )}
          </>
        ) : (
          <div className="flex items-center justify-center h-[400px] sm:h-[500px] text-gray-500">
            <div className="text-center">
              <MessageSquare className="w-8 sm:w-12 h-8 sm:h-12 mx-auto mb-3 opacity-50" />
              <p className="font-bold uppercase tracking-wide text-sm sm:text-base">Select a conversation to monitor</p>
            </div>
          </div>
        )}
      </Card>

      {/* Quick Actions */}
      <Card 
        bg="#ffffff"
        borderColor="black"
        shadowColor="#92cd41"
        className="p-4 xl:col-span-3 hover-lift"
      >
        <div className="flex items-center justify-between gap-4 flex-wrap">
          <div className="flex items-center gap-2 min-w-0">
            <Shield className="w-4 sm:w-5 h-4 sm:h-5 text-green-600 flex-shrink-0" />
            <span className="text-xs sm:text-sm font-black uppercase tracking-wider text-black">
               All conversations are being monitored for safety
            </span>
          </div>
          <div className="flex gap-2">
            <Button
              bg="#f0f0f0"
              textColor="black"
              borderColor="black"
              shadow="#d0d0d0"
              className="py-1 sm:py-2 px-2 sm:px-3 text-xs sm:text-sm font-bold uppercase tracking-wider hover-lift"
            >
              <span className="hidden sm:inline">Export Session</span>
              <span className="sm:hidden">Export</span>
            </Button>
            <Button
              bg="#c381b5"
              textColor="white"
              borderColor="black"
              shadow="#8b5fa3"
              className="py-1 sm:py-2 px-2 sm:px-3 text-xs sm:text-sm font-bold uppercase tracking-wider hover-lift"
            >
              <span className="hidden sm:inline">Safety Report</span>
              <span className="sm:hidden">Report</span>
            </Button>
          </div>
        </div>
      </Card>
    </div>
  );
}
</file>

<file path="src/components/guardian/LiveMonitoring.tsx">
"use client";

import { useState, useEffect, useRef } from "react";
import { useQuery } from "convex/react";
import { api } from "../../../convex/_generated/api";
import { Id } from "../../../convex/_generated/dataModel";
import { Card, Button } from "@pommai/ui";
import {
  Activity,
  MessageSquare,
  PauseCircle,
  PlayCircle,
  AlertTriangle,
  Shield,
  Eye,
  EyeOff,
  Volume2,
  VolumeX,
  RefreshCw,
  CheckCircle2,
  XCircle,
  AlertCircle,
} from "lucide-react";
import { formatDistanceToNow } from "date-fns";

interface LiveMonitoringProps {
  childId: string;
}

export function LiveMonitoring({ childId }: LiveMonitoringProps) {
  const [selectedConversationId, setSelectedConversationId] = useState<string | null>(null);
  const [audioEnabled, setAudioEnabled] = useState(false);
  const [autoScroll, setAutoScroll] = useState(true);
  const messagesEndRef = useRef<HTMLDivElement>(null);

  // Fetch active conversations for toys marked as "for kids"
  const activeConversations = useQuery(
    api.conversations.getActiveConversations,
    { isForKids: true }
  );

  // Fetch messages for selected conversation
  const selectedConversationMessages = useQuery(
    api.messages.getMessages,
    selectedConversationId 
      ? { conversationId: selectedConversationId as Id<"conversations"> }
      : "skip"
  );

  // Fetch conversation details
  const selectedConversation = useQuery(
    api.conversations.getConversationWithMessages,
    selectedConversationId
      ? { conversationId: selectedConversationId as Id<"conversations"> }
      : "skip"
  );

  // Auto-select first conversation if none selected
  useEffect(() => {
    if (!selectedConversationId && activeConversations && activeConversations.length > 0) {
      setSelectedConversationId(activeConversations[0]._id);
    }
  }, [activeConversations, selectedConversationId]);

  // Auto-scroll to bottom when new messages arrive
  useEffect(() => {
    if (autoScroll) {
      messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
    }
  }, [selectedConversationMessages, autoScroll]);

  const handlePauseConversation = async (conversationId: string) => {
    // TODO: Implement pause functionality via Convex mutation
    console.log("Pause conversation:", conversationId);
  };

  const handleToggleMonitoring = async (conversationId: string) => {
    // TODO: Implement monitoring toggle via Convex mutation
    console.log("Toggle monitoring:", conversationId);
  };

  const getSafetyBadge = (score?: number) => {
    if (!score) return null;
    if (score >= 0.95) return <span className="px-2 py-1 text-xs font-black uppercase tracking-wider border border-green-600 bg-green-100 text-green-800">Safe</span>;
    if (score >= 0.8) return <span className="px-2 py-1 text-xs font-black uppercase tracking-wider border border-gray-600 bg-gray-100 text-gray-800">Normal</span>;
    return <span className="px-2 py-1 text-xs font-black uppercase tracking-wider border border-red-600 bg-red-100 text-red-800">Review</span>;
  };

  return (
    <div className="grid grid-cols-1 xl:grid-cols-3 gap-4 sm:gap-6">
      {/* Active Conversations List */}
      <Card 
        bg="#ffffff"
        borderColor="black"
        shadowColor="#c381b5"
        className="p-4 sm:p-6 xl:col-span-1 hover-lift"
      >
        <div className="flex items-center justify-between mb-4">
          <h3 className="retro-h3 text-base sm:text-lg text-black flex items-center gap-2">
            <Activity className="w-4 sm:w-5 h-4 sm:h-5" />
             Active Sessions
          </h3>
          <span className="px-2 py-1 text-xs font-black uppercase tracking-wider border-2 border-black bg-[#c381b5] text-white">
            {activeConversations?.length || 0}
          </span>
        </div>

        <div className="space-y-3 max-h-[400px] sm:max-h-[500px] overflow-y-auto">
          {activeConversations?.map((conversation) => (
            <Card
              key={conversation._id}
              bg={selectedConversationId === conversation._id ? "#c381b5" : "#ffffff"}
              borderColor="black"
              shadowColor={selectedConversationId === conversation._id ? "#8b5fa3" : "#e0e0e0"}
              className={`p-3 cursor-pointer transition-all hover-lift ${
                selectedConversationId === conversation._id
                  ? "text-white"
                  : "text-black hover:shadow-[0_4px_0_2px_#c381b5]"
              }`}
              onClick={() => setSelectedConversationId(conversation._id)}
            >
              <div className="flex items-start justify-between gap-2">
                <div className="flex-1 min-w-0">
                  <p className="font-black uppercase tracking-wider text-sm sm:text-base truncate">
                    {conversation.toy?.name || "Unknown Toy"}
                  </p>
                  <p className={`text-xs sm:text-sm font-bold uppercase tracking-wide truncate ${
                    selectedConversationId === conversation._id ? "text-white opacity-90" : "text-gray-600"
                  }`}>
                    Started {formatDistanceToNow(new Date(parseInt(conversation.startedAt || "0")), { addSuffix: true })}
                  </p>
                </div>
                <div className="flex flex-col gap-1 items-end flex-shrink-0">
                  {conversation.isPaused && (
                    <span className="px-1 sm:px-2 py-1 text-xs font-black uppercase tracking-wider border border-orange-600 bg-orange-100 text-orange-800">
                      Paused
                    </span>
                  )}
                  <span className="px-1 sm:px-2 py-1 text-xs font-black uppercase tracking-wider border border-blue-600 bg-blue-100 text-blue-800 flex items-center gap-1">
                    <Eye className="w-3 h-3" />
                    Live
                  </span>
                </div>
              </div>
              <div className="mt-2 flex items-center gap-2">
                <MessageSquare className="w-3 sm:w-4 h-3 sm:h-4 text-gray-400" />
                <span className={`text-xs sm:text-sm font-bold uppercase tracking-wide ${
                  selectedConversationId === conversation._id ? "text-white opacity-90" : "text-gray-600"
                }`}>
                  {conversation.messageCount || 0} messages
                </span>
                {conversation.flaggedMessages > 0 && (
                  <span className="ml-auto px-1 py-0.5 text-xs font-black uppercase tracking-wider border border-red-600 bg-red-100 text-red-800">
                    {conversation.flaggedMessages} flagged
                  </span>
                )}
              </div>
            </Card>
          ))}
        </div>

        {(!activeConversations || activeConversations.length === 0) && (
          <div className="text-center py-8 text-gray-500">
            <Activity className="w-8 sm:w-12 h-8 sm:h-12 mx-auto mb-3 opacity-50" />
            <p className="font-bold uppercase tracking-wide text-sm sm:text-base">No active conversations</p>
          </div>
        )}
      </Card>

      {/* Live Conversation View */}
      <Card 
        bg="#ffffff"
        borderColor="black"
        shadowColor="#f7931e"
        className="p-4 sm:p-6 xl:col-span-2 hover-lift"
      >
        {selectedConversation ? (
          <>
            {/* Header */}
            <div className="flex items-center justify-between mb-4 gap-4">
              <div className="flex items-center gap-2 sm:gap-3 min-w-0">
                <h3 className="retro-h3 text-base sm:text-lg text-black truncate">
                  {selectedConversation.toy?.name || "Unknown Toy"}
                </h3>
                {selectedConversation.isPaused && (
                  <span className="px-2 py-1 text-xs font-black uppercase tracking-wider border-2 border-red-600 bg-red-100 text-red-800 flex-shrink-0">
                    Paused
                  </span>
                )}
              </div>
              <div className="flex items-center gap-1 sm:gap-2 flex-wrap">
                <Button
                  bg={selectedConversation.isMonitored ? "#f0f0f0" : "#92cd41"}
                  textColor={selectedConversation.isMonitored ? "black" : "white"}
                  borderColor="black"
                  shadow={selectedConversation.isMonitored ? "#d0d0d0" : "#76a83a"}
                  onClick={() => handleToggleMonitoring(selectedConversation._id)}
                  className="py-1 sm:py-2 px-2 sm:px-3 text-xs sm:text-sm font-bold uppercase tracking-wider hover-lift"
                >
                  {selectedConversation.isMonitored ? (
                    <>
                      <EyeOff className="w-3 sm:w-4 h-3 sm:h-4 sm:mr-1" />
                      <span className="hidden sm:inline">Hide</span>
                    </>
                  ) : (
                    <>
                      <Eye className="w-3 sm:w-4 h-3 sm:h-4 sm:mr-1" />
                      <span className="hidden sm:inline">Monitor</span>
                    </>
                  )}
                </Button>
                <Button
                  bg={selectedConversation.isPaused ? "#92cd41" : "#ff6b6b"}
                  textColor="white"
                  borderColor="black"
                  shadow={selectedConversation.isPaused ? "#76a83a" : "#e84545"}
                  onClick={() => handlePauseConversation(selectedConversation._id)}
                  className="py-1 sm:py-2 px-2 sm:px-3 text-xs sm:text-sm font-bold uppercase tracking-wider hover-lift"
                >
                  {selectedConversation.isPaused ? (
                    <>
                      <PlayCircle className="w-3 sm:w-4 h-3 sm:h-4 sm:mr-1" />
                      <span className="hidden sm:inline">Resume</span>
                    </>
                  ) : (
                    <>
                      <PauseCircle className="w-3 sm:w-4 h-3 sm:h-4 sm:mr-1" />
                      <span className="hidden sm:inline">Pause</span>
                    </>
                  )}
                </Button>
                <Button
                  bg={audioEnabled ? "#c381b5" : "#f0f0f0"}
                  textColor={audioEnabled ? "white" : "black"}
                  borderColor="black"
                  shadow={audioEnabled ? "#8b5fa3" : "#d0d0d0"}
                  onClick={() => setAudioEnabled(!audioEnabled)}
                  className="py-1 sm:py-2 px-2 sm:px-3 text-xs sm:text-sm font-bold uppercase tracking-wider hover-lift"
                >
                  {audioEnabled ? (
                    <Volume2 className="w-3 sm:w-4 h-3 sm:h-4" />
                  ) : (
                    <VolumeX className="w-3 sm:w-4 h-3 sm:h-4" />
                  )}
                </Button>
              </div>
            </div>

            <div className="h-px bg-black mb-4"></div>

            {/* Messages */}
            <div className="h-[300px] sm:h-[400px] overflow-y-auto pr-2 sm:pr-4 border-2 border-black bg-[#fefcd0] p-3 sm:p-4">
              <div className="space-y-3 sm:space-y-4">
                {selectedConversation.messages?.map((message) => (
                  <div
                    key={message._id}
                    className={`flex ${
                      message.role === "user" ? "justify-end" : "justify-start"
                    }`}
                  >
                    <div
                      className={`max-w-[85%] sm:max-w-[70%] border-2 border-black p-2 sm:p-3 ${
                        message.role === "user"
                          ? "bg-[#c381b5] text-white shadow-[2px_2px_0_0_#8b5fa3]"
                          : message.role === "toy"
                          ? "bg-white text-black shadow-[2px_2px_0_0_#e0e0e0]"
                          : "bg-[#f7931e] text-white shadow-[2px_2px_0_0_#d67c1a]"
                      }`}
                    >
                      <p className="text-xs sm:text-sm font-bold break-words">{message.content}</p>
                      <div className="flex flex-wrap items-center gap-1 sm:gap-2 mt-2">
                        <span className="text-xs font-bold uppercase tracking-wider opacity-70">
                          {new Date(parseInt(message.timestamp || "0")).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
                        </span>
                        {message.metadata?.safetyScore && getSafetyBadge(message.metadata.safetyScore)}
                        {message.metadata?.flagged && (
                          <span className="px-1 sm:px-2 py-1 text-xs font-black uppercase tracking-wider border border-red-600 bg-red-100 text-red-800 flex items-center gap-1">
                            <AlertTriangle className="w-3 h-3" />
                            Flagged
                          </span>
                        )}
                      </div>
                      {message.metadata?.topics && message.metadata.topics.length > 0 && (
                        <div className="flex flex-wrap gap-1 mt-2">
                          {message.metadata.topics.map((topic: string) => (
                            <span key={topic} className="px-1 sm:px-2 py-1 text-xs font-black uppercase tracking-wider border border-black bg-[#92cd41] text-white">
                              {topic}
                            </span>
                          ))}
                        </div>
                      )}
                    </div>
                  </div>
                ))}
                <div ref={messagesEndRef} />
              </div>
            </div>

            {/* Auto-scroll toggle */}
            <div className="mt-4 flex items-center justify-between gap-4">
              <Button
                bg={autoScroll ? "#92cd41" : "#f0f0f0"}
                textColor={autoScroll ? "white" : "black"}
                borderColor="black"
                shadow={autoScroll ? "#76a83a" : "#d0d0d0"}
                onClick={() => setAutoScroll(!autoScroll)}
                className="py-1 sm:py-2 px-2 sm:px-3 text-xs sm:text-sm font-bold uppercase tracking-wider hover-lift"
              >
                <RefreshCw className={`w-3 sm:w-4 h-3 sm:h-4 mr-1 ${autoScroll ? "animate-spin" : ""}`} />
                Auto-scroll {autoScroll ? "On" : "Off"}
              </Button>
              <p className="text-xs sm:text-sm font-bold uppercase tracking-wide text-gray-700 truncate">
                {selectedConversation.messages?.length || 0} messages in this session
              </p>
            </div>

            {/* Safety Alert */}
            {selectedConversation.messages?.some(m => m.metadata?.flagged) && (
              <Card
                bg="#ffe4e1"
                borderColor="red"
                shadowColor="#ff6b6b"
                className="mt-4 p-3 sm:p-4"
              >
                <div className="flex items-start gap-2">
                  <AlertTriangle className="w-5 h-5 text-red-600 flex-shrink-0 mt-1" />
                  <div>
                    <p className="font-black uppercase tracking-wider text-sm text-red-800 mb-1">
                      Safety Alert
                    </p>
                    <p className="text-xs sm:text-sm font-bold text-red-700">
                      This conversation contains flagged content. Please review the messages marked with safety warnings.
                    </p>
                  </div>
                </div>
              </Card>
            )}
          </>
        ) : (
          <div className="flex items-center justify-center h-full">
            <div className="text-center">
              <MessageSquare className="w-12 h-12 mx-auto mb-3 text-gray-400" />
              <p className="font-bold uppercase tracking-wide text-gray-500">
                Select a conversation to monitor
              </p>
            </div>
          </div>
        )}
      </Card>
    </div>
  );
}
</file>

<file path="src/components/guardian/OverviewTab.tsx">
'use client';

import { Card, Button } from '@pommai/ui';
import { AlertTriangle, AlertCircle, CheckCircle2, XCircle } from 'lucide-react';
import { formatDistanceToNow } from 'date-fns';
import { QuickStatsCards } from './QuickStatsCards';

interface ChildProfile {
  id: string;
  name: string;
  age: number;
  assignedToys: string[];
  dailyLimit: number;
  currentUsage: number;
  avatar?: string;
}

interface SafetyAlert {
  id: string;
  severity: "low" | "medium" | "high";
  type: "content" | "usage" | "behavior";
  message: string;
  timestamp: Date;
  resolved: boolean;
  childId: string;
  toyId: string;
}

interface OverviewTabProps {
  selectedChild: ChildProfile;
  childAlerts: SafetyAlert[];
  onResolveAlert: (alertId: string) => void;
}

export function OverviewTab({ 
  selectedChild, 
  childAlerts, 
  onResolveAlert 
}: OverviewTabProps) {
  return (
    <div className="space-y-4">
      {/* Recent Alerts */}
      <Card
        bg="#ffffff"
        borderColor="black"
        shadowColor="#c381b5"
        className="p-4 sm:p-6"
      >
        <h3 className="retro-h3 text-base sm:text-lg text-black mb-4 flex items-center gap-2 retro-shadow-orange">
          <AlertTriangle className="w-5 h-5" />
           Recent Safety Alerts
        </h3>
        <div className="space-y-3">
          {childAlerts.length === 0 ? (
            <p className="text-gray-500 text-center py-8 font-bold uppercase tracking-wide">
              No safety alerts for {selectedChild.name}
            </p>
          ) : (
            childAlerts.map((alert) => (
              <Card
                key={alert.id}
                bg={alert.resolved
                  ? "#f8f8f8"
                  : alert.severity === "high"
                  ? "#ffe4e1"
                  : alert.severity === "medium"
                  ? "#fff3cd"
                  : "#e1f5fe"}
                borderColor={alert.resolved
                  ? "gray"
                  : alert.severity === "high"
                  ? "red"
                  : alert.severity === "medium"
                  ? "orange"
                  : "blue"}
                shadowColor={alert.resolved
                  ? "#d0d0d0"
                  : alert.severity === "high"
                  ? "#ff6b6b"
                  : alert.severity === "medium"
                  ? "#f7931e"
                  : "#92cd41"}
                className="p-4"
              >
                <div className="flex items-start justify-between">
                  <div className="flex items-start gap-3">
                    {alert.resolved ? (
                      <CheckCircle2 className="w-5 h-5 text-green-500 mt-0.5" />
                    ) : alert.severity === "high" ? (
                      <XCircle className="w-5 h-5 text-red-500 mt-0.5" />
                    ) : alert.severity === "medium" ? (
                      <AlertCircle className="w-5 h-5 text-orange-500 mt-0.5" />
                    ) : (
                      <AlertCircle className="w-5 h-5 text-blue-500 mt-0.5" />
                    )}
                    <div className="flex-1">
                      <p className="font-bold text-black">{alert.message}</p>
                      <p className="text-sm text-gray-500 mt-1 font-bold uppercase tracking-wide">
                        {formatDistanceToNow(alert.timestamp, { addSuffix: true })}
                      </p>
                    </div>
                  </div>
                  {!alert.resolved && (
                    <Button
                      bg="#92cd41"
                      textColor="white"
                      borderColor="black"
                      shadow="#76a83a"
                      onClick={() => onResolveAlert(alert.id)}
                      className="py-1 px-3 font-bold uppercase tracking-wider hover-lift"
                    >
                      Resolve
                    </Button>
                  )}
                </div>
              </Card>
            ))
          )}
        </div>
      </Card>

      {/* Quick Stats */}
      <QuickStatsCards selectedChild={selectedChild} />
    </div>
  );
}
</file>

<file path="src/components/guardian/QuickStatsCards.tsx">
'use client';

import { Card } from '@pommai/ui';
import { Clock, Shield, MessageSquare } from 'lucide-react';

interface ChildProfile {
  id: string;
  name: string;
  age: number;
  assignedToys: string[];
  dailyLimit: number;
  currentUsage: number;
  avatar?: string;
}

interface QuickStatsCardsProps {
  selectedChild: ChildProfile;
}

export function QuickStatsCards({ selectedChild }: QuickStatsCardsProps) {
  return (
    <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
      <Card
        bg="#ffffff"
        borderColor="black"
        shadowColor="#92cd41"
        className="p-4 sm:p-6"
      >
        <div className="flex items-center justify-between">
          <div>
            <p className="text-sm font-black uppercase tracking-wider text-gray-700">Today&apos;s Activity</p>
            <p className="text-2xl font-black text-black">{selectedChild.currentUsage} min</p>
          </div>
          <Clock className="w-8 h-8 text-blue-500" />
        </div>
      </Card>
      
      <Card
        bg="#ffffff"
        borderColor="black"
        shadowColor="#f7931e"
        className="p-4 sm:p-6"
      >
        <div className="flex items-center justify-between">
          <div>
            <p className="text-sm font-black uppercase tracking-wider text-gray-700">Safety Score</p>
            <p className="text-2xl font-black text-black">98%</p>
          </div>
          <Shield className="w-8 h-8 text-green-500" />
        </div>
      </Card>
      
      <Card
        bg="#ffffff"
        borderColor="black"
        shadowColor="#c381b5"
        className="p-4 sm:p-6"
      >
        <div className="flex items-center justify-between">
          <div>
            <p className="text-sm font-black uppercase tracking-wider text-gray-700">Messages Today</p>
            <p className="text-2xl font-black text-black">127</p>
          </div>
          <MessageSquare className="w-8 h-8 text-purple-500" />
        </div>
      </Card>
    </div>
  );
}
</file>

<file path="src/components/guardian/SafetyAnalytics.tsx">
"use client";

import { Card, Button, ProgressBar } from "@pommai/ui";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  BarChart3,
  TrendingUp,
  TrendingDown,
  Calendar,
  Download,
  Filter,
  Brain,
  Heart,
  Shield,
  Clock,
  MessageSquare,
  AlertTriangle,
  CheckCircle2,
  AlertCircle,
} from "lucide-react";
import {
  BarChart,
  Bar,
  LineChart,
  Line,
  PieChart,
  Pie,
  Cell,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer,
} from "recharts";

interface SafetyAnalyticsProps {
  childId: string;
}

// Mock data for charts
const weeklyActivityData = [
  { day: "Mon", minutes: 45, messages: 120 },
  { day: "Tue", minutes: 60, messages: 150 },
  { day: "Wed", minutes: 30, messages: 80 },
  { day: "Thu", minutes: 75, messages: 190 },
  { day: "Fri", minutes: 90, messages: 220 },
  { day: "Sat", minutes: 120, messages: 280 },
  { day: "Sun", minutes: 100, messages: 240 },
];

const topicsDistribution = [
  { name: "Education", value: 35, color: "#3B82F6" },
  { name: "Games", value: 25, color: "#10B981" },
  { name: "Stories", value: 20, color: "#F59E0B" },
  { name: "Creative", value: 15, color: "#8B5CF6" },
  { name: "Other", value: 5, color: "#6B7280" },
];

const safetyTrends = [
  { date: "Week 1", safetyScore: 98, incidents: 0 },
  { date: "Week 2", safetyScore: 97, incidents: 1 },
  { date: "Week 3", safetyScore: 99, incidents: 0 },
  { date: "Week 4", safetyScore: 96, incidents: 2 },
];

const emotionalInsights = [
  { emotion: "Happy", percentage: 65 },
  { emotion: "Curious", percentage: 20 },
  { emotion: "Neutral", percentage: 10 },
  { emotion: "Frustrated", percentage: 5 },
];

export function SafetyAnalytics({ childId }: SafetyAnalyticsProps) {
  return (
    <div className="space-y-6">
      {/* Header with filters */}
      <div className="flex items-center justify-between">
        <h3 className="retro-h3 text-base sm:text-lg text-black flex items-center gap-2">
          <BarChart3 className="w-5 h-5" />
           Safety Analytics & Insights
        </h3>
        <div className="flex items-center gap-2">
          <Select defaultValue="week">
            <SelectTrigger className="w-[140px] border-2 border-black font-bold">
              <Calendar className="w-4 h-4 mr-2" />
              <SelectValue />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="today">Today</SelectItem>
              <SelectItem value="week">This Week</SelectItem>
              <SelectItem value="month">This Month</SelectItem>
              <SelectItem value="year">This Year</SelectItem>
            </SelectContent>
          </Select>
          <Button
            bg="#f0f0f0"
            textColor="black"
            borderColor="black"
            shadow="#d0d0d0"
            className="py-2 px-3 font-bold uppercase tracking-wider hover-lift"
          >
            <Download className="w-4 h-4 mr-2" />
            Export Report
          </Button>
        </div>
      </div>

      {/* Key Metrics */}
      <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
        <Card 
          bg="#ffffff"
          borderColor="black"
          shadowColor="#92cd41"
          className="p-4 hover-lift"
        >
          <div className="flex items-center justify-between mb-2">
            <Shield className="w-5 h-5 text-green-600" />
            <span className="px-2 py-1 text-xs font-black uppercase tracking-wider border border-green-600 bg-green-100 text-green-600 flex items-center gap-1">
              <TrendingUp className="w-3 h-3" />
              +2%
            </span>
          </div>
          <p className="text-2xl font-black text-black">98%</p>
          <p className="text-sm font-bold uppercase tracking-wide text-gray-700">Safety Score</p>
        </Card>

        <Card 
          bg="#ffffff"
          borderColor="black"
          shadowColor="#f7931e"
          className="p-4 hover-lift"
        >
          <div className="flex items-center justify-between mb-2">
            <Clock className="w-5 h-5 text-blue-600" />
            <span className="px-2 py-1 text-xs font-black uppercase tracking-wider border border-red-600 bg-red-100 text-red-600 flex items-center gap-1">
              <TrendingDown className="w-3 h-3" />
              -15%
            </span>
          </div>
          <p className="text-2xl font-black text-black">74 min</p>
          <p className="text-sm font-bold uppercase tracking-wide text-gray-700">Avg Daily Usage</p>
        </Card>

        <Card 
          bg="#ffffff"
          borderColor="black"
          shadowColor="#c381b5"
          className="p-4 hover-lift"
        >
          <div className="flex items-center justify-between mb-2">
            <MessageSquare className="w-5 h-5 text-purple-600" />
            <span className="px-2 py-1 text-xs font-black uppercase tracking-wider border border-gray-600 bg-gray-100 text-gray-800">Stable</span>
          </div>
          <p className="text-2xl font-black text-black">1,280</p>
          <p className="text-sm font-bold uppercase tracking-wide text-gray-700">Total Messages</p>
        </Card>

        <Card 
          bg="#ffffff"
          borderColor="black"
          shadowColor="#fefcd0"
          className="p-4 hover-lift"
        >
          <div className="flex items-center justify-between mb-2">
            <AlertTriangle className="w-5 h-5 text-orange-600" />
            <span className="px-2 py-1 text-xs font-black uppercase tracking-wider border border-green-600 bg-green-100 text-green-600">Low</span>
          </div>
          <p className="text-2xl font-black text-black">3</p>
          <p className="text-sm font-bold uppercase tracking-wide text-gray-700">Safety Incidents</p>
        </Card>
      </div>

      {/* Activity Chart */}
      <Card 
        bg="#ffffff"
        borderColor="black"
        shadowColor="#c381b5"
        className="p-4 sm:p-6 hover-lift"
      >
        <h4 className="text-md font-black uppercase tracking-wider text-black mb-4">
           Weekly Activity Overview
        </h4>
        <ResponsiveContainer width="100%" height={300}>
          <BarChart data={weeklyActivityData}>
            <CartesianGrid strokeDasharray="3 3" />
            <XAxis dataKey="day" />
            <YAxis yAxisId="left" />
            <YAxis yAxisId="right" orientation="right" />
            <Tooltip />
            <Legend />
            <Bar yAxisId="left" dataKey="minutes" fill="#3B82F6" name="Minutes" />
            <Bar yAxisId="right" dataKey="messages" fill="#10B981" name="Messages" />
          </BarChart>
        </ResponsiveContainer>
      </Card>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        {/* Topics Distribution */}
        <Card 
          bg="#ffffff"
          borderColor="black"
          shadowColor="#f7931e"
          className="p-4 sm:p-6 hover-lift"
        >
          <h4 className="text-md font-black uppercase tracking-wider text-black mb-4">
             Conversation Topics
          </h4>
          <ResponsiveContainer width="100%" height={250}>
            <PieChart>
              <Pie
                data={topicsDistribution}
                cx="50%"
                cy="50%"
                labelLine={false}
                label={({ name, percent }) => `${name} ${((percent || 0) * 100).toFixed(0)}%`}
                outerRadius={80}
                fill="#8884d8"
                dataKey="value"
              >
                {topicsDistribution.map((entry, index) => (
                  <Cell key={`cell-${index}`} fill={entry.color} />
                ))}
              </Pie>
              <Tooltip />
            </PieChart>
          </ResponsiveContainer>
        </Card>

        {/* Safety Trends */}
        <Card 
          bg="#ffffff"
          borderColor="black"
          shadowColor="#92cd41"
          className="p-4 sm:p-6 hover-lift"
        >
          <h4 className="text-md font-black uppercase tracking-wider text-black mb-4">
             Safety Trends
          </h4>
          <ResponsiveContainer width="100%" height={250}>
            <LineChart data={safetyTrends}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis dataKey="date" />
              <YAxis />
              <Tooltip />
              <Legend />
              <Line
                type="monotone"
                dataKey="safetyScore"
                stroke="#10B981"
                name="Safety Score"
                strokeWidth={2}
              />
              <Line
                type="monotone"
                dataKey="incidents"
                stroke="#EF4444"
                name="Incidents"
                strokeWidth={2}
              />
            </LineChart>
          </ResponsiveContainer>
        </Card>
      </div>

      {/* Emotional Insights */}
      <Card 
        bg="#ffffff"
        borderColor="black"
        shadowColor="#c381b5"
        className="p-4 sm:p-6 hover-lift"
      >
        <div className="flex items-center justify-between mb-4">
          <h4 className="text-md font-black uppercase tracking-wider text-black flex items-center gap-2">
            <Heart className="w-5 h-5 text-pink-600" />
             Emotional Well-being Insights
          </h4>
          <span className="px-2 py-1 text-xs font-black uppercase tracking-wider border border-green-600 bg-green-100 text-green-600">
            Healthy
          </span>
        </div>
        <div className="space-y-4">
          {emotionalInsights.map((emotion) => (
            <div key={emotion.emotion}>
              <div className="flex justify-between mb-2">
                <span className="text-sm font-black uppercase tracking-wider text-black">{emotion.emotion}</span>
                <span className="text-sm font-bold text-gray-700">{emotion.percentage}%</span>
              </div>
              <ProgressBar 
                progress={emotion.percentage} 
                color="#c381b5"
                borderColor="black"
                className="h-2 shadow-[0_2px_0_1px_rgba(0,0,0,0.3)]"
              />
            </div>
          ))}
        </div>
        <Card
          bg="#e1f5fe"
          borderColor="blue"
          shadowColor="#2196f3"
          className="mt-4 p-4"
        >
          <p className="text-sm font-bold text-blue-800">
            <strong> AI Insight:</strong> Your child shows healthy emotional patterns with
            predominantly positive interactions. The curiosity level indicates good engagement
            with educational content.
          </p>
        </Card>
      </Card>

      {/* Learning Progress */}
      <Card 
        bg="#ffffff"
        borderColor="black"
        shadowColor="#92cd41"
        className="p-4 sm:p-6 hover-lift"
      >
        <div className="flex items-center justify-between mb-4">
          <h4 className="text-md font-black uppercase tracking-wider text-black flex items-center gap-2">
            <Brain className="w-5 h-5 text-purple-600" />
             Learning & Development
          </h4>
          <span className="px-2 py-1 text-xs font-black uppercase tracking-wider border border-green-600 bg-green-100 text-green-600">
            On Track
          </span>
        </div>
        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
          <Card
            bg="#f8f4ff"
            borderColor="black"
            shadowColor="#c381b5"
            className="text-center p-4"
          >
            <p className="text-2xl font-black text-purple-600">127</p>
            <p className="text-sm font-bold uppercase tracking-wide text-gray-700">New Words Learned</p>
          </Card>
          <Card
            bg="#e3f2fd"
            borderColor="black"
            shadowColor="#2196f3"
            className="text-center p-4"
          >
            <p className="text-2xl font-black text-blue-600">45</p>
            <p className="text-sm font-bold uppercase tracking-wide text-gray-700">Questions Asked</p>
          </Card>
          <Card
            bg="#e8f5e8"
            borderColor="black"
            shadowColor="#4caf50"
            className="text-center p-4"
          >
            <p className="text-2xl font-black text-green-600">23</p>
            <p className="text-sm font-bold uppercase tracking-wide text-gray-700">Stories Completed</p>
          </Card>
        </div>
      </Card>

      {/* Recommendations */}
      <Card 
        bg="#ffffff"
        borderColor="black"
        shadowColor="#f7931e"
        className="p-4 sm:p-6 hover-lift"
      >
        <h4 className="text-md font-black uppercase tracking-wider text-black mb-4">
           Personalized Recommendations
        </h4>
        <div className="space-y-3">
          <Card
            bg="#e8f5e8"
            borderColor="green"
            shadowColor="#4caf50"
            className="p-3"
          >
            <div className="flex items-start gap-3">
              <CheckCircle2 className="w-5 h-5 text-green-600 mt-0.5" />
              <div>
                <p className="font-black text-sm uppercase tracking-wider text-green-800">
                  Encourage more educational content
                </p>
                <p className="text-sm font-bold text-green-700">
                  Your child responds well to learning activities. Consider enabling more educational games.
                </p>
              </div>
            </div>
          </Card>
          <Card
            bg="#e3f2fd"
            borderColor="blue"
            shadowColor="#2196f3"
            className="p-3"
          >
            <div className="flex items-start gap-3">
              <AlertCircle className="w-5 h-5 text-blue-600 mt-0.5" />
              <div>
                <p className="font-black text-sm uppercase tracking-wider text-blue-800">
                  Adjust weekend time limits
                </p>
                <p className="text-sm font-bold text-blue-700">
                  Weekend usage is higher than weekdays. Consider setting specific weekend limits.
                </p>
              </div>
            </div>
          </Card>
        </div>
      </Card>
    </div>
  );
}
</file>

<file path="src/components/guardian/SafetyControls.tsx">
"use client";

import { useState, type ChangeEvent, type KeyboardEvent } from "react";
import { Card, Button, Input } from "@pommai/ui";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Slider } from "@/components/ui/slider";
import { Switch } from "@/components/ui/switch";
import {
  Shield,
  Clock,
  Filter,
  Bell,
  Plus,
  X,
  Save,
  AlertCircle,
} from "lucide-react";

interface SafetyControlsProps {
  childId: string;
}

interface TimeRestriction {
  id: string;
  dayType: "weekday" | "weekend";
  startTime: string;
  endTime: string;
}

export function SafetyControls({ childId }: SafetyControlsProps) {
  // Content Filtering State
  const [strictnessLevel, setStrictnessLevel] = useState<"low" | "medium" | "high">("medium");
  const [blockedTopics, setBlockedTopics] = useState<string[]>([
    "violence",
    "inappropriate content",
    "scary stories",
  ]);
  const [allowedTopics, setAllowedTopics] = useState<string[]>([
    "education",
    "creativity",
    "friendship",
    "nature",
  ]);
  const [newBlockedTopic, setNewBlockedTopic] = useState("");
  const [newAllowedTopic, setNewAllowedTopic] = useState("");

  // Time Controls State
  const [dailyLimit, setDailyLimit] = useState([90]); // minutes
  const [timeRestrictions, setTimeRestrictions] = useState<TimeRestriction[]>([
    { id: "1", dayType: "weekday", startTime: "07:00", endTime: "20:00" },
    { id: "2", dayType: "weekend", startTime: "08:00", endTime: "21:00" },
  ]);
  const [schoolDayRules, setSchoolDayRules] = useState(true);
  const [weekendRules, setWeekendRules] = useState(true);

  // Notification Preferences
  const [realTimeAlerts, setRealTimeAlerts] = useState(true);
  const [dailySummary, setDailySummary] = useState(true);
  const [weeklyReport, setWeeklyReport] = useState(false);
  const [severityThreshold, setSeverityThreshold] = useState<"all" | "medium" | "high">("medium");

  const handleAddBlockedTopic = () => {
    if (newBlockedTopic.trim()) {
      setBlockedTopics([...blockedTopics, newBlockedTopic.trim()]);
      setNewBlockedTopic("");
    }
  };

  const handleAddAllowedTopic = () => {
    if (newAllowedTopic.trim()) {
      setAllowedTopics([...allowedTopics, newAllowedTopic.trim()]);
      setNewAllowedTopic("");
    }
  };

  const handleRemoveBlockedTopic = (topic: string) => {
    setBlockedTopics(blockedTopics.filter(t => t !== topic));
  };

  const handleRemoveAllowedTopic = (topic: string) => {
    setAllowedTopics(allowedTopics.filter(t => t !== topic));
  };

  const handleSaveSettings = () => {
    console.log("Saving safety settings:", {
      contentFilters: { strictnessLevel, blockedTopics, allowedTopics },
      timeControls: { dailyLimit: dailyLimit[0], timeRestrictions, schoolDayRules, weekendRules },
      notifications: { realTimeAlerts, dailySummary, weeklyReport, severityThreshold },
    });
    // In production, this would save to Convex
  };

  return (
    <div className="space-y-6">
      {/* Content Filtering */}
      <Card 
        bg="#ffffff"
        borderColor="black"
        shadowColor="#c381b5"
        className="p-4 sm:p-6 hover-lift"
      >
        <div className="flex items-center gap-2 mb-4">
          <Filter className="w-5 h-5 text-blue-600" />
          <h3 className="retro-h3 text-base sm:text-lg text-black">
             Content Filtering
          </h3>
        </div>

        <div className="space-y-6">
          {/* Strictness Level */}
          <div>
            <label className="block text-sm font-black uppercase tracking-wider text-black mb-2">
              Content Filter Strictness
            </label>
            <Select value={strictnessLevel} onValueChange={(value) => setStrictnessLevel(value as "low" | "medium" | "high")}>
              <SelectTrigger className="w-full border-2 border-black font-bold">
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="low">
                  <div>
                    <p className="font-bold text-black">Low</p>
                    <p className="text-sm text-gray-500">Basic filtering for obvious inappropriate content</p>
                  </div>
                </SelectItem>
                <SelectItem value="medium">
                  <div>
                    <p className="font-bold text-black">Medium</p>
                    <p className="text-sm text-gray-500">Balanced filtering for age-appropriate content</p>
                  </div>
                </SelectItem>
                <SelectItem value="high">
                  <div>
                    <p className="font-bold text-black">High</p>
                    <p className="text-sm text-gray-500">Strict filtering with maximum protection</p>
                  </div>
                </SelectItem>
              </SelectContent>
            </Select>
          </div>

          {/* Blocked Topics */}
          <div>
            <label className="block text-sm font-black uppercase tracking-wider text-black mb-2">
               Blocked Topics
            </label>
            <div className="flex gap-2 mb-3">
              <Input
                placeholder="Add blocked topic..."
                value={newBlockedTopic}
                onChange={(e: ChangeEvent<HTMLInputElement>) => setNewBlockedTopic(e.target.value)}
                onKeyPress={(e: KeyboardEvent<HTMLInputElement>) => e.key === "Enter" && handleAddBlockedTopic()}
                bg="#ffffff"
                borderColor="black"
                className="font-bold flex-1"
              />
              <Button
                bg={newBlockedTopic.trim() ? "#ff6b6b" : "#f0f0f0"}
                textColor={newBlockedTopic.trim() ? "white" : "#999"}
                borderColor="black"
                shadow={newBlockedTopic.trim() ? "#e84545" : "#d0d0d0"}
                onClick={handleAddBlockedTopic}
                disabled={!newBlockedTopic.trim()}
                className={`py-2 px-3 font-bold ${newBlockedTopic.trim() ? 'hover-lift' : 'cursor-not-allowed'}`}
              >
                <Plus className="w-4 h-4" />
              </Button>
            </div>
            <div className="flex flex-wrap gap-2">
              {blockedTopics.map((topic) => (
                <span key={topic} className="px-2 py-1 text-xs font-black uppercase tracking-wider border-2 border-red-600 bg-red-100 text-red-800 flex items-center gap-2">
                  {topic}
                  <button
                    onClick={() => handleRemoveBlockedTopic(topic)}
                    className="hover:text-red-600 transition-colors"
                  >
                    <X className="w-3 h-3" />
                  </button>
                </span>
              ))}
            </div>
          </div>

          {/* Allowed Topics */}
          <div>
            <label className="block text-sm font-black uppercase tracking-wider text-black mb-2">
               Encouraged Topics
            </label>
            <div className="flex gap-2 mb-3">
              <Input
                placeholder="Add encouraged topic..."
                value={newAllowedTopic}
                onChange={(e: ChangeEvent<HTMLInputElement>) => setNewAllowedTopic(e.target.value)}
                onKeyPress={(e: KeyboardEvent<HTMLInputElement>) => e.key === "Enter" && handleAddAllowedTopic()}
                bg="#ffffff"
                borderColor="black"
                className="font-bold flex-1"
              />
              <Button
                bg={newAllowedTopic.trim() ? "#92cd41" : "#f0f0f0"}
                textColor={newAllowedTopic.trim() ? "white" : "#999"}
                borderColor="black"
                shadow={newAllowedTopic.trim() ? "#76a83a" : "#d0d0d0"}
                onClick={handleAddAllowedTopic}
                disabled={!newAllowedTopic.trim()}
                className={`py-2 px-3 font-bold ${newAllowedTopic.trim() ? 'hover-lift' : 'cursor-not-allowed'}`}
              >
                <Plus className="w-4 h-4" />
              </Button>
            </div>
            <div className="flex flex-wrap gap-2">
              {allowedTopics.map((topic) => (
                <span key={topic} className="px-2 py-1 text-xs font-black uppercase tracking-wider border-2 border-green-600 bg-green-100 text-green-800 flex items-center gap-2">
                  {topic}
                  <button
                    onClick={() => handleRemoveAllowedTopic(topic)}
                    className="hover:text-green-600 transition-colors"
                  >
                    <X className="w-3 h-3" />
                  </button>
                </span>
              ))}
            </div>
          </div>
        </div>
      </Card>

      {/* Time Controls */}
      <Card 
        bg="#ffffff"
        borderColor="black"
        shadowColor="#92cd41"
        className="p-4 sm:p-6 hover-lift"
      >
        <div className="flex items-center gap-2 mb-4">
          <Clock className="w-5 h-5 text-green-600" />
          <h3 className="retro-h3 text-base sm:text-lg text-black retro-shadow-green">
             Time Controls
          </h3>
        </div>

        <div className="space-y-6">
          {/* Daily Limit */}
          <div>
            <div className="flex justify-between mb-2">
              <label className="text-sm font-black uppercase tracking-wider text-black">Daily Usage Limit</label>
              <span className="text-sm font-black text-black">{dailyLimit[0]} minutes</span>
            </div>
            <Slider
              value={dailyLimit}
              onValueChange={setDailyLimit}
              min={30}
              max={240}
              step={15}
              className="w-full"
            />
            <div className="flex justify-between mt-1 text-xs font-bold uppercase tracking-wide text-gray-500">
              <span>30 min</span>
              <span>4 hours</span>
            </div>
          </div>

          {/* School Day Rules */}
          <div className="flex items-center justify-between">
            <div>
              <label htmlFor="school-rules" className="text-sm font-black uppercase tracking-wider text-black">
                 School Day Restrictions
              </label>
              <p className="text-sm font-bold text-gray-600">
                Limit access during school hours on weekdays
              </p>
            </div>
            <Switch
              id="school-rules"
              checked={schoolDayRules}
              onCheckedChange={setSchoolDayRules}
            />
          </div>

          {/* Weekend Rules */}
          <div className="flex items-center justify-between">
            <div>
              <label htmlFor="weekend-rules" className="text-sm font-black uppercase tracking-wider text-black">
                 Weekend Extended Hours
              </label>
              <p className="text-sm font-bold text-gray-600">
                Allow extra time on weekends
              </p>
            </div>
            <Switch
              id="weekend-rules"
              checked={weekendRules}
              onCheckedChange={setWeekendRules}
            />
          </div>

          {/* Time Restrictions */}
          <div>
            <label className="block text-sm font-black uppercase tracking-wider text-black mb-2">
               Allowed Hours
            </label>
            <div className="space-y-2">
              {timeRestrictions.map((restriction) => (
                <Card
                  key={restriction.id}
                  bg="#f8f8f8"
                  borderColor="black"
                  shadowColor="#e0e0e0"
                  className="flex items-center gap-2 p-3"
                >
                  <span className="px-2 py-1 text-xs font-black uppercase tracking-wider border border-black bg-[#fefcd0] text-black">
                    {restriction.dayType === "weekday" ? "Weekdays" : "Weekends"}
                  </span>
                  <span className="text-sm font-bold text-black">
                    {restriction.startTime} - {restriction.endTime}
                  </span>
                </Card>
              ))}
            </div>
          </div>
        </div>
      </Card>

      {/* Notification Preferences */}
      <Card 
        bg="#ffffff"
        borderColor="black"
        shadowColor="#f7931e"
        className="p-4 sm:p-6 hover-lift"
      >
        <div className="flex items-center gap-2 mb-4">
          <Bell className="w-5 h-5 text-purple-600" />
          <h3 className="retro-h3 text-base sm:text-lg text-black retro-shadow-orange">
             Notification Preferences
          </h3>
        </div>

        <div className="space-y-4">
          <div className="flex items-center justify-between">
            <div>
              <label htmlFor="real-time" className="text-sm font-black uppercase tracking-wider text-black">
                 Real-time Alerts
              </label>
              <p className="text-sm font-bold text-gray-600">
                Get instant notifications for safety concerns
              </p>
            </div>
            <Switch
              id="real-time"
              checked={realTimeAlerts}
              onCheckedChange={setRealTimeAlerts}
            />
          </div>

          <div className="flex items-center justify-between">
            <div>
              <label htmlFor="daily-summary" className="text-sm font-black uppercase tracking-wider text-black">
                 Daily Summary
              </label>
              <p className="text-sm font-bold text-gray-600">
                Receive a daily report of your child&apos;s activity
              </p>
            </div>
            <Switch
              id="daily-summary"
              checked={dailySummary}
              onCheckedChange={setDailySummary}
            />
          </div>

          <div className="flex items-center justify-between">
            <div>
              <label htmlFor="weekly-report" className="text-sm font-black uppercase tracking-wider text-black">
                 Weekly Report
              </label>
              <p className="text-sm font-bold text-gray-600">
                Get detailed weekly analytics and insights
              </p>
            </div>
            <Switch
              id="weekly-report"
              checked={weeklyReport}
              onCheckedChange={setWeeklyReport}
            />
          </div>

          <div>
            <label className="block text-sm font-black uppercase tracking-wider text-black mb-2">
               Alert Severity Threshold
            </label>
            <Select value={severityThreshold} onValueChange={(value) => setSeverityThreshold(value as "all" | "medium" | "high")}>
              <SelectTrigger className="border-2 border-black font-bold">
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">All Alerts</SelectItem>
                <SelectItem value="medium">Medium & High Priority</SelectItem>
                <SelectItem value="high">High Priority Only</SelectItem>
              </SelectContent>
            </Select>
          </div>
        </div>
      </Card>

      {/* Save Button */}
      <div className="flex justify-end gap-3">
        <Button
          bg="#f0f0f0"
          textColor="black"
          borderColor="black"
          shadow="#d0d0d0"
          className="py-2 px-4 font-bold uppercase tracking-wider hover-lift"
        >
          Reset to Defaults
        </Button>
        <Button
          bg="#92cd41"
          textColor="white"
          borderColor="black"
          shadow="#76a83a"
          onClick={handleSaveSettings}
          className="py-2 px-4 font-bold uppercase tracking-wider hover-lift flex items-center gap-2"
        >
          <Save className="w-4 h-4" />
          Save Settings
        </Button>
      </div>

      {/* Info Box */}
      <Card
        bg="#e3f2fd"
        borderColor="blue"
        shadowColor="#2196f3"
        className="p-4"
      >
        <div className="flex items-center gap-2">
          <AlertCircle className="h-4 w-4 text-blue-600" />
          <p className="text-sm font-bold text-blue-800 uppercase tracking-wide">
             These settings apply to all toys assigned to this child. Changes take effect immediately.
          </p>
        </div>
      </Card>
    </div>
  );
}
</file>

<file path="src/components/history/ConversationAnalytics.tsx">
'use client';

import { Card } from '@pommai/ui';
import { 
  BarChart, 
  Bar, 
  LineChart, 
  Line,
  PieChart, 
  Pie, 
  Cell,
  XAxis, 
  YAxis, 
  CartesianGrid, 
  Tooltip, 
  ResponsiveContainer,
  Legend
} from 'recharts';
import { 
  MessageSquare, 
  Clock, 
  TrendingUp, 
  AlertCircle,
  Smile,
  Calendar
} from 'lucide-react';
import { ConversationAnalytics as AnalyticsType } from '@/types/history';

interface ConversationAnalyticsProps {
  analytics: AnalyticsType | null | undefined;
  isLoading: boolean;
}

export function ConversationAnalytics({ analytics, isLoading }: ConversationAnalyticsProps) {
  if (isLoading) {
    return (
      <div className="space-y-4">
        {[1, 2, 3, 4].map((i) => (
          <Card 
            key={i} 
            bg="#f8f8f8"
            borderColor="black"
            shadowColor="#e0e0e0"
            className="p-4"
          >
            <div className="h-8 w-32 mb-4 bg-gray-300 border-2 border-black animate-pulse"></div>
            <div className="h-32 w-full bg-gray-200 border-2 border-black animate-pulse"></div>
          </Card>
        ))}
      </div>
    );
  }

  if (!analytics) {
    return null;
  }

  const sentimentData = [
    { 
      name: 'Positive', 
      value: analytics.sentimentBreakdown.positive, 
      color: '#10b981',
      icon: ''
    },
    { 
      name: 'Neutral', 
      value: analytics.sentimentBreakdown.neutral, 
      color: '#6b7280',
      icon: ''
    },
    { 
      name: 'Negative', 
      value: analytics.sentimentBreakdown.negative, 
      color: '#ef4444',
      icon: ''
    },
  ];

  const formatDuration = (ms: number) => {
    const minutes = Math.floor(ms / (60 * 1000));
    return `${minutes} min`;
  };

  return (
    <div className="space-y-4">
      {/* Summary Stats */}
      <div className="grid grid-cols-2 gap-3">
        <Card 
          bg="#ffffff"
          borderColor="black"
          shadowColor="#c381b5"
          className="p-4 hover-lift"
        >
          <div className="flex items-center justify-between mb-2">
            <MessageSquare className="w-5 h-5 text-purple-600" />
            <span className="text-2xl font-black text-black">{analytics.totalConversations}</span>
          </div>
          <p className="text-sm font-bold uppercase tracking-wide text-gray-700">Total Conversations</p>
        </Card>
        
        <Card 
          bg="#ffffff"
          borderColor="black"
          shadowColor="#92cd41"
          className="p-4 hover-lift"
        >
          <div className="flex items-center justify-between mb-2">
            <Clock className="w-5 h-5 text-blue-600" />
            <span className="text-2xl font-black text-black">{formatDuration(analytics.averageDuration)}</span>
          </div>
          <p className="text-sm font-bold uppercase tracking-wide text-gray-700">Avg Duration</p>
        </Card>
        
        <Card 
          bg="#ffffff"
          borderColor="black"
          shadowColor="#f7931e"
          className="p-4 hover-lift"
        >
          <div className="flex items-center justify-between mb-2">
            <MessageSquare className="w-5 h-5 text-green-600" />
            <span className="text-2xl font-black text-black">{analytics.totalMessages}</span>
          </div>
          <p className="text-sm font-bold uppercase tracking-wide text-gray-700">Total Messages</p>
        </Card>
        
        <Card 
          bg="#ffffff"
          borderColor="black"
          shadowColor="#fefcd0"
          className="p-4 hover-lift"
        >
          <div className="flex items-center justify-between mb-2">
            <AlertCircle className="w-5 h-5 text-orange-600" />
            <span className="text-2xl font-black text-black">{analytics.flaggedMessageCount}</span>
          </div>
          <p className="text-sm font-bold uppercase tracking-wide text-gray-700">Flagged</p>
        </Card>
      </div>

      {/* Sentiment Distribution */}
      <Card 
        bg="#ffffff"
        borderColor="black"
        shadowColor="#c381b5"
        className="p-4 hover-lift"
      >
        <h3 className="font-black text-lg uppercase tracking-wider text-black mb-4 flex items-center gap-2">
          <Smile className="w-5 h-5" />
           Sentiment Distribution
        </h3>
        <div className="h-48">
          <ResponsiveContainer width="100%" height="100%">
            <PieChart>
              <Pie
                data={sentimentData}
                cx="50%"
                cy="50%"
                labelLine={false}
                label={({ name, percent, icon }) => `${icon} ${((percent || 0) * 100).toFixed(0)}%`}
                outerRadius={70}
                fill="#8884d8"
                dataKey="value"
              >
                {sentimentData.map((entry, index) => (
                  <Cell key={`cell-${index}`} fill={entry.color} />
                ))}
              </Pie>
              <Tooltip />
            </PieChart>
          </ResponsiveContainer>
        </div>
        <div className="mt-4 flex justify-center gap-4">
          {sentimentData.map((item) => (
            <div key={item.name} className="flex items-center gap-2">
              <div 
                className="w-3 h-3 border border-black" 
                style={{ backgroundColor: item.color }}
              />
              <span className="text-sm font-bold uppercase tracking-wide text-gray-700">{item.name}</span>
            </div>
          ))}
        </div>
      </Card>

      {/* Conversations Over Time */}
      {analytics.conversationsByDay.length > 0 && (
        <Card 
          bg="#ffffff"
          borderColor="black"
          shadowColor="#92cd41"
          className="p-4 hover-lift"
        >
          <h3 className="font-black text-lg uppercase tracking-wider text-black mb-4 flex items-center gap-2">
            <Calendar className="w-5 h-5" />
             Activity Trend
          </h3>
          <div className="h-48">
            <ResponsiveContainer width="100%" height="100%">
              <LineChart data={analytics.conversationsByDay}>
                <CartesianGrid strokeDasharray="3 3" stroke="#e5e7eb" />
                <XAxis 
                  dataKey="date" 
                  tick={{ fontSize: 12 }}
                  tickFormatter={(date) => {
                    const d = new Date(date);
                    return `${d.getMonth() + 1}/${d.getDate()}`;
                  }}
                />
                <YAxis tick={{ fontSize: 12 }} />
                <Tooltip 
                  labelFormatter={(date) => new Date(date).toLocaleDateString()}
                />
                <Line 
                  type="monotone" 
                  dataKey="count" 
                  stroke="#8b5cf6" 
                  strokeWidth={2}
                  dot={{ fill: '#8b5cf6', r: 4 }}
                  name="Conversations"
                />
              </LineChart>
            </ResponsiveContainer>
          </div>
        </Card>
      )}

      {/* Top Topics */}
      {analytics.topTopics && analytics.topTopics.length > 0 && (
        <Card 
          bg="#ffffff"
          borderColor="black"
          shadowColor="#f7931e"
          className="p-4 hover-lift"
        >
          <h3 className="font-black text-lg uppercase tracking-wider text-black mb-4 flex items-center gap-2">
            <TrendingUp className="w-5 h-5" />
             Top Topics
          </h3>
          <div className="space-y-2">
            {analytics.topTopics.slice(0, 5).map((topic, i) => (
              <div key={i} className="flex items-center justify-between">
                <span className="px-2 py-1 text-xs font-black uppercase tracking-wider border border-black bg-[#c381b5] text-white">
                  {topic.topic}
                </span>
                <span className="text-sm font-bold text-gray-700">{topic.count}</span>
              </div>
            ))}
          </div>
        </Card>
      )}
    </div>
  );
}
</file>

<file path="src/components/history/ConversationDetails.tsx">
'use client';

import { useQuery } from 'convex/react';
import { api } from '../../../convex/_generated/api';
import { Id } from '../../../convex/_generated/dataModel';
import { Popup, Button, Card } from '@pommai/ui';
import { format } from 'date-fns';
import { 
  X, 
  Download, 
  Flag, 
  MessageSquare,
  User,
  Bot,
  AlertCircle,
  Clock,
  Calendar
} from 'lucide-react';

interface ConversationDetailsProps {
  conversationId: string;
  onClose: () => void;
  isGuardianMode?: boolean;
}

export function ConversationDetails({ 
  conversationId, 
  onClose,
  isGuardianMode = false 
}: ConversationDetailsProps) {
  const conversation = useQuery(
    api.conversations.getConversationWithMessages,
    { conversationId: conversationId as Id<"conversations"> }
  );

  if (!conversation) {
    return (
      <Popup
        isOpen={true}
        title="Loading Conversation..."
        onClose={onClose}
      >
        <div className="space-y-4 p-6 max-w-3xl h-[80vh]">
          {[1, 2, 3, 4].map((i) => (
            <div key={i} className="space-y-2">
              <div className="h-4 w-24 bg-gray-300 border-2 border-black animate-pulse"></div>
              <div className="h-16 w-full bg-gray-200 border-2 border-black animate-pulse"></div>
            </div>
          ))}
        </div>
      </Popup>
    );
  }

  const handleExportTranscript = () => {
    const transcript = conversation.messages
      .map((msg: { timestamp: number | string | Date; role: string; content: string }) => `[${format(new Date(msg.timestamp), 'HH:mm:ss')}] ${msg.role === 'user' ? 'User' : conversation.toy?.name || 'Toy'}: ${msg.content}`)
      .join('\n');
    
    const blob = new Blob([transcript], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `conversation-${conversationId}-${new Date().toISOString().split('T')[0]}.txt`;
    a.click();
    URL.revokeObjectURL(url);
  };

  const getToyAvatar = () => {
    const avatarMap: Record<string, string> = {
      teddy: '',
      bunny: '',
      cat: '',
      dog: '',
      bird: '',
      fish: '',
      robot: '',
      magical: '',
    };
    return avatarMap[conversation.toy?.type || ''] || '';
  };

  const duration = conversation.endTime 
    ? Number(conversation.endTime) - Number(conversation.startTime)
    : Date.now() - Number(conversation.startTime);
  const durationMinutes = Math.floor(duration / (60 * 1000));

  return (
    <Popup
      isOpen={true}
      title={` Conversation with ${conversation.toy?.name}`}
      onClose={onClose}
    >
      <div className="flex flex-col h-full max-w-3xl min-h-[80vh]">
        {/* Header with metadata */}
        <Card
          bg="#ffffff"
          borderColor="black"
          shadowColor="#c381b5"
          className="p-4 mb-4"
        >
          <div className="flex items-start justify-between mb-4">
            <div className="flex-1">
              <div className="flex items-center gap-4 text-sm font-bold text-gray-700 uppercase tracking-wide">
                <span className="flex items-center gap-1">
                  <Calendar className="w-4 h-4" />
                  {format(new Date(conversation.startTime), 'MMMM d, yyyy')}
                </span>
                <span className="flex items-center gap-1">
                  <Clock className="w-4 h-4" />
                  {format(new Date(conversation.startTime), 'h:mm a')} - 
                  {conversation.endTime && format(new Date(conversation.endTime), 'h:mm a')}
                  {' '}({durationMinutes} min)
                </span>
                <span className="flex items-center gap-1">
                  <MessageSquare className="w-4 h-4" />
                  {conversation.messages.length} messages
                </span>
              </div>
            </div>
            <Button
              bg="#f0f0f0"
              textColor="black"
              borderColor="black"
              shadow="#d0d0d0"
              onClick={handleExportTranscript}
              className="py-2 px-3 font-bold uppercase tracking-wider hover-lift"
            >
              <Download className="w-4 h-4 mr-2" />
              Export
            </Button>
          </div>
        </Card>

        {/* Messages Container */}
        <div className="flex-1 h-[400px] overflow-y-auto border-2 border-black bg-[#fefcd0] p-4">
          <div className="space-y-4">
            {conversation.messages.map((message) => (
              <div
                key={message._id}
                className={`flex gap-3 ${
                  message.role === 'user' ? 'justify-end' : 'justify-start'
                }`}
              >
                {message.role !== 'user' && (
                  <div className="w-8 h-8 bg-purple-100 border-2 border-black flex items-center justify-center text-lg">
                    {getToyAvatar()}
                  </div>
                )}
                
                <div className={`max-w-[70%] ${message.role === 'user' ? 'order-first' : ''}`}>
                  <Card
                    bg={message.role === 'user' ? '#c381b5' : '#ffffff'}
                    borderColor="black"
                    shadowColor={message.role === 'user' ? '#8b5fa3' : '#e0e0e0'}
                    className="p-3"
                  >
                    <p className={`text-sm font-bold ${
                      message.role === 'user' ? 'text-white' : 'text-black'
                    }`}>
                      {message.content}
                    </p>
                  </Card>
                  
                  <div className="flex items-center gap-2 mt-1 text-xs">
                    <span className="font-bold text-gray-700">
                      {format(new Date(message.timestamp), 'HH:mm:ss')}
                    </span>
                    {message.metadata?.flagged && (
                      <span className="px-2 py-1 text-xs font-black uppercase tracking-wider border border-red-600 bg-red-100 text-red-800 flex items-center gap-1">
                        <AlertCircle className="w-3 h-3" />
                        Flagged
                      </span>
                    )}
                    {isGuardianMode && message.metadata?.sentiment && (
                      <span className="px-2 py-1 text-xs font-black uppercase tracking-wider border border-gray-600 bg-gray-100 text-gray-800">
                        {message.metadata.sentiment}
                      </span>
                    )}
                    {isGuardianMode && message.metadata?.safetyScore !== undefined && (
                      <span 
                        className={`px-2 py-1 text-xs font-black uppercase tracking-wider border ${
                          message.metadata.safetyScore > 0.8 
                            ? 'border-green-600 bg-green-100 text-green-800' 
                            : 'border-red-600 bg-red-100 text-red-800'
                        }`}
                      >
                        Safety: {(message.metadata.safetyScore * 100).toFixed(0)}%
                      </span>
                    )}
                  </div>
                </div>
                
                {message.role === 'user' && (
                  <div className="w-8 h-8 bg-blue-100 border-2 border-black flex items-center justify-center">
                    <User className="w-4 h-4" />
                  </div>
                )}
              </div>
            ))}
          </div>
        </div>

        {/* Guardian Mode Footer */}
        {isGuardianMode && (
          <Card
            bg="#ffffff"
            borderColor="black"
            shadowColor="#f7931e"
            className="p-4 mt-4"
          >
            <div className="flex items-center justify-between">
              <p className="text-sm font-bold text-gray-700 uppercase tracking-wide">
                 Guardian Mode: Full conversation access enabled
              </p>
              <Button
                bg="#f7931e"
                textColor="white"
                borderColor="black"
                shadow="#d67c1a"
                className="py-2 px-3 font-bold uppercase tracking-wider hover-lift"
              >
                <Flag className="w-4 h-4 mr-2" />
                Report Conversation
              </Button>
            </div>
          </Card>
        )}
      </div>
    </Popup>
  );
}
</file>

<file path="src/components/history/ConversationList.tsx">
'use client';

import { Card } from '@pommai/ui';
import { format, isToday, isYesterday } from 'date-fns';
import { 
  MessageSquare, 
  Clock, 
  AlertCircle,
  Smile,
  Frown,
  Meh,
  ChevronRight
} from 'lucide-react';

interface ConversationItem {
  _id: string;
  toyName: string;
  startedAt: string | number | Date;
  duration?: number;
  messageCount: number;
  flaggedMessageCount: number;
  topics?: string[];
  sentiment: 'positive' | 'neutral' | 'negative' | string;
}

interface ConversationListProps {
  conversations: ConversationItem[];
  selectedId: string | null;
  onSelect: (id: string) => void;
  isLoading: boolean;
}

export function ConversationList({ 
  conversations, 
  selectedId, 
  onSelect, 
  isLoading 
}: ConversationListProps) {
  if (isLoading) {
    return (
      <Card 
        bg="#ffffff"
        borderColor="black"
        shadowColor="#e0e0e0"
        className="p-4"
      >
        <div className="space-y-4">
          {[1, 2, 3, 4].map((i) => (
            <div key={i} className="space-y-2">
              <div className="h-4 w-32 bg-gray-300 border-2 border-black animate-pulse"></div>
              <div className="h-20 w-full bg-gray-200 border-2 border-black animate-pulse"></div>
            </div>
          ))}
        </div>
      </Card>
    );
  }

  if (conversations.length === 0) {
    return (
      <Card 
        bg="#ffffff"
        borderColor="black"
        shadowColor="#c381b5"
        className="p-8 text-center hover-lift"
      >
        <MessageSquare className="w-12 h-12 mx-auto text-gray-400 mb-4" />
        <h3 className="retro-h3 text-base sm:text-lg text-black mb-2">No conversations found</h3>
        <p className="font-bold text-gray-700 uppercase tracking-wide">
          Try adjusting your filters or search criteria
        </p>
      </Card>
    );
  }

  // Group conversations by date
  const groupedConversations = conversations.reduce((groups: Record<string, ConversationItem[]>, conv: ConversationItem) => {
    const date = new Date(conv.startedAt);
    let dateKey: string;
    
    if (isToday(date)) {
      dateKey = 'Today';
    } else if (isYesterday(date)) {
      dateKey = 'Yesterday';
    } else {
      dateKey = format(date, 'MMMM d, yyyy');
    }
    
    if (!groups[dateKey]) {
      groups[dateKey] = [];
    }
    groups[dateKey].push(conv);
    return groups;
  }, {} as Record<string, ConversationItem[]>);

  const getSentimentIcon = (sentiment: string) => {
    switch (sentiment) {
      case 'positive':
        return <Smile className="w-4 h-4 text-green-500" />;
      case 'negative':
        return <Frown className="w-4 h-4 text-red-500" />;
      default:
        return <Meh className="w-4 h-4 text-gray-500" />;
    }
  };

  const formatDuration = (duration: number) => {
    const minutes = Math.floor(duration / (60 * 1000));
    const seconds = Math.floor((duration % (60 * 1000)) / 1000);
    return `${minutes}:${seconds.toString().padStart(2, '0')}`;
  };

  return (
    <Card 
      bg="#ffffff"
      borderColor="black"
      shadowColor="#c381b5"
      className="overflow-hidden hover-lift"
    >
      <div className="h-[600px] overflow-y-auto border-2 border-black bg-[#fefcd0]">
        <div className="p-4 space-y-6">
          {Object.entries(groupedConversations).map(([date, convs]) => (
            <div key={date}>
              <h3 className="retro-h3 text-sm text-black mb-3">
                 {date}
              </h3>
              <div className="space-y-2">
                {convs.map((conv) => (
                  <Card
                    key={conv._id}
                    bg={selectedId === conv._id ? "#c381b5" : "#ffffff"}
                    borderColor="black"
                    shadowColor={selectedId === conv._id ? "#8b5fa3" : "#e0e0e0"}
                    className={`p-4 cursor-pointer transition-all hover-lift ${
                      selectedId === conv._id 
                        ? 'text-white' 
                        : 'text-black hover:shadow-[0_4px_0_2px_#c381b5]'
                    }`}
                    onClick={() => onSelect(conv._id)}
                  >
                    <div className="flex items-start justify-between">
                      <div className="flex-1">
                        <div className="flex items-center gap-2 mb-1">
                          <h4 className="font-black uppercase tracking-wider text-inherit">
                            {conv.toyName}
                          </h4>
                          {conv.flaggedMessageCount > 0 && (
                            <span className="px-2 py-1 text-xs font-black uppercase tracking-wider border border-red-600 bg-red-100 text-red-800 flex items-center gap-1">
                              <AlertCircle className="w-3 h-3" />
                              {conv.flaggedMessageCount} flagged
                            </span>
                          )}
                        </div>
                        
                        <div className={`flex items-center gap-4 text-sm font-bold ${
                          selectedId === conv._id ? 'text-white opacity-90' : 'text-gray-700'
                        }`}>
                          <span className="flex items-center gap-1">
                            <Clock className="w-3 h-3" />
                            {format(new Date(conv.startedAt), 'h:mm a')}
                          </span>
                          {(() => {
                            const durationMs = typeof conv.duration === 'number' ? conv.duration : 0;
                            return durationMs > 0 ? (
                              <span className="flex items-center gap-1">
                                Duration: {formatDuration(durationMs)}
                              </span>
                            ) : null;
                          })()}
                          <span className="flex items-center gap-1">
                            <MessageSquare className="w-3 h-3" />
                            {conv.messageCount} messages
                          </span>
                        </div>
                      </div>
                      
                      <div className="flex items-center gap-2">
                        {getSentimentIcon(conv.sentiment)}
                        <ChevronRight className="w-4 h-4 text-gray-400" />
                      </div>
                    </div>
                    
                    {conv.topics && conv.topics.length > 0 && (
                      <div className="mt-2 flex flex-wrap gap-1">
                        {conv.topics.slice(0, 3).map((topic: string, i: number) => (
                          <span key={i} className="px-2 py-1 text-xs font-black uppercase tracking-wider border border-black bg-[#92cd41] text-white">
                            {topic}
                          </span>
                        ))}
                        {conv.topics.length > 3 && (
                          <span className="px-2 py-1 text-xs font-black uppercase tracking-wider border border-black bg-[#f7931e] text-white">
                            +{conv.topics.length - 3} more
                          </span>
                        )}
                      </div>
                    )}
                  </Card>
                ))}
              </div>
            </div>
          ))}
        </div>
      </div>
    </Card>
  );
}
</file>

<file path="src/components/history/ConversationViewer.tsx">
'use client';

import { useState, useEffect, type ChangeEvent } from 'react';
import { useQuery } from 'convex/react';
import { api } from '../../../convex/_generated/api';
import { Id } from '../../../convex/_generated/dataModel';
import { Card, Button, Input } from '@pommai/ui';
import Calendar from 'react-calendar';
import { format, subDays, startOfDay, endOfDay } from 'date-fns';
import { 
  Search, 
  Filter, 
  Calendar as CalendarIcon,
  AlertCircle,
  Download,
  ChevronDown,
  ChevronUp,
  Smile,
  Frown,
  Meh
} from 'lucide-react';
import { ConversationAnalytics } from './ConversationAnalytics';
import { ConversationList } from './ConversationList';
import { ConversationDetails } from './ConversationDetails';
import { ConversationFilters } from '@/types/history';
import 'react-calendar/dist/Calendar.css';

interface ConversationViewerProps {
  toyId?: string;
  isGuardianMode?: boolean;
}

export function ConversationViewer({ toyId, isGuardianMode = false }: ConversationViewerProps) {
  const [selectedConversationId, setSelectedConversationId] = useState<string | null>(null);
  const [showFilters, setShowFilters] = useState(false);
  const [timelineView, setTimelineView] = useState<'day' | 'week' | 'month'>('week');
  const [searchQuery, setSearchQuery] = useState('');
  const [showCalendar, setShowCalendar] = useState(false);
  
  // Filter states
  const [filters, setFilters] = useState<ConversationFilters>({
    toyId,
    searchQuery: '',
    sentiment: [],
    hasFlaggedMessages: undefined,
  });

  const [dateRange, setDateRange] = useState<[Date | null, Date | null]>([
    subDays(new Date(), 7),
    new Date()
  ]);

  // Update filters when search or date changes
  useEffect(() => {
    setFilters(prev => ({
      ...prev,
      searchQuery,
      dateFrom: dateRange[0] ? startOfDay(dateRange[0]).getTime() : undefined,
      dateTo: dateRange[1] ? endOfDay(dateRange[1]).getTime() : undefined,
    }));
  }, [searchQuery, dateRange]);

  // Fetch conversations with filters
  const conversations = useQuery(
    api.conversations.getFilteredConversationHistory,
    {
      toyId: (filters.toyId as unknown as Id<"toys"> | undefined),
      sentiment: filters.sentiment,
      dateFrom: filters.dateFrom,
      dateTo: filters.dateTo,
      hasFlaggedMessages: filters.hasFlaggedMessages,
      searchQuery: filters.searchQuery,
    }
  );

  // Fetch analytics
  const analytics = useQuery(
    api.conversations.getConversationAnalytics,
    {
      toyId: (toyId as unknown as Id<"toys"> | undefined),
      dateFrom: filters.dateFrom,
      dateTo: filters.dateTo,
    }
  );

  const handleSentimentToggle = (sentiment: 'positive' | 'neutral' | 'negative') => {
    setFilters(prev => {
      const current = prev.sentiment || [];
      const updated = current.includes(sentiment)
        ? current.filter(s => s !== sentiment)
        : [...current, sentiment];
      return { ...prev, sentiment: updated };
    });
  };

  const handleFlaggedToggle = () => {
    setFilters(prev => ({
      ...prev,
      hasFlaggedMessages: prev.hasFlaggedMessages === true ? undefined : true
    }));
  };

  const handleExport = (format: 'pdf' | 'csv' | 'json') => {
    // TODO: Implement export functionality
    console.log('Exporting as', format);
  };

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between flex-wrap gap-4">
        <h2 className="text-2xl font-black uppercase tracking-wider text-black">
           Conversation History
        </h2>
        <div className="flex items-center gap-2 flex-wrap">
          {/* Timeline View Tabs */}
          <div className="flex bg-gray-100 border-2 border-black">
            {(['day', 'week', 'month'] as const).map((view) => (
              <Button
                key={view}
                bg={timelineView === view ? '#c381b5' : 'transparent'}
                textColor={timelineView === view ? 'white' : 'black'}
                borderColor="transparent"
                className={`px-4 py-2 font-bold uppercase tracking-wider border-r border-black last:border-r-0 ${
                  timelineView === view ? '' : 'hover:bg-gray-200'
                }`}
                onClick={() => setTimelineView(view)}
              >
                {view.charAt(0).toUpperCase() + view.slice(1)}
              </Button>
            ))}
          </div>
          
          {/* Export Buttons */}
          <div className="flex gap-1">
            {['pdf', 'csv'].map((format) => (
              <Button
                key={format}
                bg="#f0f0f0"
                textColor="black"
                borderColor="black"
                shadow="#d0d0d0"
                onClick={() => handleExport(format as 'pdf' | 'csv')}
                className="py-2 px-3 font-bold uppercase tracking-wider hover-lift"
              >
                <Download className="w-4 h-4 mr-1" />
                {format.toUpperCase()}
              </Button>
            ))}
          </div>
        </div>
      </div>

      {/* Search and Filters */}
      <Card
        bg="#ffffff"
        borderColor="black"
        shadowColor="#c381b5"
        className="p-4"
      >
        <div className="space-y-4">
          <div className="flex gap-2 flex-wrap">
            <div className="relative flex-1 min-w-[300px]">
              <Search className="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-gray-400" />
              <Input
                placeholder="Search conversations..."
                value={searchQuery}
                onChange={(e: ChangeEvent<HTMLInputElement>) => setSearchQuery(e.target.value)}
                bg="#fefcd0"
                borderColor="black"
                className="pl-10 font-medium"
              />
            </div>
            
            <Button
              bg={showCalendar ? '#c381b5' : '#f0f0f0'}
              textColor={showCalendar ? 'white' : 'black'}
              borderColor="black"
              shadow={showCalendar ? '#8b5fa3' : '#d0d0d0'}
              onClick={() => setShowCalendar(!showCalendar)}
              className="py-2 px-4 font-bold uppercase tracking-wider hover-lift relative"
            >
              <CalendarIcon className="w-4 h-4 mr-2" />
              {dateRange[0] && dateRange[1] ? (
                `${format(dateRange[0], 'MMM d')} - ${format(dateRange[1], 'MMM d')}`
              ) : (
                'Select dates'
              )}
            </Button>
            
            <Button
              bg={showFilters ? '#c381b5' : '#f0f0f0'}
              textColor={showFilters ? 'white' : 'black'}
              borderColor="black"
              shadow={showFilters ? '#8b5fa3' : '#d0d0d0'}
              onClick={() => setShowFilters(!showFilters)}
              className="py-2 px-4 font-bold uppercase tracking-wider hover-lift"
            >
              <Filter className="w-4 h-4 mr-2" />
              Filters
              {showFilters ? <ChevronUp className="w-4 h-4 ml-1" /> : <ChevronDown className="w-4 h-4 ml-1" />}
            </Button>
          </div>

          {/* Date Picker */}
          {showCalendar && (
            <Card
              bg="#ffffff"
              borderColor="black"
              shadowColor="#f7931e"
              className="absolute z-10 p-2 mt-2"
            >
              <Calendar
                selectRange
                onChange={(value) => {
                  const range = value as Date | Date[];
                  if (Array.isArray(range)) {
                    setDateRange([range[0] ?? null, range[1] ?? null]);
                    setShowCalendar(false);
                  }
                }}
                value={dateRange}
                className="border-0"
              />
            </Card>
          )}

          {/* Advanced Filters */}
          {showFilters && (
            <div className="grid grid-cols-1 md:grid-cols-3 gap-4 pt-4 border-t-2 border-black">
              <div>
                <label className="text-sm font-black uppercase tracking-wider text-black mb-2 block">
                   Sentiment
                </label>
                <div className="space-y-2">
                  {[
                    { key: 'positive', icon: Smile, color: 'text-green-500', label: 'Positive' },
                    { key: 'neutral', icon: Meh, color: 'text-gray-500', label: 'Neutral' },
                    { key: 'negative', icon: Frown, color: 'text-red-500', label: 'Negative' }
                  ].map(({ key, icon: Icon, color, label }) => (
                    <label key={key} className="flex items-center gap-2 cursor-pointer">
                      <input
                        type="checkbox"
                        checked={filters.sentiment?.includes(key as 'positive' | 'neutral' | 'negative') || false}
                        onChange={() => handleSentimentToggle(key as 'positive' | 'neutral' | 'negative')}
                        className="w-4 h-4 border-2 border-black"
                      />
                      <Icon className={`w-4 h-4 ${color}`} />
                      <span className="text-sm font-bold uppercase tracking-wide text-black">{label}</span>
                    </label>
                  ))}
                </div>
              </div>

              <div>
                <label className="text-sm font-black uppercase tracking-wider text-black mb-2 block">
                   Safety
                </label>
                <label className="flex items-center gap-2 cursor-pointer">
                  <input
                    type="checkbox"
                    checked={filters.hasFlaggedMessages === true}
                    onChange={handleFlaggedToggle}
                    className="w-4 h-4 border-2 border-black"
                  />
                  <AlertCircle className="w-4 h-4 text-orange-500" />
                  <span className="text-sm font-bold uppercase tracking-wide text-black">Has flagged messages</span>
                </label>
              </div>

              <div className="flex items-end">
                <Button
                  bg="#f0f0f0"
                  textColor="black"
                  borderColor="black"
                  shadow="#d0d0d0"
                  onClick={() => {
                    setFilters({
                      toyId,
                      searchQuery: '',
                      sentiment: [],
                      hasFlaggedMessages: undefined,
                    });
                    setSearchQuery('');
                    setDateRange([subDays(new Date(), 7), new Date()]);
                  }}
                  className="py-2 px-4 font-bold uppercase tracking-wider hover-lift"
                >
                  Clear filters
                </Button>
              </div>
            </div>
          )}
        </div>
      </Card>

      {/* Main Content */}
      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        {/* Conversations List */}
        <div className="lg:col-span-2">
          <ConversationList
            conversations={conversations || []}
            selectedId={selectedConversationId}
            onSelect={setSelectedConversationId}
            isLoading={conversations === undefined}
          />
        </div>

        {/* Analytics Sidebar */}
        <div className="space-y-4">
          <ConversationAnalytics
            analytics={analytics}
            isLoading={analytics === undefined}
          />
        </div>
      </div>

      {/* Conversation Details Modal */}
      {selectedConversationId && (
        <ConversationDetails
          conversationId={selectedConversationId}
          onClose={() => setSelectedConversationId(null)}
          isGuardianMode={isGuardianMode}
        />
      )}
    </div>
  );
}
</file>

<file path="src/components/index.ts">
export {
  Button,
  Card,
  Input,
  TextArea,
  ProgressBar,
  Popup,
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuLabel,
  DropdownMenuItem,
  DropdownMenuSeparator,
  Bubble,
  Accordion,
  AccordionItem,
  AccordionTrigger,
  AccordionContent,
} from '@pommai/ui';
</file>

<file path="src/components/ui/accordion.tsx">
"use client"

export {
  Accordion,
  AccordionItem,
  AccordionTrigger,
  AccordionContent,
  type AccordionProps,
  type AccordionItemProps,
  type AccordionTriggerProps,
  type AccordionContentProps
} from '@pommai/ui'
</file>

<file path="src/components/ui/alert-dialog.tsx">
"use client"

import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"
import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"

const AlertDialog = AlertDialogPrimitive.Root

const AlertDialogTrigger = AlertDialogPrimitive.Trigger

const AlertDialogPortal = AlertDialogPrimitive.Portal

/**
 * RetroUI-styled overlay for AlertDialog.
 */
const AlertDialogOverlay = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Overlay
    className={cn("pixel-popup-overlay", className)}
    {...props}
    ref={ref}
  />
))
AlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName

/**
 * RetroUI-styled AlertDialogContent matching Popup component.
 * Adds overlayClassName/contentClassName like Popup for consistency.
 */
interface AlertContentProps extends React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content> {
  overlayClassName?: string
  contentClassName?: string
  modalClassName?: string
  /** Optional title rendered as pixel header (use normal AlertDialogTitle if you prefer) */
  title?: string
  /** Renders a top-right close button inside the dialog */
  showClose?: boolean
  closeLabel?: string
}

const AlertDialogContent = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Content>,
  AlertContentProps
>(({ className, modalClassName, overlayClassName, contentClassName = "", children, title, showClose = true, closeLabel = "X", ...props }, ref) => {
  const svgString = React.useMemo(() => {
    const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="8" height="8"><path d="M3 1h1v1h-1zM4 1h1v1h-1zM2 2h1v1h-1zM5 2h1v1h-1zM1 3h1v1h-1zM6 3h1v1h-1zM1 4h1v1h-1zM6 4h1v1h-1zM2 5h1v1h-1zM5 5h1v1h-1zM3 6h1v1h-1zM4 6h1v1h-1z" fill="black"/></svg>`
    return `url("data:image/svg+xml,${encodeURIComponent(svg)}")`
  }, [])

  const styleVars = {
    "--popup-border-svg": svgString,
  } as React.CSSProperties

  return (
    <AlertDialogPortal>
      <AlertDialogOverlay className={overlayClassName} />
      <AlertDialogPrimitive.Content
        ref={ref}
        className={cn(
          "fixed left-1/2 top-1/2 z-50 w-full -translate-x-1/2 -translate-y-1/2 pixel-popup",
          modalClassName || className
        )}
        style={styleVars}
        {...props}
      >
        <div className={cn("pixel-popup-inner", contentClassName)}>
          {title && <h2 className="pixel-popup-title">{title}</h2>}
          {showClose && (
            <AlertDialogPrimitive.Cancel asChild>
              <button className="pixel-popup-close-button" aria-label="Close dialog">{closeLabel}</button>
            </AlertDialogPrimitive.Cancel>
          )}
          {children}
        </div>
      </AlertDialogPrimitive.Content>
    </AlertDialogPortal>
  )
})
AlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName

const AlertDialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
AlertDialogHeader.displayName = "AlertDialogHeader"

const AlertDialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
AlertDialogFooter.displayName = "AlertDialogFooter"

const AlertDialogTitle = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold", className)}
    {...props}
  />
))
AlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName

const AlertDialogDescription = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
AlertDialogDescription.displayName =
  AlertDialogPrimitive.Description.displayName

const AlertDialogAction = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Action>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>
>(({ className, formAction, children, ...props }, ref) => {
  // Filter out formAction if it's a function since our Button only accepts string formAction
  const buttonProps = typeof formAction === 'function' 
    ? { ...props, children }
    : { ...props, formAction, children };
    
  return (
    <AlertDialogPrimitive.Action ref={ref} className={cn("", className)} asChild>
      {/* Use RetroUI Button as the action */}
      <Button {...(buttonProps as unknown as React.ComponentProps<typeof Button>)} />
    </AlertDialogPrimitive.Action>
  )
})
AlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName

const AlertDialogCancel = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>
>(({ className, formAction, children, ...props }, ref) => {
  // Filter out formAction if it's a function since our Button only accepts string formAction
  const buttonProps = typeof formAction === 'function' 
    ? { ...props, children }
    : { ...props, formAction, children };
    
  return (
    <AlertDialogPrimitive.Cancel ref={ref} className={cn("", className)} asChild>
      {/* Use RetroUI Button as the cancel */}
      <Button bg="#e5e5e5" {...(buttonProps as unknown as React.ComponentProps<typeof Button>)} />
    </AlertDialogPrimitive.Cancel>
  )
})
AlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}
</file>

<file path="src/components/ui/alert.tsx">
"use client"

import * as React from "react"
import { cn } from "@/lib/utils"
import { cva, type VariantProps } from "class-variance-authority"

const alertVariants = cva(
  "relative w-full p-4 [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg+div]:pl-7 border-solid border-[5px] text-base",
  {
    variants: {
      variant: {
        default: "",
        destructive: "",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

interface AlertProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof alertVariants> {
  borderColor?: string
  bg?: string
  textColor?: string
}

const Alert = React.forwardRef<HTMLDivElement, AlertProps>(
  ({ className, variant, borderColor, bg, textColor, style, ...props }, ref) => {
    const svgString = React.useMemo(() => {
      const color = borderColor || (variant === "destructive" ? "#ff0000" : "#000000")
      const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="8" height="8"><path d="M3 1h1v1h-1zM4 1h1v1h-1zM2 2h1v1h-1zM5 2h1v1h-1zM1 3h1v1h-1zM6 3h1v1h-1zM1 4h1v1h-1zM6 4h1v1h-1zM2 5h1v1h-1zM5 5h1v1h-1zM3 6h1v1h-1zM4 6h1v1h-1z" fill="${color}"/></svg>`
      return `url("data:image/svg+xml,${encodeURIComponent(svg)}")`
    }, [borderColor, variant])

    const customStyle = {
      ...style,
      backgroundColor: bg || (variant === "destructive" ? "#fee2e2" : "#fefcd0"),
      color: textColor || "#000000",
      borderImageSource: svgString,
      borderImageSlice: 3,
      borderImageWidth: 2,
      borderImageRepeat: "stretch",
      borderImageOutset: 2,
      borderColor: borderColor || (variant === "destructive" ? "#ff0000" : "#000000"),
      boxShadow: `2px 2px 0 2px ${borderColor || (variant === "destructive" ? "#ff0000" : "#c381b5")}, -2px -2px 0 2px ${bg || (variant === "destructive" ? "#fee2e2" : "#fefcd0")}`,
    }

    return (
      <div
        ref={ref}
        role="alert"
        className={cn(alertVariants({ variant }), className)}
        style={customStyle}
        {...props}
      />
    )
  }
)
Alert.displayName = "Alert"

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-bold leading-none tracking-tight", className)}
    {...props}
  />
))
AlertTitle.displayName = "AlertTitle"

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
))
AlertDescription.displayName = "AlertDescription"

export { Alert, AlertTitle, AlertDescription }
</file>

<file path="src/components/ui/avatar.tsx">
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
      className
    )}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-gray-100",
      className
    )}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }
</file>

<file path="src/components/ui/badge.tsx">
"use client"

import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 border-solid border-[3px]",
  {
    variants: {
      variant: {
        default: "",
        secondary: "",
        destructive: "",
        outline: "bg-transparent",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {
  borderColor?: string
  bg?: string
  textColor?: string
}

function Badge({ className, variant, borderColor, bg, textColor, style, ...props }: BadgeProps) {
  const svgString = React.useMemo(() => {
    const color = borderColor || "#000000"
    const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="8" height="8"><path d="M3 1h1v1h-1zM4 1h1v1h-1zM2 2h1v1h-1zM5 2h1v1h-1zM1 3h1v1h-1zM6 3h1v1h-1zM1 4h1v1h-1zM6 4h1v1h-1zM2 5h1v1h-1zM5 5h1v1h-1zM3 6h1v1h-1zM4 6h1v1h-1z" fill="${color}"/></svg>`
    return `url("data:image/svg+xml,${encodeURIComponent(svg)}")`
  }, [borderColor])

  const getDefaultColors = () => {
    switch (variant) {
      case "secondary":
        return { bg: "#e5e5e5", text: "#000000", border: "#666666" }
      case "destructive":
        return { bg: "#fee2e2", text: "#ff0000", border: "#ff0000" }
      case "outline":
        return { bg: "transparent", text: "#000000", border: "#000000" }
      default:
        return { bg: "#fefcd0", text: "#000000", border: "#000000" }
    }
  }

  const defaults = getDefaultColors()

  const customStyle = {
    ...style,
    backgroundColor: bg || defaults.bg,
    color: textColor || defaults.text,
    borderImageSource: svgString,
    borderImageSlice: 3,
    borderImageWidth: 1,
    borderImageRepeat: "stretch",
    borderImageOutset: 1,
    borderColor: borderColor || defaults.border,
  }

  return (
    <div
      className={cn(badgeVariants({ variant }), className)}
      style={customStyle}
      {...props}
    />
  )
}

export { Badge, badgeVariants }
</file>

<file path="src/components/ui/button.tsx">
"use client"

export { Button, type ButtonProps } from '@pommai/ui'
</file>

<file path="src/components/ui/card.tsx">
"use client"

import * as React from 'react'

export { Card, type CardProps } from '@pommai/ui'

// Additional exports for shadcn/ui compatibility
export const CardHeader = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div className={`p-6 ${className || ''}`} {...props} />
)
CardHeader.displayName = "CardHeader"

export const CardTitle = ({ className, ...props }: React.HTMLAttributes<HTMLHeadingElement>) => (
  <h3 className={`text-2xl font-semibold leading-none tracking-tight ${className || ''}`} {...props} />
)
CardTitle.displayName = "CardTitle"

export const CardDescription = ({ className, ...props }: React.HTMLAttributes<HTMLParagraphElement>) => (
  <p className={`text-sm text-muted-foreground ${className || ''}`} {...props} />
)
CardDescription.displayName = "CardDescription"

export const CardContent = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div className={`p-6 pt-0 ${className || ''}`} {...props} />
)
CardContent.displayName = "CardContent"

export const CardFooter = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div className={`flex items-center p-6 pt-0 ${className || ''}`} {...props} />
)
CardFooter.displayName = "CardFooter"
</file>

<file path="src/components/ui/checkbox.tsx">
"use client"

import * as React from "react"
import { cn } from "@/lib/utils"

const Checkbox = React.forwardRef<
  HTMLInputElement,
  React.ComponentPropsWithoutRef<"input">
>(({ className, ...props }, ref) => {
  return (
    <input
      ref={ref}
      type="checkbox"
      className={cn(
        "h-5 w-5 border-[3px] border-black focus:ring-2 focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        "appearance-none relative bg-[var(--bg-input)] cursor-pointer",
        "before:content-[''] before:absolute before:inset-[2px] before:scale-0 before:transition-transform",
        "checked:before:scale-100 checked:before:bg-black",
        "checked:bg-[var(--bg-input)]",
        "hover:shadow-[2px_2px_0_0_var(--shadow-button)]",
        className
      )}
      {...props}
    />
  )
})
Checkbox.displayName = "Checkbox"

export { Checkbox }
</file>

<file path="src/components/ui/dialog.tsx">
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

/**
 * RetroUI-styled overlay for Dialogs.
 * Uses the pixel-popup-overlay class to match RetroUI aesthetics.
 */
const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn("pixel-popup-overlay", className)}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

/**
 * RetroUI-styled DialogContent.
 * - Centers the modal and applies pixel-popup outer and pixel-popup-inner wrapper.
 * - Preserves Radix primitives and accessibility.
 */
const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => {
  const svgString = React.useMemo(() => {
    const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="8" height="8"><path d="M3 1h1v1h-1zM4 1h1v1h-1zM2 2h1v1h-1zM5 2h1v1h-1zM1 3h1v1h-1zM6 3h1v1h-1zM1 4h1v1h-1zM6 4h1v1h-1zM2 5h1v1h-1zM5 5h1v1h-1zM3 6h1v1h-1zM4 6h1v1h-1z" fill="black"/></svg>`
    return `url("data:image/svg+xml,${encodeURIComponent(svg)}")`
  }, [])

  const styleVars = {
    "--popup-border-svg": svgString,
  } as React.CSSProperties

  return (
    <DialogPortal>
      <DialogOverlay />
      <DialogPrimitive.Content
        ref={ref}
        className={cn(
          "fixed left-[50%] top-[50%] z-50 w-full max-w-lg -translate-x-1/2 -translate-y-1/2 pixel-popup",
          className
        )}
        style={styleVars}
        {...props}
      >
        <div className="pixel-popup-inner">
          {children}
          <DialogPrimitive.Close className="pixel-popup-close-button">
            <X className="h-4 w-4" />
            <span className="sr-only">Close</span>
          </DialogPrimitive.Close>
        </div>
      </DialogPrimitive.Content>
    </DialogPortal>
  )
})
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-gray-500", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}
</file>

<file path="src/components/ui/dropdown-menu.tsx">
"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const DropdownMenu = DropdownMenuPrimitive.Root

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger

const DropdownMenuGroup = DropdownMenuPrimitive.Group

const DropdownMenuPortal = DropdownMenuPrimitive.Portal

const DropdownMenuSub = DropdownMenuPrimitive.Sub

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center px-2 py-1.5 text-sm outline-none dropdown-menu-item",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden dropdown-menu-content p-1 text-[var(--text-dropdown)]",
      className
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden dropdown-menu-content p-1 text-[var(--text-dropdown)]",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center px-2 py-1.5 text-sm outline-none transition-colors dropdown-menu-item",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center py-1.5 pl-8 pr-2 text-sm outline-none transition-colors dropdown-menu-item",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center py-1.5 pl-8 pr-2 text-sm outline-none transition-colors dropdown-menu-item",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-gray-200 dropdown-menu-separator", className)}
    {...props}
  />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  )
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}
</file>

<file path="src/components/ui/input.tsx">
"use client"

export { Input, type InputProps } from '@pommai/ui'
</file>

<file path="src/components/ui/label.tsx">
"use client"

import * as React from "react"
import { cn } from "@/lib/utils"

export type LabelProps = React.LabelHTMLAttributes<HTMLLabelElement>;

const Label = React.forwardRef<HTMLLabelElement, LabelProps>(
  ({ className, ...props }, ref) => (
    <label
      ref={ref}
      className={cn(
        "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70",
        className
      )}
      {...props}
    />
  )
)
Label.displayName = "Label"

export { Label }
</file>

<file path="src/components/ui/progress.tsx">
"use client"

export { ProgressBar as Progress, type ProgressBarProps as ProgressProps } from '@pommai/ui'
</file>

<file path="src/components/ui/radio-group.tsx">
"use client"

import * as React from "react"
import { cn } from "@/lib/utils"

interface RadioGroupProps extends Omit<React.ComponentPropsWithoutRef<"div">, "onChange"> {
  value?: string
  onValueChange?: (value: string) => void
  defaultValue?: string
  name?: string
}

const RadioGroupContext = React.createContext<{
  value?: string
  onValueChange?: (value: string) => void
  name?: string
}>({})

const RadioGroup = React.forwardRef<HTMLDivElement, RadioGroupProps>(
  ({ className, value, onValueChange, defaultValue, name, children, ...props }, ref) => {
    const [internalValue, setInternalValue] = React.useState(defaultValue || "")
    
    const contextValue = React.useMemo(
      () => ({
        value: value ?? internalValue,
        onValueChange: onValueChange ?? setInternalValue,
        name: name || "radio-group-" + Math.random().toString(36).substr(2, 9),
      }),
      [value, internalValue, onValueChange, name]
    )

    return (
      <RadioGroupContext.Provider value={contextValue}>
        <div
          ref={ref}
          className={cn("grid gap-2", className)}
          role="radiogroup"
          {...props}
        >
          {children}
        </div>
      </RadioGroupContext.Provider>
    )
  }
)
RadioGroup.displayName = "RadioGroup"

interface RadioGroupItemProps extends Omit<React.ComponentPropsWithoutRef<"input">, "type" | "onChange"> {
  value: string
}

const RadioGroupItem = React.forwardRef<HTMLInputElement, RadioGroupItemProps>(
  ({ className, value, ...props }, ref) => {
    const context = React.useContext(RadioGroupContext)
    const isChecked = context.value === value

    return (
      <input
        ref={ref}
        type="radio"
        name={context.name}
        value={value}
        checked={isChecked}
        onChange={(e) => {
          if (e.target.checked) {
            context.onValueChange?.(value)
          }
        }}
        className={cn(
          "h-5 w-5 border-[3px] border-black focus:ring-2 focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          "appearance-none relative bg-[var(--bg-input)] cursor-pointer",
          "before:content-[''] before:absolute before:inset-[2px] before:scale-0 before:transition-transform before:rounded-full",
          "checked:before:scale-100 before:bg-black",
          "hover:shadow-[2px_2px_0_0_var(--shadow-button)]",
          className
        )}
        {...props}
      />
    )
  }
)
RadioGroupItem.displayName = "RadioGroupItem"

export { RadioGroup, RadioGroupItem }
</file>

<file path="src/components/ui/scroll-area.tsx">
"use client"

import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-gray-400" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName

export { ScrollArea, ScrollBar }
</file>

<file path="src/components/ui/select.tsx">
"use client"

import * as React from "react"
import { cn } from "@/lib/utils"
import { ChevronDown } from "lucide-react"

interface SelectContextValue {
  value?: string
  onValueChange?: (value: string) => void
  open?: boolean
  onOpenChange?: (open: boolean) => void
}

const SelectContext = React.createContext<SelectContextValue>({})

interface SelectProps {
  children: React.ReactNode
  value?: string
  onValueChange?: (value: string) => void
  defaultValue?: string
}

const Select = ({ children, value, onValueChange, defaultValue }: SelectProps) => {
  const [open, setOpen] = React.useState(false)
  const [internalValue, setInternalValue] = React.useState(defaultValue || "")

  const contextValue = React.useMemo(
    () => ({
      value: value ?? internalValue,
      onValueChange: onValueChange ?? setInternalValue,
      open,
      onOpenChange: setOpen,
    }),
    [value, internalValue, onValueChange, open]
  )

  return (
    <SelectContext.Provider value={contextValue}>
      <div className="relative inline-block">{children}</div>
    </SelectContext.Provider>
  )
}

const SelectTrigger = React.forwardRef<
  HTMLButtonElement,
  React.ButtonHTMLAttributes<HTMLButtonElement>
>(({ className, children, ...props }, ref) => {
  const { open, onOpenChange } = React.useContext(SelectContext)

  return (
    <button
      ref={ref}
      className={cn(
        "pixel-button flex h-10 w-full items-center justify-between px-3 py-2 text-sm",
        "focus:outline-none disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      onClick={() => onOpenChange?.(!open)}
      aria-expanded={open}
      aria-haspopup="listbox"
      type="button"
      {...props}
      style={{
        // ensure the pixel border renders using the same SVG pattern as other components via CSS var fallback
        // If your theming sets --button-custom-* vars, pixel-button will honor them.
      }}
    >
      {children}
      <ChevronDown className={cn("h-4 w-4 transition-transform", open && "rotate-180")} />
    </button>
  )
})
SelectTrigger.displayName = "SelectTrigger"

const SelectValue = ({ placeholder }: { placeholder?: string }) => {
  const { value } = React.useContext(SelectContext)
  return <span className={!value ? "text-muted-foreground" : ""}>{value || placeholder}</span>
}

type SelectContentProps = React.HTMLAttributes<HTMLDivElement>;

const SelectContent = React.forwardRef<HTMLDivElement, SelectContentProps>(
  ({ className, children, ...props }, ref) => {
    const { open } = React.useContext(SelectContext)

    if (!open) return null

    return (
      <div
        ref={ref}
        className={cn(
          "absolute z-50 mt-1 max-h-60 w-full overflow-auto dropdown-menu-content",
          className
        )}
        {...props}
      >
        {children}
      </div>
    )
  }
)
SelectContent.displayName = "SelectContent"

interface SelectItemProps extends React.HTMLAttributes<HTMLDivElement> {
  value: string
}

const SelectItem = React.forwardRef<HTMLDivElement, SelectItemProps>(
  ({ className, children, value, ...props }, ref) => {
    const { value: selectedValue, onValueChange, onOpenChange } = React.useContext(SelectContext)
    const isSelected = selectedValue === value

    return (
      <div
        ref={ref}
        className={cn(
          "relative flex cursor-pointer select-none items-center px-3 py-2 text-sm outline-none dropdown-menu-item",
          isSelected && "bg-[var(--shadow-dropdown)] text-white",
          "disabled:pointer-events-none disabled:opacity-50",
          className
        )}
        onClick={() => {
          onValueChange?.(value)
          onOpenChange?.(false)
        }}
        {...props}
      >
        {children}
      </div>
    )}
)
SelectItem.displayName = "SelectItem"

export { Select, SelectTrigger, SelectValue, SelectContent, SelectItem }
</file>

<file path="src/components/ui/separator.tsx">
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        className
      )}
      {...props}
    />
  )
)
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator }
</file>

<file path="src/components/ui/skeleton.tsx">
import { cn } from "@/lib/utils"

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-gray-200", className)}
      {...props}
    />
  )
}

export { Skeleton }
</file>

<file path="src/components/ui/slider.tsx">
"use client"

import * as React from "react"
import { cn } from "@/lib/utils"

interface SliderProps extends React.HTMLAttributes<HTMLDivElement> {
  value?: number[]
  onValueChange?: (value: number[]) => void
  max?: number
  min?: number
  step?: number
  disabled?: boolean
}

/**
 * RetroUI Slider
 * - Track styled like pixel-progressbar-container (sm)
 * - Range styled like pixel-progressbar (filled portion)
 * - Thumb is a square block with pixel border and hard shadow, press-down on active
 */
const Slider = React.forwardRef<HTMLDivElement, SliderProps>(
  ({ className, value = [0], onValueChange, max = 100, min = 0, step = 1, disabled, ...props }, ref) => {
    const [internalValue, setInternalValue] = React.useState(value)
    const currentValue = value || internalValue

    const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
      const newValue = [parseInt(e.target.value)]
      setInternalValue(newValue)
      onValueChange?.(newValue)
    }

    const percentage = ((currentValue[0] - min) / (max - min)) * 100

    return (
      <div
        ref={ref}
        className={cn("relative flex w-full touch-none select-none items-center", className)}
        {...props}
      >
        <div className="relative w-full">
          {/* Track */}
          <div className="pixel-progressbar-container pixel-progressbar-sm">
            {/* Filled range */}
            <div
              className="pixel-progressbar"
              style={{ width: `${percentage}%` }}
            />
          </div>

          {/* Invisible native range for interaction */}
          <input
            type="range"
            min={min}
            max={max}
            step={step}
            value={currentValue[0]}
            onChange={handleChange}
            disabled={disabled}
            className="absolute top-0 left-0 w-full h-8 opacity-0 cursor-pointer"
          />

          {/* Thumb */}
          <div
            className="absolute top-1/2 w-6 h-6 -translate-y-1/2 -translate-x-1/2 bg-[var(--bg-button)] border-[5px] border-solid"
            style={{
              left: `${percentage}%`,
              borderColor: "var(--border-button, #000000)",
              boxShadow: "2px 2px 0 2px var(--shadow-button, #000000), -2px -2px 0 2px var(--bg-button, #f0f0f0)",
            }}
          />
        </div>
      </div>
    )
  }
)
Slider.displayName = "Slider"

export { Slider }
</file>

<file path="src/components/ui/switch.tsx">
"use client"

import * as React from "react"
import { cn } from "@/lib/utils"

interface SwitchProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  checked?: boolean
  onCheckedChange?: (checked: boolean) => void
}

const Switch = React.forwardRef<HTMLButtonElement, SwitchProps>(
  ({ className, checked = false, onCheckedChange, disabled, ...props }, ref) => {
    const [isChecked, setIsChecked] = React.useState(checked)
    const currentChecked = checked !== undefined ? checked : isChecked

    const handleClick = () => {
      if (disabled) return
      const newChecked = !currentChecked
      setIsChecked(newChecked)
      onCheckedChange?.(newChecked)
    }

    return (
      <button
        ref={ref}
        type="button"
        role="switch"
        aria-checked={currentChecked}
        onClick={handleClick}
        disabled={disabled}
        className={cn(
          "peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center",
          "border-2 border-[var(--border-button)] bg-[var(--bg-input)]",
          "transition-colors focus-visible:outline-none focus-visible:ring-2",
          "focus-visible:ring-ring focus-visible:ring-offset-2",
          "disabled:cursor-not-allowed disabled:opacity-50",
          currentChecked && "bg-[var(--color-progressbar)]",
          className
        )}
        {...props}
      >
        <span
          className={cn(
            "pointer-events-none block h-4 w-4",
            "bg-[var(--border-button)] transition-transform",
            currentChecked ? "translate-x-5" : "translate-x-1"
          )}
        />
      </button>
    )
  }
)
Switch.displayName = "Switch"

export { Switch }
</file>

<file path="src/components/ui/tabs.tsx">
'use client';

/**
 * Tabs component adapter for RetroUI.
 * Re-exports the Tabs components from @pommai/ui to maintain consistent import paths
 * while using the RetroUI styled components.
 */

export {
  Tabs,
  TabsList,
  TabsTrigger,
  TabsContent,
  type TabsProps,
  type TabsListProps,
  type TabsTriggerProps,
  type TabsContentProps,
} from '@pommai/ui';
</file>

<file path="src/components/ui/textarea.tsx">
"use client"

export { TextArea as Textarea, type TextAreaProps as TextareaProps } from '@pommai/ui'
</file>

<file path="src/components/ui/tooltip.tsx">
"use client"

import * as React from "react"
import { cn } from "@/lib/utils"

interface TooltipContextValue {
  open: boolean
  setOpen: (open: boolean) => void
}

const TooltipContext = React.createContext<TooltipContextValue>({
  open: false,
  setOpen: () => {},
})

export const TooltipProvider = ({ children }: { children: React.ReactNode }) => {
  const [open, setOpen] = React.useState(false)

  return (
    <TooltipContext.Provider value={{ open, setOpen }}>
      {children}
    </TooltipContext.Provider>
  )
}

export const Tooltip = ({ children }: { children: React.ReactNode }) => {
  return <div className="relative inline-block">{children}</div>
}

export const TooltipTrigger = React.forwardRef<
  HTMLButtonElement,
  React.ButtonHTMLAttributes<HTMLButtonElement>
>(({ className, onMouseEnter, onMouseLeave, ...props }, ref) => {
  const { setOpen } = React.useContext(TooltipContext)

  return (
    <button
      ref={ref}
      className={cn("", className)}
      onMouseEnter={(e) => {
        setOpen(true)
        onMouseEnter?.(e)
      }}
      onMouseLeave={(e) => {
        setOpen(false)
        onMouseLeave?.(e)
      }}
      {...props}
    />
  )
})
TooltipTrigger.displayName = "TooltipTrigger"

export const TooltipContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { open } = React.useContext(TooltipContext)

  if (!open) return null

  return (
    <div
      ref={ref}
      className={cn(
        "absolute z-50 px-3 py-1.5 text-sm",
        "bg-[var(--bg-popup)] text-[var(--text-popup)]",
        "border-solid border-[3px] border-black",
        "bottom-full left-1/2 transform -translate-x-1/2 mb-2",
        "pointer-events-none",
        className
      )}
      style={{
        borderImageSlice: 3,
        borderImageWidth: 1,
        borderImageRepeat: "stretch",
        borderImageSource: `url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='8' height='8'%3E%3Cpath d='M3 1h1v1h-1zM4 1h1v1h-1zM2 2h1v1h-1zM5 2h1v1h-1zM1 3h1v1h-1zM6 3h1v1h-1zM1 4h1v1h-1zM6 4h1v1h-1zM2 5h1v1h-1zM5 5h1v1h-1zM3 6h1v1h-1zM4 6h1v1h-1z' fill='black'/%3E%3C/svg%3E")`,
      }}
      {...props}
    />
  )
})
TooltipContent.displayName = "TooltipContent"
</file>

<file path="src/components/voice/VoiceGallery.tsx">
"use client";

import { useState, useMemo, type ChangeEvent, type MouseEvent } from "react";
import { useQuery, useMutation } from "convex/react";
import { api } from "../../../convex/_generated/api";
import { Id } from "../../../convex/_generated/dataModel";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Skeleton } from "@/components/ui/skeleton";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Play,
  Pause,
  Volume2,
  Check,
  Upload,
  Search,
  Filter,
} from "lucide-react";

interface Voice {
  _id: string;
  name: string;
  description?: string;
  previewUrl: string;
  provider?: string;
  gender?: string;
  language?: string;
  accent?: string;
  isPremium?: boolean;
  tags: string[];
  uploadedBy?: string;
}

interface VoiceGalleryProps {
  selectedVoiceId?: string;
  onSelectVoice: (voice: Voice) => void;
  onUploadClick?: () => void;
  isForKids?: boolean;
}

export function VoiceGallery({
  selectedVoiceId,
  onSelectVoice,
  onUploadClick,
  isForKids = false,
}: VoiceGalleryProps) {
  const [searchTerm, setSearchTerm] = useState("");
  const [genderFilter, setGenderFilter] = useState<string>("all");
  const [languageFilter, setLanguageFilter] = useState<string>("all");
  const [ageGroupFilter, setAgeGroupFilter] = useState<string>("all");
  const [playingVoiceId, setPlayingVoiceId] = useState<string | null>(null);
  const [audioElements, setAudioElements] = useState<Map<string, HTMLAudioElement>>(new Map());

  // Fetch voices based on whether it's for kids
  const publicVoices = useQuery(
    isForKids ? api.voices.getKidsFriendlyVoices : api.voices.getPublicVoices,
    genderFilter !== "all" || languageFilter !== "all" || ageGroupFilter !== "all"
      ? {
          gender: genderFilter !== "all" ? (genderFilter as 'male' | 'female' | 'neutral') : undefined,
          language: languageFilter !== "all" ? languageFilter : undefined,
          ageGroup: ageGroupFilter !== "all" ? ageGroupFilter : undefined,
        }
      : {}
  ) as Voice[] | undefined;

  const myVoices = useQuery(api.voices.getMyVoices) as Voice[] | undefined;
  const deleteVoiceMutation = useMutation(api.voices.deleteVoice);

  // Search functionality
  const searchResults = useQuery(
    api.voices.searchVoices,
    searchTerm.length > 2 ? { searchTerm } : "skip"
  ) as Voice[] | undefined;

  // Combine and filter voices
  const allVoices = useMemo(() => {
    if (searchTerm.length > 2 && searchResults) {
      return searchResults;
    }

    const combined = [];
    if (publicVoices) combined.push(...publicVoices);
    if (myVoices) {
      // Add custom voices that aren't already in public voices
      const publicIds = new Set(publicVoices?.map(v => v._id) || []);
      const uniqueMyVoices = myVoices.filter(v => !publicIds.has(v._id));
      combined.push(...uniqueMyVoices);
    }
    return combined;
  }, [publicVoices, myVoices, searchResults, searchTerm]);

  const handlePlayPreview = (voice: Voice) => {
    // Stop any currently playing audio
    if (playingVoiceId) {
      const currentAudio = audioElements.get(playingVoiceId);
      if (currentAudio) {
        currentAudio.pause();
        currentAudio.currentTime = 0;
      }
    }

    if (playingVoiceId === voice._id) {
      setPlayingVoiceId(null);
      return;
    }

    // Create or get audio element
    let audio = audioElements.get(voice._id);
    if (!audio) {
      audio = new Audio(voice.previewUrl);
      audio.addEventListener('ended', () => {
        setPlayingVoiceId(null);
      });
      const newMap = new Map(audioElements);
      newMap.set(voice._id, audio);
      setAudioElements(newMap);
    }

    audio.play();
    setPlayingVoiceId(voice._id);
  };

  const handleDeleteVoice = async (voice: Voice, e: React.MouseEvent) => {
    e.stopPropagation();
    try {
      await deleteVoiceMutation({ voiceId: voice._id as Id<"voices"> });
    } catch (err) {
      console.error('Failed to delete voice', err);
    }
  };

  const getVoiceCardClass = (voice: Voice) => {
    const isSelected = selectedVoiceId === voice._id;
    const isCustom = voice.provider === "custom";
    
    if (isSelected) {
      // Light retro highlight with strong outline; avoid any dark blue backgrounds
      return "border-2 border-black bg-[#fff6cc]";
    }
    if (isCustom) {
      return "border-dashed border-purple-300 dark:border-purple-700";
    }
    return "";
  };

  if (!publicVoices && !myVoices) {
    return (
      <div className="space-y-4">
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
          {[...Array(6)].map((_, i) => (
            <Card key={i} className="p-4">
              <Skeleton className="h-24 w-full mb-2" />
              <Skeleton className="h-4 w-3/4 mb-2" />
              <Skeleton className="h-4 w-1/2" />
            </Card>
          ))}
        </div>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* Search and Filters */}
      <div className="space-y-4">
        <div className="flex gap-2">
          <div className="relative flex-1">
            <Search className="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-gray-400" />
            <Input
              placeholder="Search voices by name or tags..."
              value={searchTerm}
              onChange={(e: ChangeEvent<HTMLInputElement>) => setSearchTerm(e.target.value)}
              className="pl-10"
            />
          </div>
          {onUploadClick && (
            <Button 
              onClick={onUploadClick} 
              bg="#ffffff"
              textColor="black"
              borderColor="black"
              shadow="#e0e0e0"
            >
              <Upload className="w-4 h-4 mr-2" />
              Upload Voice
            </Button>
          )}
        </div>

        <div className="flex flex-wrap gap-2">
          <Select value={genderFilter} onValueChange={setGenderFilter}>
            <SelectTrigger className="w-[140px]">
              <Filter className="w-4 h-4 mr-2" />
              <SelectValue placeholder="Gender" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="all">All Genders</SelectItem>
              <SelectItem value="male">Male</SelectItem>
              <SelectItem value="female">Female</SelectItem>
              <SelectItem value="neutral">Neutral</SelectItem>
            </SelectContent>
          </Select>

          <Select value={languageFilter} onValueChange={setLanguageFilter}>
            <SelectTrigger className="w-[140px]">
              <SelectValue placeholder="Language" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="all">All Languages</SelectItem>
              <SelectItem value="en">English</SelectItem>
              <SelectItem value="es">Spanish</SelectItem>
              <SelectItem value="fr">French</SelectItem>
              <SelectItem value="de">German</SelectItem>
              <SelectItem value="ja">Japanese</SelectItem>
              <SelectItem value="zh">Chinese</SelectItem>
            </SelectContent>
          </Select>

          <Select value={ageGroupFilter} onValueChange={setAgeGroupFilter}>
            <SelectTrigger className="w-[140px]">
              <SelectValue placeholder="Age Group" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="all">All Ages</SelectItem>
              <SelectItem value="child">Child</SelectItem>
              <SelectItem value="teen">Teen</SelectItem>
              <SelectItem value="adult">Adult</SelectItem>
              <SelectItem value="senior">Senior</SelectItem>
            </SelectContent>
          </Select>
        </div>
      </div>

      {/* Custom Voices Section */}
      {myVoices && myVoices.length > 0 && (
        <div>
          <h3 className="retro-h3 text-base sm:text-lg mb-3">My Custom Voices</h3>
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 mb-6">
            {myVoices.map((voice) => (
              <Card
                key={voice._id}
                className={`p-4 cursor-pointer transition-all ${getVoiceCardClass(voice)}`}
                onClick={() => onSelectVoice(voice)}
              >
                <div className="flex items-start justify-between mb-2">
                  <div className="flex-1">
                    <h4 className="font-semibold">{voice.name}</h4>
                    <p className="text-sm text-gray-500 dark:text-gray-400">
                      {voice.description}
                    </p>
                  </div>
                  {selectedVoiceId === voice._id && (
                    <Check className="w-5 h-5 text-black ml-2" />
                  )}
                </div>

                <div className="flex items-center gap-2 mb-3">
                  <Badge variant="secondary">{voice.gender}</Badge>
                  <Badge variant="secondary">{voice.language}</Badge>
                  {voice.accent && <Badge variant="secondary">{voice.accent}</Badge>}
                  <Badge variant="outline" className="text-purple-600">
                    Custom
                  </Badge>
                </div>

                <div className="flex items-center justify-between">
                  <div className="flex items-center gap-2">
                    <Button
                      size="sm"
                      onClick={(e: MouseEvent) => {
                        e.stopPropagation();
                        handlePlayPreview(voice);
                      }}
                    >
                      {playingVoiceId === voice._id ? (
                        <Pause className="w-4 h-4 mr-1" />
                      ) : (
                        <Play className="w-4 h-4 mr-1" />
                      )}
                      Preview
                    </Button>
                    {voice.uploadedBy && (
                      <Button
                        size="sm"
onClick={(e: MouseEvent) => handleDeleteVoice(voice, e)}
                      >
                        Delete
                      </Button>
                    )}
                  </div>
                </div>
              </Card>
            ))}
          </div>
        </div>
      )}

      {/* Public Voices */}
      <div>
        <h3 className="retro-h3 text-base sm:text-lg mb-3">
          {isForKids ? "Kid-Friendly Voices" : "Voice Library"}
        </h3>
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
          {allVoices.map((voice) => (
            <Card
              key={voice._id}
              className={`p-4 cursor-pointer transition-all ${getVoiceCardClass(voice)}`}
              onClick={() => onSelectVoice(voice)}
            >
              <div className="flex items-start justify-between mb-2">
                <div className="flex-1">
                  <h4 className="font-semibold">{voice.name}</h4>
                  <p className="text-sm text-gray-500 dark:text-gray-400">
                    {voice.description}
                  </p>
                </div>
                {selectedVoiceId === voice._id && (
                  <Check className="w-5 h-5 text-black ml-2" />
                )}
              </div>

              <div className="flex items-center gap-2 mb-3">
                <Badge variant="secondary">{voice.gender}</Badge>
                <Badge variant="secondary">{voice.language}</Badge>
                {voice.accent && <Badge variant="secondary">{voice.accent}</Badge>}
                {voice.isPremium && (
                  <Badge variant="default" className="bg-yellow-500">
                    Premium
                  </Badge>
                )}
                {voice.tags.includes("kids-friendly") && (
                  <Badge variant="default" className="bg-green-500">
                    Kids Safe
                  </Badge>
                )}
              </div>

              <div className="flex items-center justify-start">
                <Button
                  size="sm"
onClick={(e: MouseEvent) => {
                        e.stopPropagation();
                        handlePlayPreview(voice);
                      }}
                >
                  {playingVoiceId === voice._id ? (
                    <Pause className="w-4 h-4 mr-1" />
                  ) : (
                    <Play className="w-4 h-4 mr-1" />
                  )}
                  Preview
                </Button>
              </div>
            </Card>
          ))}
        </div>
      </div>

      {allVoices.length === 0 && (
        <div className="text-center py-12 text-gray-500">
          <Volume2 className="w-12 h-12 mx-auto mb-4 opacity-50" />
          <p>No voices found matching your criteria.</p>
          {onUploadClick && (
            <Button 
              onClick={onUploadClick} 
              bg="#ffffff"
              textColor="black"
              borderColor="black"
              shadow="#e0e0e0"
              className="mt-4"
            >
              <Upload className="w-4 h-4 mr-2" />
              Upload Your Own Voice
            </Button>
          )}
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/components/voice/VoicePreview.tsx">
"use client";

import { useState, useRef, useEffect, type ChangeEvent } from "react";
import { useAction } from "convex/react";
import { api } from "../../../convex/_generated/api";
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import { Textarea } from "@/components/ui/textarea";
import { Slider } from "@/components/ui/slider";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Play,
  Pause,
  Volume2,
  RefreshCw,
  Mic,
  Settings,
  Sparkles,
  Loader2,
  AlertCircle,
} from "lucide-react";
import { playAudio, stopAudio, cleanupAudioResources } from "@/lib/audio";

interface Voice {
  _id?: string;
  name: string;
  description?: string;
  externalVoiceId?: string;
  voiceId?: string;
  language?: string;
  gender?: string;
  accent?: string;
  ageGroup?: string;
}

interface VoicePreviewProps {
  voice: Voice;
  isForKids?: boolean;
}

const PREVIEW_PHRASES = {
  general: [
    "Hi there! I'm so excited to be your friend!",
    "What would you like to talk about today?",
    "That's a great question! Let me think about it.",
    "I love hearing your stories. Tell me more!",
    "Wow, you're so creative and smart!",
  ],
  kids: [
    "Hello! I'm your new friend. What's your name?",
    "Once upon a time, in a magical forest far away...",
    "That's amazing! You're doing such a great job!",
    "Let's play a fun game together!",
    "I think you're super special, just the way you are!",
  ],
  educational: [
    "Did you know that butterflies taste with their feet?",
    "Let's count together! One, two, three...",
    "The sun is a big star that gives us light and warmth.",
    "Reading books helps us learn new things every day!",
    "What's your favorite subject to learn about?",
  ],
  storytelling: [
    "In a land of dragons and knights, there lived a brave little mouse...",
    "The magical door opened, revealing a world full of wonders...",
    "And they all lived happily ever after. The end!",
    "What happens next in our story? You decide!",
    "The adventure begins when you believe in magic...",
  ],
};

export function VoicePreview({ voice, isForKids = false }: VoicePreviewProps) {
  const [isPlaying, setIsPlaying] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [selectedPhrase, setSelectedPhrase] = useState("");
  const [customText, setCustomText] = useState("");
  const [phraseCategory, setPhraseCategory] = useState(isForKids ? "kids" : "general");
  const [volume, setVolume] = useState([75]);
  const [speed, setSpeed] = useState([100]);
  const [pitch, setPitch] = useState([100]);
  const [showAdvanced, setShowAdvanced] = useState(false);
  const currentAudioId = useRef<string | null>(null);
  
  // Use Convex action for TTS
  const synthesizeSpeech = useAction(api.aiServices.synthesizeSpeech);

  useEffect(() => {
    // Set initial phrase
    const phrases = PREVIEW_PHRASES[phraseCategory as keyof typeof PREVIEW_PHRASES];
    setSelectedPhrase(phrases[0]);
  }, [phraseCategory]);
  
  useEffect(() => {
    // Cleanup audio resources on unmount
    return () => {
      if (currentAudioId.current) {
        stopAudio(currentAudioId.current);
      }
      cleanupAudioResources();
    };
  }, []);

  const handlePlay = async () => {
    if (isPlaying) {
      // Stop currently playing audio
      if (currentAudioId.current) {
        stopAudio(currentAudioId.current);
      }
      setIsPlaying(false);
      return;
    }

    const textToSpeak = customText || selectedPhrase;
    if (!textToSpeak) {
      setError("Please enter or select text to preview");
      return;
    }

    setIsLoading(true);
    setError(null);

    try {
      // Call ElevenLabs TTS via Convex action
      const audioResponse = await synthesizeSpeech({
        text: textToSpeak,
        voiceId: voice.externalVoiceId || voice.voiceId || "JBFqnCBsd6RMkjVDRZzb", // Fallback to default voice
        voiceSettings: {
          stability: 0.5,
          similarityBoost: 0.75,
          style: pitch[0] / 100, // Map pitch to style for effect
          useSpeakerBoost: true,
        },
        outputFormat: "mp3_44100_128",
      });

      if (audioResponse?.audioData) {
        // Generate unique ID for this audio
        const audioId = `voice-preview-${Date.now()}`;
        currentAudioId.current = audioId;
        
        // Play the audio using our utility
        await playAudio(audioResponse.audioData, {
          id: audioId,
          volume: volume[0] / 100,
          cache: true,
          onEnded: () => {
            setIsPlaying(false);
            currentAudioId.current = null;
          },
          onError: (error) => {
            console.error("Audio playback error:", error);
            setError("Failed to play audio. Please try again.");
            setIsPlaying(false);
            currentAudioId.current = null;
          },
        });
        
        setIsPlaying(true);
      } else {
        throw new Error("No audio data received from TTS service");
      }
    } catch (error) {
      console.error("Error synthesizing speech:", error);
      setError(error instanceof Error ? error.message : "Failed to generate speech. Please try again.");
      setIsPlaying(false);
    } finally {
      setIsLoading(false);
    }
  };

  const handleRandomPhrase = () => {
    const phrases = PREVIEW_PHRASES[phraseCategory as keyof typeof PREVIEW_PHRASES];
    const currentIndex = phrases.indexOf(selectedPhrase);
    let newIndex = Math.floor(Math.random() * phrases.length);
    
    // Ensure we get a different phrase
    while (newIndex === currentIndex && phrases.length > 1) {
      newIndex = Math.floor(Math.random() * phrases.length);
    }
    
    setSelectedPhrase(phrases[newIndex]);
  };

  const textToPreview = customText || selectedPhrase;

  return (
    <Card className="p-6 space-y-4">
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-3">
          <div className="w-12 h-12 rounded-full bg-gradient-to-br from-purple-500 to-pink-500 flex items-center justify-center">
            <Volume2 className="w-6 h-6 text-white" />
          </div>
          <div>
            <h3 className="retro-h3 text-base sm:text-lg">{voice.name}</h3>
            <p className="text-sm text-gray-500">{voice.description}</p>
          </div>
        </div>
        <Button
          bg="#ffffff"
          textColor="black"
          borderColor="black"
          shadow="#e0e0e0"
          size="sm"
          onClick={() => setShowAdvanced(!showAdvanced)}
        >
          <Settings className="w-4 h-4 mr-1" />
          {showAdvanced ? "Hide" : "Show"} Settings
        </Button>
      </div>

      {/* Phrase Selection */}
      <div className="space-y-3">
        <div className="flex items-center gap-2">
          <Select value={phraseCategory} onValueChange={setPhraseCategory}>
            <SelectTrigger className="w-[200px]">
              <Sparkles className="w-4 h-4 mr-2" />
              <SelectValue />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="general">General Phrases</SelectItem>
              <SelectItem value="kids">Kid-Friendly</SelectItem>
              <SelectItem value="educational">Educational</SelectItem>
              <SelectItem value="storytelling">Storytelling</SelectItem>
            </SelectContent>
          </Select>
          <Button 
            bg="#ffffff"
            textColor="black"
            borderColor="black"
            shadow="#e0e0e0"
            size="sm" 
            onClick={handleRandomPhrase}
          >
            <RefreshCw className="w-4 h-4 mr-1" />
            Random
          </Button>
        </div>

        <div className="space-y-2">
          <label className="text-sm font-medium">Preview Text</label>
          <Textarea
            value={textToPreview}
            onChange={(e: ChangeEvent<HTMLTextAreaElement>) => {
              setCustomText(e.target.value);
              setSelectedPhrase("");
            }}
            placeholder="Type custom text or select a phrase above..."
            className="min-h-[80px]"
          />
          {customText && (
            <Button
              bg="#f0f0f0"
              textColor="black"
              borderColor="black"
              shadow="#d0d0d0"
              size="sm"
              onClick={() => {
                setCustomText("");
                handleRandomPhrase();
              }}
            >
              Clear custom text
            </Button>
          )}
        </div>
      </div>

      {/* Advanced Settings */}
      {showAdvanced && (
        <div className="space-y-4 p-4 rounded-lg border-2 border-black bg-[#fff6cc]">
          <div className="space-y-2">
            <div className="flex items-center justify-between">
              <label className="text-sm font-medium">Volume</label>
              <span className="text-sm text-gray-700">{volume[0]}%</span>
            </div>
            <Slider
              value={volume}
              onValueChange={setVolume}
              min={0}
              max={100}
              step={5}
              className="w-full"
            />
          </div>

          <div className="space-y-2">
            <div className="flex items-center justify-between">
              <label className="text-sm font-medium">Speed</label>
              <span className="text-sm text-gray-700">{speed[0]}%</span>
            </div>
            <Slider
              value={speed}
              onValueChange={setSpeed}
              min={50}
              max={150}
              step={10}
              className="w-full"
            />
          </div>

          <div className="space-y-2">
            <div className="flex items-center justify-between">
              <label className="text-sm font-medium">Pitch</label>
              <span className="text-sm text-gray-700">{pitch[0]}%</span>
            </div>
            <Slider
              value={pitch}
              onValueChange={setPitch}
              min={50}
              max={150}
              step={10}
              className="w-full"
            />
          </div>
        </div>
      )}

      {/* Error Display */}
      {error && (
        <div className="flex items-center gap-2 p-3 bg-red-50 dark:bg-red-900/20 text-red-600 dark:text-red-400 rounded-lg">
          <AlertCircle className="w-4 h-4 flex-shrink-0" />
          <p className="text-sm">{error}</p>
        </div>
      )}

      {/* Play Controls */}
      <div className="flex items-center gap-3">
        <Button
          onClick={handlePlay}
          className="flex-1"
          size="lg"
          disabled={!textToPreview || isLoading}
        >
          {isLoading ? (
            <>
              <Loader2 className="w-5 h-5 mr-2 animate-spin" />
              Generating...
            </>
          ) : isPlaying ? (
            <>
              <Pause className="w-5 h-5 mr-2" />
              Stop Preview
            </>
          ) : (
            <>
              <Play className="w-5 h-5 mr-2" />
              Play Preview
            </>
          )}
        </Button>
        <Button 
          bg="#ffffff"
          textColor="black"
          borderColor="black"
          shadow="#e0e0e0"
          size="lg" 
          disabled={isLoading}
        >
          <Mic className="w-5 h-5 mr-2" />
          Test with Mic
        </Button>
      </div>

      {/* Voice Details */}
      <div className="grid grid-cols-2 gap-4 pt-4 border-t">
        <div>
          <p className="text-sm text-gray-500">Language</p>
          <p className="font-medium">{voice.language}</p>
        </div>
        <div>
          <p className="text-sm text-gray-500">Gender</p>
          <p className="font-medium capitalize">{voice.gender}</p>
        </div>
        {voice.accent && (
          <div>
            <p className="text-sm text-gray-500">Accent</p>
            <p className="font-medium">{voice.accent}</p>
          </div>
        )}
        <div>
          <p className="text-sm text-gray-500">Age Group</p>
          <p className="font-medium">{voice.ageGroup}</p>
        </div>
      </div>
    </Card>
  );
}
</file>

<file path="src/components/voice/VoiceUploader.tsx">
"use client";

import { useState, useRef, type ChangeEvent } from "react";
import { useAction } from "convex/react";
import { api } from "../../../convex/_generated/api";
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { Progress } from "@/components/ui/progress";
import { Switch } from "@/components/ui/switch";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  AlertCircle,
  Upload,
  Mic,
  Square,
  Check,
  X,
  Loader2,
  Volume2,
  FileAudio,
  Wand2,
} from "lucide-react";

interface VoiceUploaderProps {
  onComplete: (voiceId: string) => void;
  onCancel: () => void;
}

type UploadStep = 
  | "requirements"
  | "recordOrUpload"
  | "processing"
  | "preview"
  | "save";

const REQUIREMENTS = [
  "3-5 minutes of clear audio recording",
  "Quiet environment with minimal background noise",
  "Natural speaking voice (no whispering or shouting)",
  "Consistent tone and pace throughout",
  "Read diverse content for best results",
];

const SAMPLE_SCRIPT = `Welcome to Pommai voice recording! Please read the following text in your natural voice:

"Hello! I'm excited to be your new friend. Let me tell you a story. Once upon a time, in a magical forest, there lived a curious little rabbit who loved to explore. Every day was a new adventure!

The weather today is sunny and bright. Did you know that butterflies taste with their feet? That's amazing! I love learning new things with you.

One, two, three, four, five. Let's count together! Mathematics is fun when we practice together. What's your favorite number?

Thank you for spending time with me today. I can't wait to talk with you again soon. Remember, you're special just the way you are!"

Please continue reading any book or article for 3-5 minutes to provide enough voice samples.`;

export function VoiceUploader({ onComplete, onCancel }: VoiceUploaderProps) {
  const [step, setStep] = useState<UploadStep>("requirements");
  const [isRecording, setIsRecording] = useState(false);
  const [recordingTime, setRecordingTime] = useState(0);
  const [audioBlob, setAudioBlob] = useState<Blob | null>(null);
  const [audioUrl, setAudioUrl] = useState<string | null>(null);
  const [processingProgress, setProcessingProgress] = useState(0);
  const [voiceData, setVoiceData] = useState({
    name: "",
    description: "",
    language: "en",
    accent: "",
    ageGroup: "adult",
    gender: "neutral" as "male" | "female" | "neutral",
    tags: [] as string[],
    isPublic: false,
  });
  
  const mediaRecorderRef = useRef<MediaRecorder | null>(null);
  const chunksRef = useRef<Blob[]>([]);
  const timerRef = useRef<NodeJS.Timeout | null>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);

const cloneVoice = useAction(api.aiServices.cloneElevenVoiceFromBase64);

  const startRecording = async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const mediaRecorder = new MediaRecorder(stream);
      mediaRecorderRef.current = mediaRecorder;
      chunksRef.current = [];

      mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          chunksRef.current.push(event.data);
        }
      };

      mediaRecorder.onstop = () => {
        const blob = new Blob(chunksRef.current, { type: "audio/webm" });
        setAudioBlob(blob);
        setAudioUrl(URL.createObjectURL(blob));
        stream.getTracks().forEach(track => track.stop());
      };

      mediaRecorder.start();
      setIsRecording(true);
      setRecordingTime(0);

      // Start timer
      timerRef.current = setInterval(() => {
        setRecordingTime(prev => prev + 1);
      }, 1000);
    } catch (error) {
      console.error("Error accessing microphone:", error);
      alert("Could not access microphone. Please check permissions.");
    }
  };

  const stopRecording = () => {
    if (mediaRecorderRef.current && isRecording) {
      mediaRecorderRef.current.stop();
      setIsRecording(false);
      
      if (timerRef.current) {
        clearInterval(timerRef.current);
        timerRef.current = null;
      }
    }
  };

  const handleFileUpload = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (file) {
      if (file.size > 50 * 1024 * 1024) { // 50MB limit
        alert("File too large. Please upload a file smaller than 50MB.");
        return;
      }
      
      setAudioBlob(file);
      setAudioUrl(URL.createObjectURL(file));
    }
  };

  const processVoice = async () => {
    if (!audioBlob) return;
    
    setStep("processing");
    
    // Simulate processing steps
    const steps = [
      { progress: 20, message: "Analyzing audio quality..." },
      { progress: 40, message: "Detecting voice characteristics..." },
      { progress: 60, message: "Creating voice model..." },
      { progress: 80, message: "Optimizing for real-time synthesis..." },
      { progress: 100, message: "Voice clone ready!" },
    ];
    
    for (const step of steps) {
      setProcessingProgress(step.progress);
      await new Promise(resolve => setTimeout(resolve, 1500));
    }
    
    // In production, this would upload to 11Labs or other voice cloning service
    // and return the voice ID
    setStep("preview");
  };

  const saveVoice = async () => {
    try {
      if (!audioBlob) throw new Error("No audio to upload");
      // Convert Blob to base64 via FileReader
      const base64Audio: string = await new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => {
          const res = reader.result as string;
          const b64 = res?.split(',')[1] || '';
          resolve(b64);
        };
        reader.onerror = () => reject(new Error('Failed to read audio file'));
        reader.readAsDataURL(audioBlob);
      });

      const result = await cloneVoice({
        name: voiceData.name,
        description: voiceData.description,
        language: voiceData.language,
        accent: voiceData.accent || undefined,
        ageGroup: voiceData.ageGroup,
        gender: voiceData.gender,
        tags: voiceData.tags,
        isPublic: voiceData.isPublic,
        fileBase64: base64Audio,
        mimeType: audioBlob.type || 'audio/webm',
      }) as unknown as { externalVoiceId?: string };

      // Pass back the external voice id so backend TTS can use it immediately
      if (result?.externalVoiceId) {
        onComplete(result.externalVoiceId);
      } else {
        throw new Error('Voice cloning succeeded but no externalVoiceId returned');
      }
    } catch (error) {
      console.error("Error saving voice:", error);
      alert("Failed to save voice. Please try again.");
    }
  };

  const formatTime = (seconds: number) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  const renderStep = () => {
    switch (step) {
      case "requirements":
        return (
          <Card className="p-6 space-y-6">
            <div>
              <h2 className="text-2xl font-bold mb-2">Voice Upload Requirements</h2>
              <p className="text-gray-600">
                To create a high-quality voice clone, please ensure you meet these requirements:
              </p>
            </div>
            
            <div className="space-y-3">
              {REQUIREMENTS.map((req, index) => (
                <div key={index} className="flex items-start gap-3">
                  <Check className="w-5 h-5 text-green-500 mt-0.5" />
                  <p className="text-sm">{req}</p>
                </div>
              ))}
            </div>
            
            <div className="bg-blue-50 dark:bg-blue-950 p-4 rounded-lg">
              <div className="flex items-start gap-3">
                <AlertCircle className="w-5 h-5 text-blue-500 mt-0.5" />
                <div className="text-sm">
                  <p className="font-medium mb-1">Pro Tip:</p>
                  <p>
                    For best results, read from a variety of content including stories,
                    educational material, and conversational phrases.
                  </p>
                </div>
              </div>
            </div>
            
            <div className="flex justify-between">
              <Button variant="outline" onClick={onCancel}>
                Cancel
              </Button>
              <Button onClick={() => setStep("recordOrUpload")}>
                Continue
              </Button>
            </div>
          </Card>
        );

      case "recordOrUpload":
        return (
          <Card className="p-6 space-y-6">
            <div>
              <h2 className="text-2xl font-bold mb-2">Record or Upload Voice</h2>
              <p className="text-gray-600">
                Choose to record directly or upload an existing audio file.
              </p>
            </div>
            
            <div className="grid md:grid-cols-2 gap-4">
              <Card className="p-4 space-y-4">
                <div className="flex items-center gap-3">
                  <Mic className="w-8 h-8 text-blue-500" />
                  <h3 className="font-semibold">Record Voice</h3>
                </div>
                
                {!audioBlob && (
                  <div className="space-y-4">
                    <div className="bg-gray-50 dark:bg-gray-900 p-4 rounded-lg">
                      <p className="text-sm font-medium mb-2">Sample Script:</p>
                      <pre className="text-xs whitespace-pre-wrap font-mono max-h-40 overflow-y-auto">
                        {SAMPLE_SCRIPT}
                      </pre>
                    </div>
                    
                    {isRecording ? (
                      <div className="space-y-3">
                        <div className="flex items-center justify-center gap-3">
                          <div className="w-3 h-3 bg-red-500 rounded-full animate-pulse" />
                          <span className="font-medium">Recording... {formatTime(recordingTime)}</span>
                        </div>
                        <Progress value={(recordingTime / 300) * 100} className="h-2" />
                        <Button 
                          bg="#ff6b6b"
                          textColor="white"
                          borderColor="black"
                          shadow="#e84545"
                          onClick={stopRecording}
                          className="w-full"
                        >
                          <Square className="w-4 h-4 mr-2" />
                          Stop Recording
                        </Button>
                      </div>
                    ) : (
                      <Button onClick={startRecording} className="w-full">
                        <Mic className="w-4 h-4 mr-2" />
                        Start Recording
                      </Button>
                    )}
                  </div>
                )}
              </Card>
              
              <Card className="p-4 space-y-4">
                <div className="flex items-center gap-3">
                  <FileAudio className="w-8 h-8 text-purple-500" />
                  <h3 className="font-semibold">Upload File</h3>
                </div>
                
                <div className="space-y-4">
                  <div className="text-sm text-gray-600">
                    <p>Supported formats: MP3, WAV, M4A, WEBM</p>
                    <p>Maximum file size: 50MB</p>
                    <p>Minimum duration: 3 minutes</p>
                  </div>
                  
                  <input
                    ref={fileInputRef}
                    type="file"
                    accept="audio/*"
                    onChange={handleFileUpload}
                    className="hidden"
                  />
                  
                  <Button
                    onClick={() => fileInputRef.current?.click()}
                    bg="#ffffff"
                    textColor="black"
                    borderColor="black"
                    shadow="#e0e0e0"
                    className="w-full"
                    disabled={!!audioBlob}
                  >
                    <Upload className="w-4 h-4 mr-2" />
                    Choose File
                  </Button>
                </div>
              </Card>
            </div>
            
            {audioBlob && (
              <Card className="p-4 space-y-4 bg-green-50 dark:bg-green-950">
                <div className="flex items-center justify-between">
                  <div className="flex items-center gap-3">
                    <Check className="w-5 h-5 text-green-500" />
                    <div>
                      <p className="font-medium">Audio ready for processing</p>
                      <p className="text-sm text-gray-600">
                        Duration: {formatTime(recordingTime)}
                      </p>
                    </div>
                  </div>
                  <audio src={audioUrl!} controls className="max-w-xs" />
                </div>
                
                <div className="flex gap-2">
                  <Button
                    bg="#f0f0f0"
                    textColor="black"
                    borderColor="black"
                    shadow="#d0d0d0"
                    onClick={() => {
                      setAudioBlob(null);
                      setAudioUrl(null);
                      setRecordingTime(0);
                    }}
                  >
                    <X className="w-4 h-4 mr-2" />
                    Remove
                  </Button>
                  <Button onClick={processVoice} className="flex-1">
                    <Wand2 className="w-4 h-4 mr-2" />
                    Process Voice
                  </Button>
                </div>
              </Card>
            )}
            
            {!audioBlob && (
              <div className="flex justify-between">
                <Button 
                  bg="#f0f0f0"
                  textColor="black"
                  borderColor="black"
                  shadow="#d0d0d0"
                  onClick={onCancel}
                >
                  Cancel
                </Button>
              </div>
            )}
          </Card>
        );

      case "processing":
        return (
          <Card className="p-6 space-y-6">
            <div className="text-center space-y-4">
              <Loader2 className="w-12 h-12 animate-spin mx-auto text-blue-500" />
              <h2 className="text-2xl font-bold">Processing Your Voice</h2>
              <p className="text-gray-600">
                This may take a few minutes. Please don&apos;t close this window.
              </p>
              
              <div className="max-w-md mx-auto space-y-3">
                <Progress value={processingProgress} className="h-3" />
                <p className="text-sm text-gray-500">
                  {processingProgress < 20 && "Analyzing audio quality..."}
                  {processingProgress >= 20 && processingProgress < 40 && "Detecting voice characteristics..."}
                  {processingProgress >= 40 && processingProgress < 60 && "Creating voice model..."}
                  {processingProgress >= 60 && processingProgress < 80 && "Optimizing for real-time synthesis..."}
                  {processingProgress >= 80 && "Voice clone ready!"}
                </p>
              </div>
            </div>
          </Card>
        );

      case "preview":
        return (
          <Card className="p-6 space-y-6">
            <div>
              <h2 className="text-2xl font-bold mb-2">Preview & Save Voice</h2>
              <p className="text-gray-600">
                Test your voice clone and provide details before saving.
              </p>
            </div>
            
            <Card className="p-4 bg-blue-50 dark:bg-blue-950">
              <div className="flex items-center gap-3">
                <Volume2 className="w-8 h-8 text-blue-500" />
                <div>
                  <p className="font-medium">Voice Clone Ready!</p>
                  <p className="text-sm text-gray-600">
                    Your voice has been successfully processed.
                  </p>
                </div>
              </div>
            </Card>
            
            <div className="space-y-4">
              <div>
                <Label htmlFor="name">Voice Name *</Label>
                <Input
                  id="name"
                  value={voiceData.name}
onChange={(e: ChangeEvent<HTMLInputElement>) => setVoiceData({ ...voiceData, name: e.target.value })}
                  placeholder="e.g., My Natural Voice"
                />
              </div>
              
              <div>
                <Label htmlFor="description">Description *</Label>
                <Textarea
                  id="description"
                  value={voiceData.description}
onChange={(e: ChangeEvent<HTMLTextAreaElement>) => setVoiceData({ ...voiceData, description: e.target.value })}
                  placeholder="Describe the voice characteristics..."
                  rows={3}
                />
              </div>
              
              <div className="grid md:grid-cols-2 gap-4">
                <div>
                  <Label htmlFor="language">Language</Label>
                  <Select
                    value={voiceData.language}
                    onValueChange={(value) => setVoiceData({ ...voiceData, language: value })}
                  >
                    <SelectTrigger id="language">
                      <SelectValue />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="en">English</SelectItem>
                      <SelectItem value="es">Spanish</SelectItem>
                      <SelectItem value="fr">French</SelectItem>
                      <SelectItem value="de">German</SelectItem>
                      <SelectItem value="ja">Japanese</SelectItem>
                      <SelectItem value="zh">Chinese</SelectItem>
                    </SelectContent>
                  </Select>
                </div>
                
                <div>
                  <Label htmlFor="accent">Accent (Optional)</Label>
                  <Input
                    id="accent"
                    value={voiceData.accent}
onChange={(e: ChangeEvent<HTMLInputElement>) => setVoiceData({ ...voiceData, accent: e.target.value })}
                    placeholder="e.g., British, Southern US"
                  />
                </div>
              </div>
              
              <div className="grid md:grid-cols-2 gap-4">
                <div>
                  <Label htmlFor="gender">Gender</Label>
                  <Select
                    value={voiceData.gender}
                    onValueChange={(value) => setVoiceData({ ...voiceData, gender: value as 'male' | 'female' | 'neutral' })}
                  >
                    <SelectTrigger id="gender">
                      <SelectValue />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="male">Male</SelectItem>
                      <SelectItem value="female">Female</SelectItem>
                      <SelectItem value="neutral">Neutral</SelectItem>
                    </SelectContent>
                  </Select>
                </div>
                
                <div>
                  <Label htmlFor="ageGroup">Age Group</Label>
                  <Select
                    value={voiceData.ageGroup}
                    onValueChange={(value) => setVoiceData({ ...voiceData, ageGroup: value })}
                  >
                    <SelectTrigger id="ageGroup">
                      <SelectValue />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="child">Child</SelectItem>
                      <SelectItem value="teen">Teen</SelectItem>
                      <SelectItem value="adult">Adult</SelectItem>
                      <SelectItem value="senior">Senior</SelectItem>
                    </SelectContent>
                  </Select>
                </div>
              </div>
              
              <div className="flex items-center justify-between">
                <div className="space-y-0.5">
                  <Label htmlFor="public">Make voice public</Label>
                  <p className="text-sm text-gray-500">
                    Allow other users to use this voice
                  </p>
                </div>
                <Switch
                  id="public"
                  checked={voiceData.isPublic}
                  onCheckedChange={(checked) => setVoiceData({ ...voiceData, isPublic: checked })}
                />
              </div>
            </div>
            
            <div className="flex justify-between">
              <Button 
                bg="#f0f0f0"
                textColor="black"
                borderColor="black"
                shadow="#d0d0d0"
                onClick={onCancel}
              >
                Cancel
              </Button>
              <Button
                onClick={saveVoice}
                disabled={!voiceData.name || !voiceData.description}
              >
                Save Voice
              </Button>
            </div>
          </Card>
        );
    }
  };

  return <div className="max-w-3xl mx-auto">{renderStep()}</div>;
}
</file>

<file path="src/lib/audio.ts">
/**
 * Audio utility functions for browser audio handling
 * Provides base64 conversion, audio playback, and caching functionality
 */

/**
 * Audio cache to store preloaded audio URLs
 * @type {Map<string, string>}
 */
const audioCache = new Map<string, string>();

/**
 * Active audio elements for cleanup
 * @type {Map<string, HTMLAudioElement>}
 */
const activeAudioElements = new Map<string, HTMLAudioElement>();

/**
 * Convert base64 encoded audio data to Blob
 * @param {string} base64Data - Base64 encoded audio data
 * @param {string} mimeType - MIME type of the audio (default: audio/mp3)
 * @returns {Blob} Audio blob
 */
export function base64ToBlob(base64Data: string, mimeType: string = 'audio/mp3'): Blob {
  try {
    // Remove data URL prefix if present
    const base64 = base64Data.replace(/^data:audio\/[a-z]+;base64,/, '');
    
    // Decode base64 string
    const byteCharacters = atob(base64);
    const byteNumbers = new Array(byteCharacters.length);
    
    for (let i = 0; i < byteCharacters.length; i++) {
      byteNumbers[i] = byteCharacters.charCodeAt(i);
    }
    
    const byteArray = new Uint8Array(byteNumbers);
    return new Blob([byteArray], { type: mimeType });
  } catch (error) {
    console.error('Error converting base64 to blob:', error);
    throw new Error('Failed to convert audio data');
  }
}

/**
 * Create a URL from audio blob for playback
 * @param {Blob} blob - Audio blob
 * @returns {string} Object URL for audio playback
 */
export function createAudioURL(blob: Blob): string {
  try {
    return URL.createObjectURL(blob);
  } catch (error) {
    console.error('Error creating audio URL:', error);
    throw new Error('Failed to create audio URL');
  }
}

/**
 * Play audio from base64 data
 * @param {string} base64Data - Base64 encoded audio data
 * @param {object} options - Playback options
 * @param {string} options.id - Unique identifier for the audio
 * @param {number} options.volume - Volume level (0-1)
 * @param {boolean} options.cache - Whether to cache the audio
 * @param {function} options.onEnded - Callback when audio ends
 * @param {function} options.onError - Error callback
 * @returns {Promise<HTMLAudioElement>} Audio element
 */
export async function playAudio(
  base64Data: string,
  options: {
    id?: string;
    volume?: number;
    cache?: boolean;
    onEnded?: () => void;
    onError?: (error: Error) => void;
  } = {}
): Promise<HTMLAudioElement> {
  const {
    id = Date.now().toString(),
    volume = 1.0,
    cache = true,
    onEnded,
    onError,
  } = options;

  try {
    // Check cache first
    let audioUrl = cache ? audioCache.get(id) : null;
    
    if (!audioUrl) {
      // Convert base64 to blob and create URL
      const blob = base64ToBlob(base64Data);
      audioUrl = createAudioURL(blob);
      
      // Cache the URL if requested
      if (cache) {
        audioCache.set(id, audioUrl);
      }
    }
    
    // Stop any existing audio with the same ID
    stopAudio(id);
    
    // Create and configure audio element
    const audio = new Audio(audioUrl);
    audio.volume = volume;
    
    // Store reference for cleanup
    activeAudioElements.set(id, audio);
    
    // Set up event handlers
    audio.addEventListener('ended', () => {
      activeAudioElements.delete(id);
      onEnded?.();
    });
    
    audio.addEventListener('error', (e) => {
      activeAudioElements.delete(id);
      const error = new Error(`Audio playback failed: ${e.message || 'Unknown error'}`);
      console.error('Audio playback error:', error);
      onError?.(error);
    });
    
    // Play the audio
    await audio.play();
    
    return audio;
  } catch (error) {
    console.error('Error playing audio:', error);
    onError?.(error as Error);
    throw error;
  }
}

/**
 * Preload audio data for faster playback
 * @param {string} base64Data - Base64 encoded audio data
 * @param {string} id - Unique identifier for caching
 * @returns {Promise<void>}
 */
export async function preloadAudio(base64Data: string, id: string): Promise<void> {
  try {
    if (audioCache.has(id)) {
      return; // Already cached
    }
    
    const blob = base64ToBlob(base64Data);
    const url = createAudioURL(blob);
    audioCache.set(id, url);
    
    // Preload the audio
    const audio = new Audio(url);
    audio.preload = 'auto';
    
    // Wait for the audio to be loaded
    await new Promise((resolve, reject) => {
      audio.addEventListener('canplaythrough', resolve, { once: true });
      audio.addEventListener('error', reject, { once: true });
    });
  } catch (error) {
    console.error('Error preloading audio:', error);
    throw new Error('Failed to preload audio');
  }
}

/**
 * Stop playing audio by ID
 * @param {string} id - Audio identifier
 */
export function stopAudio(id: string): void {
  const audio = activeAudioElements.get(id);
  if (audio) {
    audio.pause();
    audio.currentTime = 0;
    activeAudioElements.delete(id);
  }
}

/**
 * Stop all playing audio
 */
export function stopAllAudio(): void {
  activeAudioElements.forEach((audio, _id) => {
    audio.pause();
    audio.currentTime = 0;
  });
  activeAudioElements.clear();
}

/**
 * Clear audio cache
 * @param {string} id - Optional specific ID to clear, otherwise clears all
 */
export function clearAudioCache(id?: string): void {
  if (id) {
    const url = audioCache.get(id);
    if (url) {
      URL.revokeObjectURL(url);
      audioCache.delete(id);
    }
  } else {
    // Clear all cached URLs
    audioCache.forEach((url) => {
      URL.revokeObjectURL(url);
    });
    audioCache.clear();
  }
}

/**
 * Get audio format from output format string
 * @param {string} outputFormat - ElevenLabs output format
 * @returns {string} MIME type
 */
export function getAudioMimeType(outputFormat: string): string {
  // Parse ElevenLabs output format strings
  if (outputFormat.startsWith('mp3')) {
    return 'audio/mp3';
  } else if (outputFormat.startsWith('pcm')) {
    return 'audio/wav';
  } else if (outputFormat === 'ulaw') {
    return 'audio/basic';
  } else if (outputFormat === 'opus') {
    return 'audio/opus';
  }
  return 'audio/mp3'; // Default
}

/**
 * Format audio duration for display
 * @param {number} seconds - Duration in seconds
 * @returns {string} Formatted duration (e.g., "1:23")
 */
export function formatAudioDuration(seconds: number): string {
  const minutes = Math.floor(seconds / 60);
  const remainingSeconds = Math.floor(seconds % 60);
  return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
}

/**
 * Audio player component utilities
 */
export interface AudioPlayerState {
  isPlaying: boolean;
  currentTime: number;
  duration: number;
  volume: number;
  isMuted: boolean;
}

/**
 * Create an audio player controller
 * @param {string} audioUrl - URL or base64 data
 * @returns {object} Player controller
 */
export function createAudioPlayer(audioUrl: string) {
  let audio: HTMLAudioElement | null = null;
  const state: AudioPlayerState = {
    isPlaying: false,
    currentTime: 0,
    duration: 0,
    volume: 1.0,
    isMuted: false,
  };

  return {
    play: async () => {
      if (!audio) {
        audio = new Audio(audioUrl);
        audio.volume = state.volume;
        audio.muted = state.isMuted;
      }
      await audio.play();
      state.isPlaying = true;
    },
    
    pause: () => {
      audio?.pause();
      state.isPlaying = false;
    },
    
    stop: () => {
      if (audio) {
        audio.pause();
        audio.currentTime = 0;
        state.isPlaying = false;
        state.currentTime = 0;
      }
    },
    
    seek: (time: number) => {
      if (audio) {
        audio.currentTime = time;
        state.currentTime = time;
      }
    },
    
    setVolume: (volume: number) => {
      state.volume = Math.max(0, Math.min(1, volume));
      if (audio) {
        audio.volume = state.volume;
      }
    },
    
    toggleMute: () => {
      state.isMuted = !state.isMuted;
      if (audio) {
        audio.muted = state.isMuted;
      }
    },
    
    getState: () => state,
    
    destroy: () => {
      if (audio) {
        audio.pause();
        audio.src = '';
        audio = null;
      }
    },
  };
}

/**
 * Clean up all audio resources (call on component unmount)
 */
export function cleanupAudioResources(): void {
  stopAllAudio();
  clearAudioCache();
}
</file>

<file path="src/lib/auth-client.ts">
import { createAuthClient } from "better-auth/react";
import { convexClient } from "@convex-dev/better-auth/client/plugins";

export const authClient = createAuthClient({
  baseURL: process.env.NEXT_PUBLIC_BASE_URL || "http://localhost:3000",
  plugins: [
    convexClient(),
  ],
});
</file>

<file path="src/lib/auth.ts">
import { convexAdapter } from "@convex-dev/better-auth";
import { convex } from "@convex-dev/better-auth/plugins";
import { requireEnv } from "@convex-dev/better-auth/utils";
import { betterAuth } from "better-auth";
import { betterAuthComponent } from "../../convex/auth";
import { type GenericCtx } from "../../convex/_generated/server";
import { api } from "../../convex/_generated/api";
const siteUrl = requireEnv("SITE_URL");

export const createAuth = (ctx: GenericCtx) => {
  const requireVerificationEnv = process.env.AUTH_REQUIRE_EMAIL_VERIFICATION;
  const REQUIRE_EMAIL_VERIFICATION = typeof requireVerificationEnv === 'string'
    ? requireVerificationEnv.toLowerCase() === 'true'
    : process.env.NODE_ENV === 'production';

  return betterAuth({
    baseURL: siteUrl,
    database: convexAdapter(ctx, betterAuthComponent),
    emailAndPassword: {
      enabled: true,
      requireEmailVerification: REQUIRE_EMAIL_VERIFICATION,
      minPasswordLength: 8,
      maxPasswordLength: 128,
      // Send password reset email
      sendResetPassword: async ({ user, url, token }, request) => {
        if (!REQUIRE_EMAIL_VERIFICATION) {
          // Dev mode: log the reset URL to console instead of sending
          console.warn('[DEV] Password reset URL:', url);
          return;
        }
        await (ctx as any).runAction(api.emailActions.sendPasswordResetEmail, {
          email: user.email,
          name: user.name,
          resetUrl: url,
        });
      },
      // Callback after password reset
      onPasswordReset: async ({ user }, request) => {
        console.log(`Password reset successfully for user: ${user.email}`);
      },
      resetPasswordTokenExpiresIn: 3600, // 1 hour
    },
    // Email verification configuration
    emailVerification: {
      // Send verification email function
      sendVerificationEmail: async ({ user, url, token }, request) => {
        if (!REQUIRE_EMAIL_VERIFICATION) {
          // Dev mode: log the verification URL to console instead of sending
          console.warn('[DEV] Email verification URL:', url);
          return;
        }
        await (ctx as any).runAction(api.emailActions.sendVerificationEmail, {
          email: user.email,
          name: user.name,
          verificationUrl: url,
        });
      },
      // Automatically send verification email on signup/signin only if required
      sendOnSignUp: REQUIRE_EMAIL_VERIFICATION,
      sendOnSignIn: REQUIRE_EMAIL_VERIFICATION,
      // Auto sign-in after verification
      autoSignInAfterVerification: true,
      // Token expiration (1 hour)
      expiresIn: 3600,
      // Callback after successful verification
      async afterEmailVerification(user, request) {
        console.log(`Email verified for user: ${user.email}`);
        if (!REQUIRE_EMAIL_VERIFICATION) return;
        await (ctx as any).runAction(api.emailActions.sendWelcomeEmail, {
          email: user.email,
          name: user.name,
        });
      },
    },
    secret: process.env.BETTER_AUTH_SECRET!,
    plugins: [
      // The Convex plugin is required
      convex(),
    ],
  });
};
</file>

<file path="src/lib/utils.ts">
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
</file>

<file path="src/middleware.ts">
import { betterFetch } from "@better-fetch/fetch";
import type { NextRequest } from "next/server";
import { NextResponse } from "next/server";
 
export async function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl;
  
  // Protect dashboard routes
  if (pathname.startsWith("/dashboard")) {
    const { data: session } = await betterFetch("/api/auth/get-session", {
      baseURL: request.nextUrl.origin,
      headers: {
        cookie: request.headers.get("cookie") || "",
      },
    });
    
    if (!session) {
      const url = new URL("/auth", request.url);
      url.searchParams.set("redirect", pathname);
      return NextResponse.redirect(url);
    }
  }
  
  return NextResponse.next();
}
 
export const config = {
  matcher: ["/dashboard/:path*"],
};
</file>

<file path="src/stores/toyWizardStore.ts">
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

/**
 * Toy creation wizard steps
 */
export type WizardStep = 
  | 'welcome'
  | 'toyProfile'
  | 'forKidsToggle'
  | 'personality'
  | 'voice'
  | 'knowledge'
  | 'safety'
  | 'device'
  | 'review'
  | 'completion';

/**
 * Personality traits configuration
 */
interface PersonalityTraits {
  traits: string[]; // max 3
  speakingStyle: {
    vocabulary: 'simple' | 'moderate' | 'advanced';
    sentenceLength: 'short' | 'medium' | 'long';
    usesSoundEffects: boolean;
    catchPhrases: string[];
  };
  interests: string[];
  favoriteTopics: string[];
  avoidTopics: string[];
  behavior: {
    encouragesQuestions: boolean;
    tellsStories: boolean;
    playsGames: boolean;
    educationalFocus: number; // 0-10
    imaginationLevel: number; // 0-10
  };
}

/**
 * Knowledge base configuration
 */
interface KnowledgeBase {
  toyBackstory: {
    origin: string;
    personality: string;
    specialAbilities: string[];
    favoriteThings: string[];
  };
  familyInfo?: {
    members: Array<{
      name: string;
      relationship: string;
      facts: string[];
    }>;
    pets: Array<{
      name: string;
      type: string;
      facts: string[];
    }>;
    importantDates: Array<{
      date: string;
      event: string;
    }>;
  };
  customFacts: Array<{
    category: string;
    fact: string;
    importance: 'high' | 'medium' | 'low';
  }>;
}

/**
 * Safety settings for Guardian Mode
 */
interface SafetySettings {
  safetyLevel: 'strict' | 'moderate' | 'relaxed';
  contentFilters: {
    enabledCategories: string[];
    customBlockedTopics: string[];
  };
}

/**
 * Complete toy configuration
 */
interface ToyConfig {
  // Basic info
  name: string;
  type: string;
  isForKids: boolean;
  ageGroup?: '3-5' | '6-8' | '9-12';
  
  // Voice
  voiceId: string;
  voiceName?: string;
  
  // Personality
  personalityPrompt: string;
  personalityTraits: PersonalityTraits;
  
  // Knowledge
  knowledgeBase?: KnowledgeBase;
  
  // Safety (for Kids mode)
  safetySettings?: SafetySettings;
  
  // Meta
  isPublic: boolean;
  tags: string[];
}

/**
 * Wizard store state
 */
interface ToyWizardState {
  // Current step
  currentStep: WizardStep;
  completedSteps: WizardStep[];
  
  // Toy configuration
  toyConfig: ToyConfig;
  
  // Validation errors
  errors: Record<string, string>;
  
  // Loading states
  isCreating: boolean;
  
  // Actions
  setCurrentStep: (step: WizardStep) => void;
  markStepCompleted: (step: WizardStep) => void;
  setToyConfig: (config: Partial<ToyConfig>) => void;
  updateToyConfig: <K extends keyof ToyConfig>(key: K, value: ToyConfig[K]) => void;
  updatePersonalityTraits: (traits: Partial<PersonalityTraits>) => void;
  updateKnowledgeBase: (kb: Partial<KnowledgeBase>) => void;
  updateSafetySettings: (settings: Partial<SafetySettings>) => void;
  setError: (field: string, error: string) => void;
  clearError: (field: string) => void;
  clearAllErrors: () => void;
  setIsCreating: (isCreating: boolean) => void;
  resetWizard: () => void;
  canProceedToStep: (step: WizardStep) => boolean;
}

/**
 * Default toy configuration
 */
const defaultToyConfig: ToyConfig = {
  name: '',
  type: '',
  isForKids: false,
  voiceId: '',
  personalityPrompt: '',
  personalityTraits: {
    traits: [],
    speakingStyle: {
      vocabulary: 'moderate',
      sentenceLength: 'medium',
      usesSoundEffects: false,
      catchPhrases: [],
    },
    interests: [],
    favoriteTopics: [],
    avoidTopics: [],
    behavior: {
      encouragesQuestions: true,
      tellsStories: true,
      playsGames: true,
      educationalFocus: 5,
      imaginationLevel: 5,
    },
  },
  isPublic: false,
  tags: [],
};

/**
 * Step dependencies for validation
 */
const stepDependencies: Record<WizardStep, WizardStep[]> = {
  welcome: [],
  toyProfile: ['welcome'],
  forKidsToggle: ['toyProfile'],
  personality: ['forKidsToggle'],
  voice: ['personality'],
  knowledge: ['voice'],
  safety: ['knowledge'],
  device: ['safety'],
  review: ['device'],
  completion: ['review'],
};

/**
 * Create the toy wizard store
 */
export const useToyWizardStore = create<ToyWizardState>()(
  persist(
    (set, get) => ({
      // Initial state
      currentStep: 'welcome',
      completedSteps: [],
      toyConfig: defaultToyConfig,
      errors: {},
      isCreating: false,

      // Actions
      setCurrentStep: (step) => {
        const state = get();
        if (state.canProceedToStep(step)) {
          set({ currentStep: step });
        }
      },

      markStepCompleted: (step) => {
        set((state) => ({
          completedSteps: [...new Set([...state.completedSteps, step])],
        }));
      },

      setToyConfig: (config) => {
        set((state) => ({
          toyConfig: {
            ...defaultToyConfig,
            ...config,
            personalityTraits: config.personalityTraits ? {
              ...defaultToyConfig.personalityTraits,
              ...config.personalityTraits,
            } : state.toyConfig.personalityTraits,
            safetySettings: config.safetySettings ? {
              ...state.toyConfig.safetySettings,
              ...config.safetySettings,
            } : state.toyConfig.safetySettings,
            knowledgeBase: config.knowledgeBase ? {
              ...state.toyConfig.knowledgeBase,
              ...config.knowledgeBase,
            } : state.toyConfig.knowledgeBase,
          },
        }));
      },

      updateToyConfig: (key, value) => {
        set((state) => ({
          toyConfig: {
            ...state.toyConfig,
            [key]: value,
          },
        }));
      },

      updatePersonalityTraits: (traits) => {
        set((state) => ({
          toyConfig: {
            ...state.toyConfig,
            personalityTraits: {
              ...state.toyConfig.personalityTraits,
              ...traits,
              speakingStyle: traits.speakingStyle
                ? { ...state.toyConfig.personalityTraits.speakingStyle, ...traits.speakingStyle }
                : state.toyConfig.personalityTraits.speakingStyle,
              behavior: traits.behavior
                ? { ...state.toyConfig.personalityTraits.behavior, ...traits.behavior }
                : state.toyConfig.personalityTraits.behavior,
            },
          },
        }));
      },

      updateKnowledgeBase: (kb) => {
        set((state) => ({
          toyConfig: {
            ...state.toyConfig,
            knowledgeBase: state.toyConfig.knowledgeBase
              ? {
                  ...state.toyConfig.knowledgeBase,
                  ...kb,
                  toyBackstory: kb.toyBackstory
                    ? { ...state.toyConfig.knowledgeBase.toyBackstory, ...kb.toyBackstory }
                    : state.toyConfig.knowledgeBase.toyBackstory,
                  familyInfo: kb.familyInfo
                    ? { ...state.toyConfig.knowledgeBase.familyInfo, ...kb.familyInfo }
                    : state.toyConfig.knowledgeBase.familyInfo,
                }
              : {
                  toyBackstory: {
                    origin: '',
                    personality: '',
                    specialAbilities: [],
                    favoriteThings: [],
                  },
                  customFacts: [],
                  ...kb,
                },
          },
        }));
      },

      updateSafetySettings: (settings) => {
        set((state) => ({
          toyConfig: {
            ...state.toyConfig,
            safetySettings: state.toyConfig.safetySettings
              ? {
                  ...state.toyConfig.safetySettings,
                  ...settings,
                  contentFilters: settings.contentFilters
                    ? {
                        ...state.toyConfig.safetySettings.contentFilters,
                        ...settings.contentFilters,
                      }
                    : state.toyConfig.safetySettings.contentFilters,
                }
              : {
                  safetyLevel: 'moderate',
                  contentFilters: {
                    enabledCategories: [],
                    customBlockedTopics: [],
                  },
                  ...settings,
                },
          },
        }));
      },

      setError: (field, error) => {
        set((state) => ({
          errors: {
            ...state.errors,
            [field]: error,
          },
        }));
      },

      clearError: (field) => {
        set((state) => {
          const { [field]: _, ...rest } = state.errors;
          return { errors: rest };
        });
      },

      clearAllErrors: () => {
        set({ errors: {} });
      },

      setIsCreating: (isCreating) => {
        set({ isCreating });
      },

      resetWizard: () => {
        set({
          currentStep: 'welcome',
          completedSteps: [],
          toyConfig: defaultToyConfig,
          errors: {},
          isCreating: false,
        });
      },

      canProceedToStep: (step) => {
        const state = get();
        const requiredSteps = stepDependencies[step];
        return requiredSteps.every((s) => state.completedSteps.includes(s));
      },
    }),
    {
      name: 'toy-wizard-storage',
      partialize: (state) => ({
        toyConfig: state.toyConfig,
        completedSteps: state.completedSteps,
        currentStep: state.currentStep,
      }),
    }
  )
);
</file>

<file path="src/stores/useAuthStore.ts">
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

export interface User {
  id: string;
  email: string;
  name: string;
  image?: string;
  createdAt: Date;
  isGuardian?: boolean;
}

export interface AuthError {
  code: string;
  message: string;
  field?: string;
}

interface AuthState {
  // State
  user: User | null;
  isLoading: boolean;
  error: AuthError | null;
  isInitialized: boolean;
  
  // Actions
  setUser: (user: User | null) => void;
  setLoading: (loading: boolean) => void;
  setError: (error: AuthError | null) => void;
  clearError: () => void;
  setInitialized: (initialized: boolean) => void;
  
  // Auth actions
  login: (email: string, password: string) => Promise<void>;
  signup: (email: string, password: string, name: string) => Promise<void>;
  logout: () => void;
  reset: () => void;
  
  // Error helpers
  getErrorMessage: (error: unknown) => string;
  isFieldError: (field: string) => boolean;
}

export const useAuthStore = create<AuthState>()(
  persist(
    (set, get) => ({
      // Initial state
      user: null,
      isLoading: false,
      error: null,
      isInitialized: false,
      
      // State setters
      setUser: (user) => set({ user }),
      setLoading: (isLoading) => set({ isLoading }),
      setError: (error) => set({ error }),
      clearError: () => set({ error: null }),
      setInitialized: (isInitialized) => set({ isInitialized }),
      
      // Auth actions (to be implemented with auth service)
      login: async (email: string, password: string) => {
        set({ isLoading: true, error: null });
        try {
          // TODO: Implement with authClient
          console.log('Login:', { email, password });
        } catch (error: unknown) {
          const err = error as { code?: string } | undefined;
          set({ 
            error: {
              code: err?.code || 'LOGIN_FAILED',
              message: get().getErrorMessage(error)
            }
          });
        } finally {
          set({ isLoading: false });
        }
      },
      
      signup: async (email: string, password: string, name: string) => {
        set({ isLoading: true, error: null });
        try {
          // TODO: Implement with authClient
          console.log('Signup:', { email, password, name });
        } catch (error: unknown) {
          const err = error as { code?: string } | undefined;
          set({ 
            error: {
              code: err?.code || 'SIGNUP_FAILED',
              message: get().getErrorMessage(error)
            }
          });
        } finally {
          set({ isLoading: false });
        }
      },
      
      logout: () => {
        set({ user: null, error: null });
      },
      
      reset: () => {
        set({
          user: null,
          isLoading: false,
          error: null,
          isInitialized: false,
        });
      },
      
      // Error helpers
      getErrorMessage: (error: unknown): string => {
        if (typeof error === 'string') return error;
        if (error instanceof Error) return error.message;
        if (typeof error === 'object' && error !== null) {
          const e = error as { message?: string; error?: { message?: string }; code?: string };
          if (typeof e.message === 'string') return e.message;
          if (e.error && typeof e.error.message === 'string') return e.error.message;
          switch (e.code) {
            case 'INVALID_CREDENTIALS':
              return 'Invalid email or password';
            case 'USER_NOT_FOUND':
              return 'No account found with this email';
            case 'WEAK_PASSWORD':
              return 'Password must be at least 8 characters long';
            case 'EMAIL_ALREADY_EXISTS':
              return 'An account with this email already exists';
            case 'INVALID_EMAIL':
              return 'Please enter a valid email address';
          }
        }
        return 'An unexpected error occurred. Please try again.';
      },
      
      isFieldError: (field: string): boolean => {
        return get().error?.field === field;
      },
    }),
    {
      name: 'pommai-auth-store',
      partialize: (state) => ({
        user: state.user,
        isInitialized: state.isInitialized,
      }),
    }
  )
);
</file>

<file path="src/stores/useDeviceStore.ts">
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

export type DeviceStatus = 'disconnected' | 'connecting' | 'connected' | 'error';
export type ConnectionType = 'bluetooth' | 'wifi' | 'qr';

export interface Device {
  id: string;
  name: string;
  type: string; // 'raspberry-pi', 'arduino', etc.
  status: DeviceStatus;
  lastSeen?: Date;
  toyId?: string; // Currently assigned toy
  ipAddress?: string;
  bluetoothAddress?: string;
  firmwareVersion?: string;
  batteryLevel?: number;
  signalStrength?: number;
}

export interface PairingSession {
  id: string;
  type: ConnectionType;
  deviceId?: string;
  qrCode?: string;
  isActive: boolean;
  expiresAt: Date;
}

interface DeviceState {
  // Data
  devices: Device[];
  selectedDevice: Device | null;
  isScanning: boolean;
  error: string | null;
  
  // Pairing
  pairingSession: PairingSession | null;
  isPairing: boolean;
  pairingStep: 'method' | 'scanning' | 'connecting' | 'success' | 'error';
  
  // Actions
  setDevices: (devices: Device[]) => void;
  addDevice: (device: Device) => void;
  updateDevice: (deviceId: string, updates: Partial<Device>) => void;
  removeDevice: (deviceId: string) => void;
  setSelectedDevice: (device: Device | null) => void;
  setScanning: (scanning: boolean) => void;
  setError: (error: string | null) => void;
  
  // Pairing actions
  startPairing: (type: ConnectionType) => Promise<void>;
  stopPairing: () => void;
  setPairingStep: (step: DeviceState['pairingStep']) => void;
  
  // Device management
  connectDevice: (deviceId: string) => Promise<void>;
  disconnectDevice: (deviceId: string) => Promise<void>;
  assignToyToDevice: (deviceId: string, toyId: string) => Promise<void>;
  unassignToyFromDevice: (deviceId: string) => Promise<void>;
  
  // Computed
  connectedDevices: () => Device[];
  availableDevices: () => Device[];
  devicesByToy: () => Record<string, Device>;
  
  reset: () => void;
}

export const useDeviceStore = create<DeviceState>()(
  persist(
    (set, get) => ({
      // Initial state
      devices: [],
      selectedDevice: null,
      isScanning: false,
      error: null,
      
      // Pairing state
      pairingSession: null,
      isPairing: false,
      pairingStep: 'method',
      
      // Data actions
      setDevices: (devices) => set({ devices, error: null }),
      
      addDevice: (device) => set((state) => ({
        devices: [...state.devices.filter(d => d.id !== device.id), device]
      })),
      
      updateDevice: (deviceId, updates) => set((state) => ({
        devices: state.devices.map(device => 
          device.id === deviceId 
            ? { ...device, ...updates, lastSeen: new Date() } 
            : device
        ),
        selectedDevice: state.selectedDevice?.id === deviceId
          ? { ...state.selectedDevice, ...updates }
          : state.selectedDevice
      })),
      
      removeDevice: (deviceId) => set((state) => ({
        devices: state.devices.filter(device => device.id !== deviceId),
        selectedDevice: state.selectedDevice?.id === deviceId 
          ? null 
          : state.selectedDevice
      })),
      
      setSelectedDevice: (selectedDevice) => set({ selectedDevice }),
      setScanning: (isScanning) => set({ isScanning }),
      setError: (error) => set({ error }),
      
      // Pairing actions
      startPairing: async (type: ConnectionType) => {
        set({ 
          isPairing: true, 
          pairingStep: 'scanning',
          error: null,
          pairingSession: {
            id: `pair_${Date.now()}`,
            type,
            isActive: true,
            expiresAt: new Date(Date.now() + 10 * 60 * 1000) // 10 minutes
          }
        });
        
        try {
          // TODO: Implement actual pairing logic
          if (type === 'qr') {
            // Generate QR code for device setup
            set((state) => ({
              pairingSession: state.pairingSession ? {
                ...state.pairingSession,
                qrCode: `pommai://pair/${state.pairingSession.id}`
              } : null
            }));
          }
          
          // Simulate pairing process
          setTimeout(() => {
            set({ pairingStep: 'connecting' });
            
            setTimeout(() => {
              // Mock successful pairing
              const mockDevice: Device = {
                id: `device_${Date.now()}`,
                name: 'Raspberry Pi Zero 2W',
                type: 'raspberry-pi',
                status: 'connected',
                lastSeen: new Date(),
                firmwareVersion: '1.0.0',
                batteryLevel: 85,
                signalStrength: -45,
              };
              
              get().addDevice(mockDevice);
              set({ 
                pairingStep: 'success',
                selectedDevice: mockDevice,
                isPairing: false,
                pairingSession: null
              });
            }, 2000);
          }, 3000);
          
        } catch (error: unknown) {
          const message = error instanceof Error ? error.message : 'Pairing failed';
          set({ 
            error: message,
            pairingStep: 'error',
            isPairing: false
          });
        }
      },
      
      stopPairing: () => set({ 
        isPairing: false, 
        pairingSession: null,
        pairingStep: 'method'
      }),
      
      setPairingStep: (pairingStep) => set({ pairingStep }),
      
      // Device management
      connectDevice: async (deviceId: string) => {
        set({ error: null });
        try {
          get().updateDevice(deviceId, { status: 'connecting' });
          
          // TODO: Implement actual connection logic
          await new Promise(resolve => setTimeout(resolve, 2000));
          
          get().updateDevice(deviceId, { status: 'connected' });
        } catch (error: unknown) {
          get().updateDevice(deviceId, { status: 'error' });
          const message = error instanceof Error ? error.message : 'Failed to connect device';
          set({ error: message });
        }
      },
      
      disconnectDevice: async (deviceId: string) => {
        try {
          // TODO: Implement actual disconnection logic
          get().updateDevice(deviceId, { status: 'disconnected' });
        } catch (error: unknown) {
          const message = error instanceof Error ? error.message : 'Failed to disconnect device';
          set({ error: message });
        }
      },
      
      assignToyToDevice: async (deviceId: string, toyId: string) => {
        try {
          // TODO: Send toy configuration to device
          get().updateDevice(deviceId, { toyId });
        } catch (error: unknown) {
          const message = error instanceof Error ? error.message : 'Failed to assign toy to device';
          set({ error: message });
        }
      },
      
      unassignToyFromDevice: async (deviceId: string) => {
        try {
          get().updateDevice(deviceId, { toyId: undefined });
        } catch (error: unknown) {
          const message = error instanceof Error ? error.message : 'Failed to unassign toy from device';
          set({ error: message });
        }
      },
      
      // Computed getters
      connectedDevices: () => 
        get().devices.filter(device => device.status === 'connected'),
      
      availableDevices: () => 
        get().devices.filter(device => 
          device.status === 'connected' || device.status === 'disconnected'
        ),
      
      devicesByToy: () => {
        const devices = get().devices;
        const result: Record<string, Device> = {};
        devices.forEach(device => {
          if (device.toyId) {
            result[device.toyId] = device;
          }
        });
        return result;
      },
      
      reset: () => set({
        devices: [],
        selectedDevice: null,
        isScanning: false,
        error: null,
        pairingSession: null,
        isPairing: false,
        pairingStep: 'method',
      }),
    }),
    {
      name: 'pommai-device-store',
      partialize: (state) => ({
        devices: state.devices,
      }),
    }
  )
);
</file>

<file path="src/stores/useToysStore.ts">
import { create } from 'zustand';
import { subscribeWithSelector } from 'zustand/middleware';

export type ToyStatus = 'active' | 'paused' | 'archived';
export type ToyType = 'teddy' | 'bunny' | 'cat' | 'dog' | 'bird' | 'fish' | 'robot' | 'magical';

export interface Toy {
  _id: string;
  name: string;
  type: ToyType;
  status: ToyStatus;
  isForKids: boolean;
  voiceId: string;
  voiceName?: string;
  personalityPrompt: string;
  isPublic: boolean;
  tags: string[];
  createdAt: string;
  updatedAt: string;
  conversationCount: number;
  messageCount: number;
  lastActiveAt?: string;
  deviceId?: string;
}

export interface ToyFilters {
  search: string;
  status: 'all' | ToyStatus;
  type: 'all' | ToyType;
  isForKids: 'all' | 'true' | 'false';
}

interface ToysState {
  // Data
  toys: Toy[];
  selectedToy: Toy | null;
  isLoading: boolean;
  error: string | null;
  
  // UI State
  viewMode: 'grid' | 'list';
  filters: ToyFilters;
  sortBy: 'name' | 'created' | 'lastActive' | 'conversations';
  sortOrder: 'asc' | 'desc';
  
  // Actions
  setToys: (toys: Toy[]) => void;
  addToy: (toy: Toy) => void;
  updateToy: (toyId: string, updates: Partial<Toy>) => void;
  removeToy: (toyId: string) => void;
  setSelectedToy: (toy: Toy | null) => void;
  setLoading: (loading: boolean) => void;
  setError: (error: string | null) => void;
  
  // UI Actions
  setViewMode: (mode: 'grid' | 'list') => void;
  updateFilters: (filters: Partial<ToyFilters>) => void;
  setSorting: (sortBy: ToysState['sortBy'], sortOrder: ToysState['sortOrder']) => void;
  clearFilters: () => void;
  
  // Computed
  filteredToys: () => Toy[];
  toysByStatus: () => Record<ToyStatus, Toy[]>;
  activeToys: () => Toy[];
  kidsModeToys: () => Toy[];
  
  // Actions
  reset: () => void;
}

const defaultFilters: ToyFilters = {
  search: '',
  status: 'all',
  type: 'all',
  isForKids: 'all',
};

export const useToysStore = create<ToysState>()(
  subscribeWithSelector((set, get) => ({
    // Initial state
    toys: [],
    selectedToy: null,
    isLoading: false,
    error: null,
    
    // UI State
    viewMode: 'grid',
    filters: defaultFilters,
    sortBy: 'created',
    sortOrder: 'desc',
    
    // Data actions
    setToys: (toys) => set({ toys, error: null }),
    
    addToy: (toy) => set((state) => ({
      toys: [toy, ...state.toys]
    })),
    
    updateToy: (toyId, updates) => set((state) => ({
      toys: state.toys.map(toy => 
        toy._id === toyId ? { ...toy, ...updates } : toy
      ),
      selectedToy: state.selectedToy?._id === toyId 
        ? { ...state.selectedToy, ...updates }
        : state.selectedToy
    })),
    
    removeToy: (toyId) => set((state) => ({
      toys: state.toys.filter(toy => toy._id !== toyId),
      selectedToy: state.selectedToy?._id === toyId ? null : state.selectedToy
    })),
    
    setSelectedToy: (toy) => set({ selectedToy: toy }),
    setLoading: (isLoading) => set({ isLoading }),
    setError: (error) => set({ error }),
    
    // UI actions
    setViewMode: (viewMode) => set({ viewMode }),
    
    updateFilters: (newFilters) => set((state) => ({
      filters: { ...state.filters, ...newFilters }
    })),
    
    setSorting: (sortBy, sortOrder) => set({ sortBy, sortOrder }),
    
    clearFilters: () => set({ filters: defaultFilters }),
    
    // Computed getters
    filteredToys: () => {
      const { toys, filters, sortBy, sortOrder } = get();
      
      const filtered = toys.filter(toy => {
        // Search filter
        if (filters.search) {
          const searchLower = filters.search.toLowerCase();
          if (!toy.name.toLowerCase().includes(searchLower) && 
              !toy.type.toLowerCase().includes(searchLower) &&
              !toy.tags.some(tag => tag.toLowerCase().includes(searchLower))) {
            return false;
          }
        }
        
        // Status filter
        if (filters.status !== 'all' && toy.status !== filters.status) {
          return false;
        }
        
        // Type filter
        if (filters.type !== 'all' && toy.type !== filters.type) {
          return false;
        }
        
        // Kids mode filter
        if (filters.isForKids !== 'all') {
          const isForKidsFilter = filters.isForKids === 'true';
          if (toy.isForKids !== isForKidsFilter) {
            return false;
          }
        }
        
        return true;
      });
      
      // Sort
      filtered.sort((a, b) => {
        let comparison = 0;
        
        switch (sortBy) {
          case 'name':
            comparison = a.name.localeCompare(b.name);
            break;
          case 'created':
            comparison = new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime();
            break;
          case 'lastActive':
            const aLastActive = a.lastActiveAt ? new Date(a.lastActiveAt).getTime() : 0;
            const bLastActive = b.lastActiveAt ? new Date(b.lastActiveAt).getTime() : 0;
            comparison = aLastActive - bLastActive;
            break;
          case 'conversations':
            comparison = a.conversationCount - b.conversationCount;
            break;
        }
        
        return sortOrder === 'asc' ? comparison : -comparison;
      });
      
      return filtered;
    },
    
    toysByStatus: () => {
      const toys = get().toys;
      return {
        active: toys.filter(toy => toy.status === 'active'),
        paused: toys.filter(toy => toy.status === 'paused'),
        archived: toys.filter(toy => toy.status === 'archived'),
      };
    },
    
    activeToys: () => get().toys.filter(toy => toy.status === 'active'),
    kidsModeToys: () => get().toys.filter(toy => toy.isForKids),
    
    reset: () => set({
      toys: [],
      selectedToy: null,
      isLoading: false,
      error: null,
      viewMode: 'grid',
      filters: defaultFilters,
      sortBy: 'created',
      sortOrder: 'desc',
    }),
  }))
);
</file>

<file path="src/types/history.ts">
export interface ConversationSummary {
  id: string;
  toyId: string;
  toyName: string;
  startTime: number;
  endTime: number;
  duration: number;
  participantChild?: string;
  messageCount: number;
  flaggedMessages: number;
  sentiment: 'positive' | 'neutral' | 'negative';
  topics: string[];
  location: 'toy' | 'web' | 'app';
}

export interface MessageAnalysis {
  topics: string[];
  educationalValue: number;
  emotionalTone: string;
  safetyFlags: string[];
}

export interface HistoryMessage {
  id: string;
  conversationId: string;
  content: string;
  role: 'user' | 'toy';
  timestamp: number;
  audioUrl?: string;
  metadata?: {
    sentiment?: string;
    safetyScore?: number;
    flagged?: boolean;
  };
  analysis?: MessageAnalysis;
}

export interface ConversationHistory {
  conversations: ConversationSummary[];
  messages: HistoryMessage[];
}

export interface ViewerFeatures {
  timeline: {
    view: 'day' | 'week' | 'month';
    navigation: 'calendar' | 'scroll';
    highlights: 'all' | 'flagged' | 'educational';
  };
  search: {
    query: string;
    dateRange: { from: Date | null; to: Date | null };
    topics: string[];
    sentiment: ('positive' | 'neutral' | 'negative')[];
    participants: string[];
  };
  analytics: {
    conversationFrequency: unknown; // Chart data
    topicDistribution: unknown; // PieChart data
    sentimentTrends: unknown; // LineChart data
    vocabularyGrowth: unknown; // ProgressChart data
    safetyIncidents: unknown; // IncidentLog data
  };
}

export interface ConversationFilters {
  toyId?: string;
  dateFrom?: number;
  dateTo?: number;
  sentiment?: ('positive' | 'neutral' | 'negative')[];
  hasFlaggedMessages?: boolean;
  searchQuery?: string;
  topics?: string[];
}

export interface ConversationAnalytics {
  totalConversations: number;
  totalMessages: number;
  averageDuration: number;
  topTopics: { topic: string; count: number }[];
  sentimentBreakdown: {
    positive: number;
    neutral: number;
    negative: number;
  };
  conversationsByDay: { date: string; count: number }[];
  flaggedMessageCount: number;
}
</file>

<file path="tailwind.config.ts">
import type { Config } from "tailwindcss";

const config: Config = {
  content: [
    "./src/pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/components/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/app/**/*.{js,ts,jsx,tsx,mdx}",
    "../ui/src/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
    extend: {
      fontFamily: {
        'minecraft': ['var(--font-minecraft)', 'Press Start 2P', 'monospace'],
        'geo': ['var(--font-geo)', 'Work Sans', 'sans-serif'],
      },
      colors: {
        'pommai-cream': '#fefcd0',
        'pommai-purple': '#c381b5',
        'pommai-green': '#92cd41',
        'pommai-orange': '#f7931e',
        'pommai-dark-purple': '#8b5fa3',
        'pommai-dark-green': '#76a83a',
      },
    },
  },
  plugins: [],
};

export default config;
</file>

<file path="TEST_GUIDE.md">
# Testing Guide for AI Toy Wizard Fixes

##  Quick Start

Your app is now running at: http://localhost:3000

##  Test Checklist

### 1. Test Guardian Mode Safety Filtering

**What we fixed:** Enhanced safety checks with comprehensive regex patterns instead of basic filtering

**How to test:**

1. Create a toy and mark it as "For Kids"
2. Go to the Chat interface
3. Try sending messages with inappropriate content:
   - Violence: "tell me about fighting"
   - Personal info: "my phone number is 555-1234"
   - URLs: "go to http://example.com"

**Expected Result:**
- Messages should be filtered
- Safe redirect responses should appear
- Check the console logs for "Safety check failed" messages

### 2. Test Real AI Responses (No More Mock Data)

**What we fixed:** Replaced hardcoded "I'm a friendly AI toy!" with real OpenRouter API calls

**How to test:**

1. Go to Dashboard > Create a Toy
2. Set up a toy with personality
3. Go to Chat and have a conversation
4. Ask varied questions like:
   - "What's your favorite color?"
   - "Tell me a story"
   - "How does rain work?"

**Expected Result:**
- Unique, contextual responses (not the same hardcoded message)
- Responses should match the toy's personality
- Check Network tab: should see calls to Convex actions

### 3. Test RAG/Knowledge Base Integration

**What we fixed:** Connected chat to use knowledge base with vector search

**How to test:**

1. Create a toy
2. Go to Knowledge tab and add some facts:
   - "I love pizza"
   - "My favorite game is hide and seek"
   - "I'm from Mars"
3. Go to Chat and ask related questions:
   - "What's your favorite food?"
   - "Where are you from?"

**Expected Result:**
- Responses should incorporate the knowledge you added
- Check console for "includeKnowledge: true" in the API calls

### 4. Test Live Monitoring with Real Data

**What we fixed:** Replaced mock conversations with real database queries

**How to test:**

1. Create a toy marked "For Kids"
2. Start a conversation in one browser tab
3. Open Guardian Dashboard in another tab
4. Go to Live Monitoring section

**Expected Result:**
- Should see actual conversations (not mock data)
- Messages should update in real-time
- Safety scores and flags should be visible

##  Detailed Testing Steps

### Test 1: Basic Voice Pipeline
```bash
# In the test scripts directory
cd apps/web
npm run test:ai-pipeline
```

This tests:
- STT (Speech-to-Text)
- LLM Response Generation
- TTS (Text-to-Speech)

### Test 2: Agent Thread System

1. Open browser console
2. Create a toy
3. Start a chat
4. Look for these in Network tab:
   - `getOrCreateToyThread` - Creates conversation thread
   - `saveAudioMessage` - Saves user message
   - `generateToyResponseWithKnowledge` - Gets AI response with RAG

### Test 3: Safety Gates

For kids' toys, test the 3-gate system:

**Gate 1 - Input Filter:**
- Type: "let's fight"
- Should be blocked before reaching LLM

**Gate 2 - System Prompt:**
- Check that responses are child-appropriate
- Short sentences, positive tone

**Gate 3 - Output Filter:**
- Even if LLM generates something inappropriate, it should be caught

##  Debugging Tips

### Check if AI Services are Working:

1. Open browser DevTools > Network tab
2. Look for these Convex actions:
   - `aiServices.transcribeAudio`
   - `aiServices.generateResponse`
   - `aiServices.synthesizeSpeech`

### Check if RAG is Working:

1. In Console, you should see:
   - "Step 1: Get or create the canonical agent thread"
   - "Step 2: Save the user's message to the agent thread"
   - "Step 3: Generate response with RAG-enabled knowledge retrieval"

### Common Issues:

**No AI responses:**
- Check `.env.local` has `OPENROUTER_API_KEY`
- Check console for API errors

**Mock data still showing:**
- Make sure you're using the updated components
- Check that Convex is deployed: `npx convex deploy`

**Knowledge not being used:**
- Ensure toy has an `agentThreadId`
- Check that knowledge was added via the Knowledge tab

##  What Success Looks Like

 **Guardian Mode:** Inappropriate content gets filtered with safe redirects
 **Real AI:** Each response is unique and contextual
 **RAG Working:** Toy remembers and uses knowledge you've added
 **Live Monitoring:** Shows real conversations, not mock data
 **Safety Scores:** Messages show appropriate safety ratings

##  Quick Test Sequence

1. **Create Account**  Sign up at http://localhost:3000/auth
2. **Create Toy**  Dashboard > Create Toy > Mark "For Kids"
3. **Add Knowledge**  Knowledge tab > Add facts about the toy
4. **Test Chat**  Try both safe and unsafe messages
5. **Check Monitoring**  Guardian Dashboard > Live Monitoring

##  Key URLs

- Main App: http://localhost:3000
- Dashboard: http://localhost:3000/dashboard
- Chat: http://localhost:3000/dashboard/chat
- Guardian: http://localhost:3000/dashboard (Guardian tab)
- History: http://localhost:3000/dashboard/history

##  Testing Checklist

- [ ] Can create a toy
- [ ] Chat gives unique responses (not hardcoded)
- [ ] Knowledge base affects responses
- [ ] Safety filtering works for kids mode
- [ ] Live monitoring shows real conversations
- [ ] Messages have safety scores
- [ ] Flagged content triggers alerts

##  If Something Doesn't Work

1. Check browser console for errors
2. Check Network tab for failed API calls
3. Run `npx convex logs` to see backend logs
4. Verify environment variables in `.env.local`
5. Make sure Convex is deployed: `npx convex deploy`

##  Support

If you encounter issues:
1. Check the console logs
2. Look at Network tab for API errors
3. Run `npx convex logs` for backend debugging
4. Check that all environment variables are set correctly
</file>

<file path="test-action.js">
const { ConvexClient } = require("convex/browser");

async function test() {
    const client = new ConvexClient("https://warmhearted-snail-998.convex.cloud");
    
    // Minimal WAV file (silence)
    const testAudio = "UklGRiQAAABXQVZFZm10IBAAAAABAAEAQB8AAEB9AAACABAAZGF0YQAAAAA=";
    
    try {
        console.log("Testing Convex action...");
        const result = await client.action("aiPipeline:processVoiceInteraction", {
            toyId: "kd729cad81984f52pz1v1f3gh57q3774",
            audioData: testAudio,
            sessionId: "test",
            deviceId: "test",
            metadata: {
                timestamp: Date.now(),
                format: "wav",
                duration: 0
            }
        });
        console.log("Result:", result);
    } catch (error) {
        console.error("Error:", error);
    } finally {
        await client.close();
    }
}

test();
</file>

<file path="test-auth.js">
// Test script to verify authentication configuration
// Run with: node test-auth.js

const fs = require('fs');
const path = require('path');

const testAuth = async () => {
  console.log(' Checking authentication configuration...\n');
  
  // Read .env.local file
  const envPath = path.join(__dirname, '.env.local');
  const envContent = fs.readFileSync(envPath, 'utf8');
  const envLines = envContent.split('\n');
  
  // Parse environment variables
  const envVars = {};
  envLines.forEach(line => {
    if (line && !line.startsWith('#')) {
      const [key, ...valueParts] = line.split('=');
      if (key) {
        envVars[key.trim()] = valueParts.join('=').trim();
      }
    }
  });
  
  console.log(' Environment Variables Check:');
  console.log('================================\n');
  
  // Check CONVEX URLs
  const convexUrl = envVars['NEXT_PUBLIC_CONVEX_URL'];
  const convexSiteUrl = envVars['NEXT_PUBLIC_CONVEX_SITE_URL'];
  
  console.log(`NEXT_PUBLIC_CONVEX_URL: ${convexUrl}`);
  console.log(`NEXT_PUBLIC_CONVEX_SITE_URL: ${convexSiteUrl}`);
  
  // Extract deployment IDs
  const convexId = convexUrl?.match(/https:\/\/([^.]+)\.convex\.cloud/)?.[1];
  const siteId = convexSiteUrl?.match(/https:\/\/([^.]+)\.convex\.site/)?.[1];
  
  console.log(`\n Deployment IDs:`);
  console.log(`  Convex deployment: ${convexId}`);
  console.log(`  Site deployment: ${siteId}`);
  
  // Check if they match
  if (convexId === siteId) {
    console.log('\n SUCCESS: Deployment IDs match!');
    console.log(`   Both are using: ${convexId}`);
  } else {
    console.log('\n ERROR: Deployment IDs do not match!');
    console.log(`   This causes authentication failures.`);
    console.log(`   Please ensure both URLs use the same deployment ID.`);
  }
  
  // Check other required auth variables
  console.log('\n Other Auth Configuration:');
  console.log('============================\n');
  
  const authSecret = envVars['BETTER_AUTH_SECRET'];
  const baseUrl = envVars['NEXT_PUBLIC_BASE_URL'];
  const siteUrl = envVars['SITE_URL'];
  
  console.log(`BETTER_AUTH_SECRET: ${authSecret ? ' Set' : ' Missing'}`);
  console.log(`NEXT_PUBLIC_BASE_URL: ${baseUrl || ' Missing'}`);
  console.log(`SITE_URL: ${siteUrl || ' Missing'}`);
  
  // Final verdict
  console.log('\n Authentication Configuration Status:');
  console.log('=====================================\n');
  
  if (convexId === siteId && authSecret && baseUrl && siteUrl) {
    console.log(' All authentication settings are properly configured!');
    console.log('\nThe authentication error should now be resolved.');
    console.log('Try refreshing your browser and signing in again.');
  } else {
    console.log(' There are issues with your authentication configuration.');
    console.log('\nPlease fix the issues mentioned above and restart your server.');
  }
  
  // Expected auth flow
  console.log('\n Expected Authentication Flow:');
  console.log('================================\n');
  console.log('1. Client authenticates with Better Auth at SITE_URL');
  console.log('2. Better Auth creates a JWT token with issuer: ' + convexSiteUrl);
  console.log('3. Token is validated by Convex with domain: ' + convexSiteUrl);
  console.log('4. Convex accepts the token if issuer matches configured domain');
  console.log('\nThe error you saw means the JWT issuer didn\'t match the configured domain.');
};

// Run the test
testAuth().catch(console.error);
</file>

<file path="test-chat.js">
// Test script to verify chat simulator AI responses
// Run with: node test-chat.js

const testChatSimulator = async () => {
  console.log('Testing chat simulator AI responses...\n');
  
  // Test message content normalization
  const testCases = [
    {
      name: 'Simple string',
      content: 'Hello, how are you?',
      expected: 'Hello, how are you?'
    },
    {
      name: 'Content array with text objects',
      content: [
        { type: 'text', text: 'What is your name?' }
      ],
      expected: 'What is your name?'
    },
    {
      name: 'Complex nested content',
      content: {
        type: 'text',
        text: 'Tell me a story'
      },
      expected: 'Tell me a story'
    },
    {
      name: 'Multiple content parts',
      content: [
        { type: 'text', text: 'First part' },
        { type: 'text', text: 'Second part' }
      ],
      expected: 'First part Second part'
    }
  ];

  // Simulate the content extraction logic from our fix
  const extractTextContent = (content) => {
    if (typeof content === 'string') {
      return content;
    }
    
    if (Array.isArray(content)) {
      const textParts = content
        .filter(item => item && (item.type === 'text' || item.text || item.content))
        .map(item => {
          if (typeof item === 'string') return item;
          if (item.type === 'text' && item.text) return item.text;
          if (item.content) return item.content;
          if (item.text) return item.text;
          return '';
        })
        .filter(Boolean);
      return textParts.join(' ');
    }
    
    if (content && typeof content === 'object') {
      return content.text || content.content || 
        (content.type === 'text' && content.value) || '';
    }
    
    return '';
  };

  // Run tests
  let passed = 0;
  let failed = 0;
  
  for (const test of testCases) {
    const result = extractTextContent(test.content);
    if (result === test.expected) {
      console.log(` ${test.name}: PASSED`);
      console.log(`   Result: "${result}"`);
      passed++;
    } else {
      console.log(` ${test.name}: FAILED`);
      console.log(`   Expected: "${test.expected}"`);
      console.log(`   Got: "${result}"`);
      failed++;
    }
    console.log('');
  }
  
  console.log(`\n Test Results: ${passed} passed, ${failed} failed`);
  
  if (failed === 0) {
    console.log(' All tests passed! The chat simulator should now work correctly.');
    console.log('\n Next steps:');
    console.log('1. Open http://localhost:3000 in your browser');
    console.log('2. Select a toy and open the chat simulator');
    console.log('3. Send a message and verify you get a proper AI response');
    console.log('4. Check that the response is coherent and not showing [object Object]');
  } else {
    console.log(' Some tests failed. Please review the normalization logic.');
  }
};

// Run the test
testChatSimulator().catch(console.error);
</file>

<file path="test-prod-convex.js">
#!/usr/bin/env node
const { ConvexClient } = require("convex/browser");

const CONVEX_URL = "https://warmhearted-snail-998.convex.cloud";

async function testProductionConvex() {
  const client = new ConvexClient(CONVEX_URL);
  
  try {
    // Test 1: Check if toy exists
    console.log("Testing production deployment...");
    console.log("Convex URL:", CONVEX_URL);
    
    // Create minimal WAV audio (silence)
    const minimalWav = "UklGRiQAAABXQVZFZm10IBAAAAABAAEAQB8AAEB9AAACABAAZGF0YQAAAAA=";
    
    const args = {
      toyId: "kd729cad81984f52pz1v1f3gh57q3774",
      audioData: minimalWav,
      sessionId: "test-session",
      deviceId: "test-device",
      metadata: {
        timestamp: Date.now(),
        format: "wav",
        duration: 0
      }
    };
    
    console.log("Calling aiPipeline:processVoiceInteraction...");
    console.log("Toy ID:", args.toyId);
    
    // Set a timeout
    const timeoutPromise = new Promise((_, reject) => 
      setTimeout(() => reject(new Error("Timeout after 30 seconds")), 30000)
    );
    
    const actionPromise = client.action("aiPipeline:processVoiceInteraction", args);
    
    const result = await Promise.race([actionPromise, timeoutPromise]);
    
    console.log("Success! Result:", result);
    
  } catch (error) {
    console.error("Error:", error.message);
    
    // Try a simpler query
    console.log("\nTrying to query the toy directly...");
    try {
      const toy = await client.query("toys:getToy", { 
        toyId: "kd729cad81984f52pz1v1f3gh57q3774" 
      });
      console.log("Toy found:", toy);
    } catch (err) {
      console.error("Failed to get toy:", err.message);
    }
  } finally {
    await client.close();
  }
}

testProductionConvex().catch(console.error);
</file>

<file path="test-toy-update.js">
// Test script to verify toy update functionality
console.log(' Testing Toy Update Functionality\n');
console.log('=====================================\n');

console.log(' Changes Made:\n');
console.log('1. Added "type" field to updateToy mutation in convex/toys.ts');
console.log('2. Added "type" field to the update call in EditToyForm.tsx');
console.log('3. Added debug logging to track what data is being saved');
console.log('');

console.log(' How to Test:\n');
console.log('1. Navigate to http://localhost:3000/dashboard');
console.log('2. Click the edit button (pencil icon) on any toy');
console.log('3. Change the toy type (e.g., from Fish to Bear)');
console.log('4. Change the name if desired');
console.log('5. Click "Save Changes"');
console.log('6. Open browser DevTools Console (F12) to see debug logs');
console.log('');

console.log(' What to Look For in Console:\n');
console.log('- "Saving toy with config:" log showing the data being saved');
console.log('- "Toy updated successfully!" if the update worked');
console.log('- Any error messages if something failed');
console.log('');

console.log(' Fields That Can Be Updated:\n');
console.log(' name - Toy name');
console.log(' type - Toy type (teddy, bunny, cat, dog, bird, fish, robot, magical)');
console.log(' personalityPrompt - Personality description');
console.log(' personalityTraits - Traits, speaking style, behaviors');
console.log(' voiceId - Voice selection');
console.log(' safetyLevel - Safety settings for kids mode');
console.log(' contentFilters - Content filtering settings');
console.log(' tags - Categorization tags');
console.log('');

console.log(' The update should now work correctly!');
console.log('The toy type will change from fish to bear (or any other type you select).');
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "types": ["react", "react-dom"],
    "typeRoots": ["../../node_modules/@types", "./node_modules/@types"] ,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules", "scripts/**", "convex/**/*"]
}
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="package.json">
{
  "name": "@pommai/web",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack -p 3000",
    "build": "next build --turbopack",
    "start": "next start -p 3000",
    "lint": "eslint",
    "type-check": "tsc --noEmit",
    "clean": "rm -rf .next .turbo node_modules"
  },
  "dependencies": {
    "@convex-dev/agent": "^0.2.4",
    "@convex-dev/better-auth": "0.7.14",
    "@convex-dev/resend": "^0.1.10",
    "@pommai/ui": "workspace:*",
    "@radix-ui/react-avatar": "^1.1.10",
    "@radix-ui/react-dialog": "^1.1.15",
    "@radix-ui/react-dropdown-menu": "^2.1.16",
    "@radix-ui/react-scroll-area": "^1.2.10",
    "@radix-ui/react-separator": "^1.1.7",
    "@types/canvas-confetti": "^1.9.0",
    "better-auth": "1.3.4",
    "canvas-confetti": "^1.9.3",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "convex": "1.25.4",
    "date-fns": "^4.1.0",
    "elevenlabs": "^1.59.0",
    "framer-motion": "^12.23.12",
    "lucide-react": "^0.540.0",
    "next": "15.5.0",
    "openai": "^5.15.0",
    "react": "19.1.0",
    "react-calendar": "^6.0.0",
    "react-dom": "19.1.0",
    "recharts": "^3.1.2",
    "tailwind-merge": "^3.3.1",
    "zustand": "^5.0.8"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "dotenv": "^16.4.5",
    "eslint": "^9",
    "eslint-config-next": "15.5.0",
    "tailwindcss": "^4",
    "typescript": "^5"
  }
}
</file>

<file path="vercel.json">
{
  "buildCommand": "cd ../.. && pnpm turbo run build --filter=@pommai/web",
  "installCommand": "pnpm install",
  "framework": "nextjs",
  "outputDirectory": ".next",
  "ignoreCommand": "git diff HEAD^ HEAD --quiet -- apps/web packages",
  "env": {
    "NEXT_PUBLIC_CONVEX_URL": "@convex_url"
  }
}
</file>

</files>
