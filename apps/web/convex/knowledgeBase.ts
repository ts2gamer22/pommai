import { v } from "convex/values";
import { mutation, query } from "./_generated/server";

/**
 * Create or update knowledge base for a toy
 */
export const upsertKnowledgeBase = mutation({
  args: {
    toyId: v.id("toys"),
    toyBackstory: v.object({
      origin: v.string(),
      personality: v.string(),
      specialAbilities: v.array(v.string()),
      favoriteThings: v.array(v.string()),
    }),
    familyInfo: v.optional(v.object({
      members: v.array(v.object({
        name: v.string(),
        relationship: v.string(),
        facts: v.array(v.string()),
      })),
      pets: v.array(v.object({
        name: v.string(),
        type: v.string(),
        facts: v.array(v.string()),
      })),
      importantDates: v.array(v.object({
        date: v.string(),
        event: v.string(),
      })),
    })),
    customFacts: v.array(v.object({
      category: v.string(),
      fact: v.string(),
      importance: v.union(v.literal("high"), v.literal("medium"), v.literal("low")),
    })),
  },
  handler: async (ctx, args) => {
    // Verify toy ownership
    const toy = await ctx.db.get(args.toyId);
    if (!toy) {
      throw new Error("Toy not found");
    }

    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Not authenticated");
    }

    const userId = identity.subject as any;
    if (toy.creatorId !== userId && toy.guardianId !== userId) {
      throw new Error("Only the toy owner can update its knowledge base");
    }

    // Check if knowledge base already exists
    const existingKb = await ctx.db
      .query("knowledgeBases")
      .withIndex("by_toy", (q) => q.eq("toyId", args.toyId))
      .first();

    const now = new Date().toISOString();

    if (existingKb) {
      // Update existing knowledge base
      await ctx.db.patch(existingKb._id, {
        toyBackstory: args.toyBackstory,
        familyInfo: args.familyInfo,
        customFacts: args.customFacts,
        updatedAt: now,
      });

      // Update toy's knowledge base reference
      if (!toy.knowledgeBaseId) {
        await ctx.db.patch(args.toyId, {
          knowledgeBaseId: existingKb._id,
          lastModifiedAt: now,
        });
      }

      return existingKb._id;
    } else {
      // Create new knowledge base
      const kbId = await ctx.db.insert("knowledgeBases", {
        toyId: args.toyId,
        toyBackstory: args.toyBackstory,
        familyInfo: args.familyInfo,
        customFacts: args.customFacts,
        memories: [],
        vectorStoreId: undefined,
        createdAt: now,
        updatedAt: now,
      });

      // Update toy with knowledge base reference
      await ctx.db.patch(args.toyId, {
        knowledgeBaseId: kbId,
        lastModifiedAt: now,
      });

      return kbId;
    }
  },
});

/**
 * Get knowledge base for a toy
 */
export const getKnowledgeBase = query({
  args: { toyId: v.id("toys") },
  handler: async (ctx, args) => {
    // Verify toy access
    const toy = await ctx.db.get(args.toyId);
    if (!toy) {
      throw new Error("Toy not found");
    }

    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Not authenticated");
    }

    const userId = identity.subject as any;
    if (toy.creatorId !== userId && toy.guardianId !== userId && !toy.isPublic) {
      throw new Error("Access denied");
    }

    const knowledgeBase = await ctx.db
      .query("knowledgeBases")
      .withIndex("by_toy", (q) => q.eq("toyId", args.toyId))
      .first();

    return knowledgeBase;
  },
});

/**
 * Add a memory to the knowledge base
 */
export const addMemory = mutation({
  args: {
    toyId: v.id("toys"),
    memory: v.object({
      description: v.string(),
      date: v.string(),
      participants: v.array(v.string()),
      autoGenerated: v.boolean(),
    }),
  },
  handler: async (ctx, args) => {
    // Verify toy ownership
    const toy = await ctx.db.get(args.toyId);
    if (!toy) {
      throw new Error("Toy not found");
    }

    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Not authenticated");
    }

    const userId = identity.subject as any;
    
    // For auto-generated memories from conversations, allow toy to add
    // For manual memories, only owner/guardian can add
    if (!args.memory.autoGenerated && 
        toy.creatorId !== userId && 
        toy.guardianId !== userId) {
      throw new Error("Only the toy owner can add memories");
    }

    const knowledgeBase = await ctx.db
      .query("knowledgeBases")
      .withIndex("by_toy", (q) => q.eq("toyId", args.toyId))
      .first();

    if (!knowledgeBase) {
      throw new Error("Knowledge base not found. Please create one first.");
    }

    // Generate unique memory ID
    const memoryId = `mem_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

    // Add memory to the array
    const updatedMemories = [
      ...knowledgeBase.memories,
      {
        id: memoryId,
        ...args.memory,
      },
    ];

    await ctx.db.patch(knowledgeBase._id, {
      memories: updatedMemories,
      updatedAt: new Date().toISOString(),
    });

    return memoryId;
  },
});

/**
 * Remove a memory from the knowledge base
 */
export const removeMemory = mutation({
  args: {
    toyId: v.id("toys"),
    memoryId: v.string(),
  },
  handler: async (ctx, args) => {
    // Verify toy ownership
    const toy = await ctx.db.get(args.toyId);
    if (!toy) {
      throw new Error("Toy not found");
    }

    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Not authenticated");
    }

    const userId = identity.subject as any;
    if (toy.creatorId !== userId && toy.guardianId !== userId) {
      throw new Error("Only the toy owner can remove memories");
    }

    const knowledgeBase = await ctx.db
      .query("knowledgeBases")
      .withIndex("by_toy", (q) => q.eq("toyId", args.toyId))
      .first();

    if (!knowledgeBase) {
      throw new Error("Knowledge base not found");
    }

    // Filter out the memory
    const updatedMemories = knowledgeBase.memories.filter(
      (mem) => mem.id !== args.memoryId
    );

    await ctx.db.patch(knowledgeBase._id, {
      memories: updatedMemories,
      updatedAt: new Date().toISOString(),
    });

    return { success: true };
  },
});

/**
 * Add custom facts to knowledge base
 */
export const addCustomFacts = mutation({
  args: {
    toyId: v.id("toys"),
    facts: v.array(v.object({
      category: v.string(),
      fact: v.string(),
      importance: v.union(v.literal("high"), v.literal("medium"), v.literal("low")),
    })),
  },
  handler: async (ctx, args) => {
    // Verify toy ownership
    const toy = await ctx.db.get(args.toyId);
    if (!toy) {
      throw new Error("Toy not found");
    }

    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Not authenticated");
    }

    const userId = identity.subject as any;
    if (toy.creatorId !== userId && toy.guardianId !== userId) {
      throw new Error("Only the toy owner can add facts");
    }

    const knowledgeBase = await ctx.db
      .query("knowledgeBases")
      .withIndex("by_toy", (q) => q.eq("toyId", args.toyId))
      .first();

    if (!knowledgeBase) {
      throw new Error("Knowledge base not found. Please create one first.");
    }

    // Append new facts to existing ones
    const updatedFacts = [...knowledgeBase.customFacts, ...args.facts];

    await ctx.db.patch(knowledgeBase._id, {
      customFacts: updatedFacts,
      updatedAt: new Date().toISOString(),
    });

    return { success: true };
  },
});

/**
 * Update family information
 */
export const updateFamilyInfo = mutation({
  args: {
    toyId: v.id("toys"),
    familyInfo: v.object({
      members: v.array(v.object({
        name: v.string(),
        relationship: v.string(),
        facts: v.array(v.string()),
      })),
      pets: v.array(v.object({
        name: v.string(),
        type: v.string(),
        facts: v.array(v.string()),
      })),
      importantDates: v.array(v.object({
        date: v.string(),
        event: v.string(),
      })),
    }),
  },
  handler: async (ctx, args) => {
    // Verify toy ownership
    const toy = await ctx.db.get(args.toyId);
    if (!toy) {
      throw new Error("Toy not found");
    }

    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Not authenticated");
    }

    const userId = identity.subject as any;
    if (toy.creatorId !== userId && toy.guardianId !== userId) {
      throw new Error("Only the toy owner can update family info");
    }

    const knowledgeBase = await ctx.db
      .query("knowledgeBases")
      .withIndex("by_toy", (q) => q.eq("toyId", args.toyId))
      .first();

    if (!knowledgeBase) {
      throw new Error("Knowledge base not found. Please create one first.");
    }

    await ctx.db.patch(knowledgeBase._id, {
      familyInfo: args.familyInfo,
      updatedAt: new Date().toISOString(),
    });

    return { success: true };
  },
});

/**
 * Search memories by keyword
 */
export const searchMemories = query({
  args: {
    toyId: v.id("toys"),
    searchTerm: v.string(),
  },
  handler: async (ctx, args) => {
    // Verify toy access
    const toy = await ctx.db.get(args.toyId);
    if (!toy) {
      throw new Error("Toy not found");
    }

    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Not authenticated");
    }

    const userId = identity.subject as any;
    if (toy.creatorId !== userId && toy.guardianId !== userId && !toy.isPublic) {
      throw new Error("Access denied");
    }

    const knowledgeBase = await ctx.db
      .query("knowledgeBases")
      .withIndex("by_toy", (q) => q.eq("toyId", args.toyId))
      .first();

    if (!knowledgeBase) {
      return [];
    }

    const searchLower = args.searchTerm.toLowerCase();

    // Search through memories
    const matchingMemories = knowledgeBase.memories.filter(mem =>
      mem.description.toLowerCase().includes(searchLower) ||
      mem.participants.some(p => p.toLowerCase().includes(searchLower))
    );

    return matchingMemories;
  },
});
