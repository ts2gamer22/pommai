#!/usr/bin/env python3
"""
Audio Stream Manager for Pommai Raspberry Pi Client
Handles real-time audio capture, compression, streaming, and playback
"""

import asyncio
import collections
import logging
import time
import struct
from typing import Optional, AsyncGenerator, Callable, Dict, Any, List
from dataclasses import dataclass
from enum import Enum
import numpy as np

import pyaudio


class AudioState(Enum):
    """Audio streaming state machine"""
    IDLE = "idle"
    RECORDING = "recording"
    STREAMING = "streaming"
    PROCESSING = "processing"
    RECEIVING = "receiving"
    PLAYING = "playing"
    ERROR = "error"


@dataclass
class AudioConfig:
    """Audio configuration parameters"""
    sample_rate: int = 16000
    channels: int = 1
    format: int = pyaudio.paInt16
    chunk_size: int = 1024
    frame_size: int = 320  # 20ms at 16kHz
    
    # Buffer configuration
    recording_buffer_size: int = 50  # ~3 seconds
    playback_buffer_size: int = 10   # ~600ms
    min_playback_buffer: int = 3     # Start playback after 3 chunks
    
    # Network configuration
    frames_per_packet: int = 3       # 60ms per network packet
    network_chunk_size: int = 960    # 60ms of audio
    
    # Performance limits
    max_recording_buffer: int = 100  # ~6 seconds
    max_playback_buffer: int = 50    # ~3 seconds


class CircularAudioBuffer:
    """Thread-safe circular buffer for audio data"""
    
    def __init__(self, maxsize: int):
        self.buffer = collections.deque(maxlen=maxsize)
        self.lock = asyncio.Lock()
        
    async def add(self, chunk: bytes):
        """Add audio chunk to buffer"""
        async with self.lock:
            self.buffer.append(chunk)
    
    async def get(self) -> Optional[bytes]:
        """Get oldest chunk from buffer"""
        async with self.lock:
            return self.buffer.popleft() if self.buffer else None
    
    async def get_all(self) -> bytes:
        """Get all buffered audio as single bytes object"""
        async with self.lock:
            return b''.join(self.buffer)
    
    async def clear(self):
        """Clear buffer"""
        async with self.lock:
            self.buffer.clear()
    
    def __len__(self) -> int:
        return len(self.buffer)


class JitterBuffer:
    """Handle network jitter and packet reordering"""
    
    def __init__(self, target_delay_ms: int = 100):
        self.buffer: Dict[int, bytes] = {}
        self.target_delay = target_delay_ms
        self.next_sequence = 0
        self.max_buffer_size = 50
        
    def add_packet(self, sequence: int, data: bytes, timestamp: float):
        """Add packet to jitter buffer"""
        if len(self.buffer) < self.max_buffer_size:
            self.buffer[sequence] = (data, timestamp)
    
    def get_packet(self) -> Optional[bytes]:
        """Get next packet in sequence"""
        if self.next_sequence in self.buffer:
            data, timestamp = self.buffer.pop(self.next_sequence)
            self.next_sequence += 1
            
            # Check if we've met target delay
            current_time = time.time() * 1000
            packet_age = current_time - timestamp
            
            if packet_age >= self.target_delay:
                return data
            else:
                # Re-add packet if not old enough
                self.buffer[self.next_sequence - 1] = (data, timestamp)
                return None
        
        # Handle missing packet
        if self.buffer and min(self.buffer.keys()) > self.next_sequence:
            # Skip missing packet
            self.next_sequence = min(self.buffer.keys())
        
        return None


class AudioStreamManager:
    """Manages audio streaming between Pi and cloud"""
    
    def __init__(self, hardware_controller, config: AudioConfig):
        self.hardware = hardware_controller
        self.config = config
        self.state = AudioState.IDLE
        
        # Audio streams from hardware controller
        self.input_stream = hardware_controller.input_stream
        self.output_stream = hardware_controller.output_stream
        
        # Buffers
        self.recording_buffer = CircularAudioBuffer(config.recording_buffer_size)
        self.playback_buffer = CircularAudioBuffer(config.playback_buffer_size)
        self.jitter_buffer = JitterBuffer()
        
        # Control flags
        self.is_recording = False
        self.is_playing = False
        self.is_streaming = False
        
        # Callbacks
        self.on_audio_chunk: Optional[Callable] = None
        self.on_silence_detected: Optional[Callable] = None
        
        # Performance monitoring
        self.stats = {
            'chunks_recorded': 0,
            'chunks_played': 0,
            'underruns': 0,
            'overruns': 0,
            'average_latency': 0
        }
        
        # Silence detection
        self.silence_threshold = 500  # RMS threshold
        self.silence_duration = 0
        self.max_silence_duration = 2.0  # 2 seconds
        
        logging.info("Audio Stream Manager initialized")
    
    async def start_recording(self, streaming: bool = True) -> None:
        """Start audio recording from microphone"""
        if self.is_recording:
            logging.warning("Already recording")
            return
        
        self.is_recording = True
        self.is_streaming = streaming
        self.state = AudioState.RECORDING
        
        # Clear buffers
        await self.recording_buffer.clear()
        
        # Start recording task
        asyncio.create_task(self._recording_loop())
        
        logging.info("Started audio recording")
    
    async def stop_recording(self) -> bytes:
        """Stop recording and return all recorded audio"""
        self.is_recording = False
        self.is_streaming = False
        
        # Wait a bit for recording to finish
        await asyncio.sleep(0.1)
        
        # Get all recorded audio
        all_audio = await self.recording_buffer.get_all()
        
        self.state = AudioState.IDLE
        logging.info(f"Stopped recording. Total size: {len(all_audio)} bytes")
        
        return all_audio
    
    async def _recording_loop(self):
        """Main recording loop"""
        sequence = 0
        
        try:
            while self.is_recording:
                # Read audio chunk
                try:
                    audio_data = self.input_stream.read(
                        self.config.chunk_size,
                        exception_on_overflow=False
                    )
                except Exception as e:
                    if "overflow" in str(e).lower():
                        self.stats['overruns'] += 1
                        # Clear buffer and continue
                        available = self.input_stream.get_read_available()
                        if available > 0:
                            self.input_stream.read(available, exception_on_overflow=False)
                        continue
                    else:
                        logging.error(f"Recording error: {e}")
                        await asyncio.sleep(0.01)
                        continue
                
                # Add to buffer
                await self.recording_buffer.add(audio_data)
                self.stats['chunks_recorded'] += 1
                
                # Check for silence
                if self._is_silence(audio_data):
                    self.silence_duration += self.config.chunk_size / self.config.sample_rate
                    if self.silence_duration >= self.max_silence_duration:
                        if self.on_silence_detected:
                            await self.on_silence_detected()
                else:
                    self.silence_duration = 0
                
                # Stream if enabled
                if self.is_streaming and self.on_audio_chunk:
                    await self.on_audio_chunk(audio_data, sequence)
                    sequence += 1
                
                # Small yield to prevent blocking
                await asyncio.sleep(0)
                
        except Exception as e:
            logging.error(f"Recording loop error: {e}")
            self.state = AudioState.ERROR
        finally:
            self.is_recording = False
    
    def _is_silence(self, audio_data: bytes) -> bool:
        """Detect if audio chunk is silence"""
        # Convert to numpy array
        audio_array = np.frombuffer(audio_data, dtype=np.int16)
        
        # Calculate RMS (Root Mean Square)
        rms = np.sqrt(np.mean(audio_array ** 2))
        
        return rms < self.silence_threshold
    
    async def play_audio_stream(self, audio_chunks: AsyncGenerator[Dict[str, Any], None]):
        """Play incoming audio stream with buffering"""
        if self.is_playing:
            logging.warning("Already playing audio - resetting state")
            # Force reset the playing state in case it's stuck
            self.is_playing = False
            self.state = AudioState.IDLE
            await asyncio.sleep(0.1)  # Small delay to let any current playback finish
        
        self.is_playing = True
        self.state = AudioState.RECEIVING
        
        # Clear playback buffer
        await self.playback_buffer.clear()
        
        try:
            # Buffer chunks until minimum reached
            chunk_count = 0
            min_buffer_reached = False
            
            async for chunk in audio_chunks:
                if not self.is_playing:
                    break
                
                # Add to buffer
                audio_data = chunk.get('data', b'')
                if audio_data:
                    await self.playback_buffer.add(audio_data)
                    chunk_count += 1
                
                # Check if minimum buffer reached
                if not min_buffer_reached and chunk_count >= self.config.min_playback_buffer:
                    min_buffer_reached = True
                    self.state = AudioState.PLAYING
                    # Start playback task
                    asyncio.create_task(self._playback_loop())
                
                # Handle final chunk
                if chunk.get('is_final', False):
                    break
            
            # If we never reached minimum buffer, play what we have
            if not min_buffer_reached and chunk_count > 0:
                self.state = AudioState.PLAYING
                await self._playback_remaining()
            
        except Exception as e:
            logging.error(f"Audio stream error: {e}", exc_info=True)
            self.state = AudioState.ERROR
        finally:
            # Wait for playback to finish with timeout
            timeout_counter = 0
            while self.is_playing and len(self.playback_buffer) > 0 and timeout_counter < 50:  # 5 second timeout
                await asyncio.sleep(0.1)
                timeout_counter += 1
            
            if timeout_counter >= 50:
                logging.warning("Playback buffer timeout - forcing cleanup")
            
            # Always reset state
            self.is_playing = False
            self.state = AudioState.IDLE
    
    async def _playback_loop(self):
        """Main playback loop"""
        try:
            logging.info(f"PLAYBACK LOOP: Starting, output_stream={self.output_stream}")
            chunks_written = 0
            while self.is_playing:
                # Get audio from buffer
                audio_data = await self.playback_buffer.get()
                
                if audio_data:
                    # Play audio
                    try:
                        logging.debug(f"PLAYBACK: Writing chunk {chunks_written+1}, size={len(audio_data)} bytes")
                        self.output_stream.write(audio_data)
                        self.stats['chunks_played'] += 1
                        chunks_written += 1
                        if chunks_written == 1:
                            logging.info("PLAYBACK: First chunk successfully written to output stream")
                    except Exception as e:
                        if "underflow" in str(e).lower():
                            self.stats['underruns'] += 1
                            logging.warning(f"PLAYBACK: Buffer underflow, inserting silence")
                            # Insert small silence to recover
                            silence = b'\x00' * len(audio_data)
                            self.output_stream.write(silence)
                        else:
                            logging.error(f"PLAYBACK ERROR: Failed to write to output stream: {e}")
                            # Try to recover by clearing the buffer and continuing
                            try:
                                logging.info("PLAYBACK: Attempting to recover output stream...")
                                await self.playback_buffer.clear()
                                await asyncio.sleep(0.1)
                                # Set flag to stop playback
                                self.is_playing = False
                                break
                            except:
                                pass
                else:
                    # Buffer empty, wait a bit
                    await asyncio.sleep(0.01)
                    
                    # Check if we should stop
                    if not self.is_playing or (len(self.playback_buffer) == 0 and self.state != AudioState.RECEIVING):
                        break
                        
        except Exception as e:
            logging.error(f"Playback loop error: {e}", exc_info=True)
            self.state = AudioState.ERROR
        finally:
            # Ensure playback state is cleared
            self.is_playing = False
    
    async def _playback_remaining(self):
        """Play any remaining audio in buffer"""
        while len(self.playback_buffer) > 0:
            audio_data = await self.playback_buffer.get()
            if audio_data:
                try:
                    self.output_stream.write(audio_data)
                    self.stats['chunks_played'] += 1
                except Exception as e:
                    logging.error(f"Final playback error: {e}")
    
    async def play_audio_data(self, audio_data: bytes):
        """Play pre-loaded audio data"""
        if self.is_playing:
            logging.warning("Already playing audio")
            return
        
        self.is_playing = True
        self.state = AudioState.PLAYING
        
        try:
            # Split into chunks
            chunk_size = self.config.chunk_size * 2  # 16-bit samples
            chunks = [audio_data[i:i + chunk_size] for i in range(0, len(audio_data), chunk_size)]
            
            # Play chunks
            for chunk in chunks:
                if not self.is_playing:
                    break
                    
                try:
                    self.output_stream.write(chunk)
                    self.stats['chunks_played'] += 1
                except Exception as e:
                    logging.error(f"Playback error: {e}")
                
                # Small delay between chunks
                await asyncio.sleep(0)
                
        except Exception as e:
            logging.error(f"Audio playback error: {e}")
            self.state = AudioState.ERROR
        finally:
            self.is_playing = False
            self.state = AudioState.IDLE
    
    def stop_playback(self):
        """Stop audio playback"""
        self.is_playing = False
        logging.info("Stopped audio playback")
    
    def set_volume(self, volume: float):
        """Set output volume (0.0 to 1.0)"""
        # This would need ALSA mixer integration
        # For now, just log
        logging.info(f"Volume set to {volume * 100:.0f}%")
    
    def get_stats(self) -> Dict[str, Any]:
        """Get performance statistics"""
        return {
            **self.stats,
            'recording_buffer_size': len(self.recording_buffer),
            'playback_buffer_size': len(self.playback_buffer),
            'state': self.state.value
        }
    
    async def test_audio_levels(self, duration: float = 5.0):
        """Monitor audio input levels for testing"""
        logging.info(f"Testing audio levels for {duration} seconds...")
        
        start_time = time.time()
        max_level = 0
        
        while time.time() - start_time < duration:
            try:
                audio_data = self.input_stream.read(self.config.chunk_size, exception_on_overflow=False)
                audio_array = np.frombuffer(audio_data, dtype=np.int16)
                
                # Calculate RMS
                rms = np.sqrt(np.mean(audio_array ** 2))
                level = min(100, int(rms / 32768 * 200))
                
                if level > max_level:
                    max_level = level
                
                # Log every second
                if int(time.time() - start_time) % 1 == 0:
                    logging.info(f"Audio level: {level}% (Max: {max_level}%)")
                    
            except Exception as e:
                logging.error(f"Level test error: {e}")
                
            await asyncio.sleep(0.1)
        
        logging.info(f"Audio level test complete. Max level: {max_level}%")
        return max_level

    # Convenience helpers for client compatibility
    async def initialize(self) -> None:
        """No-op initializer for API compatibility."""
        return None

    async def read_chunk(self):
        """Read one input chunk and return as numpy int16 array."""
        try:
            data = self.input_stream.read(self.config.chunk_size, exception_on_overflow=False)
            return np.frombuffer(data, dtype=np.int16)
        except Exception as e:
            logging.error(f"read_chunk error: {e}")
            return None

    async def play_audio(self, pcm_bytes: bytes):
        """Play a single PCM buffer (bytes)."""
        try:
            await self.play_audio_data(pcm_bytes)
        except Exception as e:
            logging.error(f"play_audio error: {e}")

    async def cleanup(self) -> None:
        """Cleanup hook; streams are owned by hardware controller."""
        # Ensure playback loop is stopped
        self.is_playing = False
        return None
